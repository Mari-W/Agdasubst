
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
\usepackage{microtype}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\nolinenumbers

\usepackage{agda}

\input{unicodeletters}
\input{agdamacros}

\definecolor{agdablue}{HTML}{0000CD}
\DisableLigatures[-]{encoding=T1}
\newcommand{\bsym}[1]{\textcolor{agdablue}{#1}}
\newcommand{\tdot}{\mkern2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern1mu}

\bibliographystyle{plainurl}
\title{Strictifying the Sigma Calculus}

\author{Marius Weidner}{University of Freiburg, Germany}{weidner@cs.uni-freiburg.de}{0009-0008-1152-165X}{}
\authorrunning{Marius Weidner}
\Copyright{Marius Weidner}

\keywords{Explicit Substitutions, Rewrite Systems, Agda}

\ccsdesc[300]{Theory of computation~Equational logic and rewriting}

\begin{document}
\AgdaNoSpaceAroundCode{}

\input{systemf}
\input{examples}

\maketitle

\begin{abstract}

      Choosing a representation of variable bindings and substitutions is a central
      challenge in mechanizing programming language metatheory. De Bruijn indices
      provide a canonical representation, but developments based on them require
      numerous lemmas about substitution composition and interaction with binders,
      leading to significant proof overhead.

      The $\sigma$-calculus treats parallel substitutions as first-class objects
      equipped with primitive operations and a terminating, confluent, and complete
      rewrite system that normalizes substitution expressions. While previous work
      has exploited these rewriting rules to implement decision procedures, the
      resulting equalities remain propositional.

      Recent support for user-defined rewrite rules in mainstream proof assistants
      enables the promotion of propositional equalities to definitional ones. To
      retain logical consistency the set of equational rules must be confluent and
      supported by proofs. However, obtaining these proofs requires modeling
      substitutions as functions, which in turn leads to violations of the syntactic
      restrictions on rewrite rules.

      In the context of the proof assistant Agda, we embed the rules of the
      $\sigma$-calculus such that they satisfy the criteria for rewrite rules while
      retaining their provability. This approach yields built-in normalization of
      substitutions while preserving logical consistency and full computational
      behavior.

      Our development is reusable: from an Autosubst specification, we automatically
      generate the required $\sigma$-calculus infrastructure and rewrite rules. To
      our knowledge, this is the first safe integration of the full $\sigma$-calculus
      by definitional rewriting in a proof assistant.
\end{abstract}

\section{Introduction}\label{sec:introduction}

Choosing a representation of variable bindings and substitutions is a central
challenge in mechanizing programming language metatheory. De Bruijn indices
provide a canonical representation, but developments based on them require
numerous lemmas about substitution composition and interaction with binders,
leading to significant proof overhead.

On paper substitution often is an operation that replaces just a single
variable. However, in proof assistants we commonly use parallel substitution,
that is maps from variables to terms, which replace multiple variables
simultaneously.
\subsection{The Sigma Calculus in \textsc{Autosubst}}

The $\sigma_{SP}$-calculus~\cite{}, an improved variant of the original
$\sigma$-calculus~\cite{}, treats parallel substitutions as first-class objects
equipped with primitive operations and a terminating, confluent~\cite{}, and
complete~\cite{} rewrite system that normalizes substitution expressions. We
refer to the $SP$ variant simply as the $\sigma$-calculus throughout this work.
We refer to the PhD thesis of Stark~\cite{Stark:2020:Mechanising} for a more
complete account of the history of explicit substitution calculi in the context
of their usage in proof assistants.

While previous work has exploited these equations to implement decision
procedures, the resulting equalities remain propositional. The creators of
\textsc{Autosubst}~\cite{} were the first to provide a decision procedure using
the $\sigma$-calculus rules for unscoped syntax definitions in the Rocq proof
assistant.

The successor \textsc{Autosubst 2}~\cite{} is now regarded the gold standard
for libraries that handle substitutions in proof assistants. \textsc{Autosubst
      2} supports intrinsically scoped syntax where the syntax data type is indexed
over the number of free variables and variable usage is restricted to the
variables in scope, by construction. Furthermore, \textsc{Autosubst 2}
generates syntax dependent $\sigma$-calculus rules from higher order abstract
syntax descriptions and enables reasoning about syntaxes with multiple sorts
via vectors of parallel substitutions.

\textsc{Autosubst 2} also includes support for first class
renamings, a special case of substitutions that map
variables to variables. Idependently of first class support,
they are required in proof assistants to model
substitutions in a structurally recursive manner that the termination checker
accepts~\cite{10.1007/11617990_1}.
The creators of \textsc{Autosubst 2} extended the equational theory of
the $\sigma$-calculus with additional rules that handle renamings although they lose completeness of the decision procedure in
the process. The authors conjecture the extended system preserves confluence but never
formally proved so~\cite{}.

\subsection{The Problem with Rewrite Rules}% TODO
Recent support for user-defined rewrite rules in mainstream proof assistants
enables the promotion of propositional equalities to definitional ones~\cite{}.
To retain logical consistency the set of equational rules must be confluent and
supported by proofs~\cite{}. However, obtaining these proofs requires modeling
substitutions as functions, which in turn leads to violations of the syntactic
restrictions on rewrite rules.

More specifically, Agda and other proof assistants performs higher-order
pattern unification to detect if a registered rewrite rule can be applied to a
stuck term~\cite{}. When we model substitution as functions, some primitive
operations of the $\sigma$-calculus generate stuck lambda functions that are
not eligible for higher-order pattern unification, thereby violating the
syntactic restriction that the LHS must be a stuck symbol and not a lambda.
Others tried to model substitution via constructors, but then we miss the
computational behaviour of substitutions required to instantiate the rule set
of the $\sigma$-calculus with proofs and in turn preservation of logical
consistency.

The solve our problem, we require more control over the reduction behaviour of
symbols. Luckily, Agda supports opaque definitions~\cite{}, that allow to
selectively block and later unfold the implementation of function definitions.
With opaque definitions we can have the best of both worlds: we treat the
substitutions primitives from the $\sigma$-calculus as blocking symbols so we
can apply the rewrite rules, but also unfold their definitions to prove the
rule set using their underlying function model. Not only does this help with
rewriting the $\sigma$-calculus, we also believe that this technique could be
applied to other structures that come with an confluent rewrite system.

\subsection{Content of this Paper}
We demonstrate in this work how to register the $\sigma$-calculus rules as
rewrite rules to produce definitional equalities in Agda. Our approach differs
from previous attempts because it completely preserves both the full
computational behavior of substitutions and the logical consistency of the
system.

\subsection*{Structure}
\Cref{sec:pre} introduces the
required background for the $\sigma$-calculus and Agda. \Cref{sec:mis}
demonstrates how to register the $\sigma$-calculus with first class renamings as
rewrite rules intrinsically scoped syntax exemplified by System
F and discusses the challenges in detail. We discuss related work in
\cref{sec:rwk}, outline directions for future work in \cref{sec:wrk} and
conclude the paper in \cref{sec:con}.

\subsection*{Contributions}
We show how to rewrite the $σ$-calculus with first class renamings for scoped
and multi-sorted syntax in Agda. We do this while preserving the logical
consistency of the system.

As a side effect we prove the extension with first class renamings confluent
via Agdas builtin confluence checker. We also show that this approach
translates to any scoped syntax by implementation of a code generation script
for Autosubst higher-order abstract syntax descriptions.

\noindent\textbf{The supplement contains the complete Agda code underlying this paper.}

\section{Preliminaries}\label{sec:pre}
We begin with a review of material from the literature. We summarize
\begin{itemize}
      \item Agda and language features relevant to our work: rewrite rules and opaque
            blocks;
      \item multi-sorted and scoped syntax in Agda and
      \item the $\sigma$-calculus.
\end{itemize}

\subsection{Agda and Relevant Language Features}\label{sec:pre-agd}
Agda is a dependently typed functional language and proof assistant based on
Martin-Löf type theory~\cite{MARTINLOF197573}, where proofs are verified via
type checking. Proofs are significantly easier when terms are
\textit{definitionally equal} (i.e.\ reduce to the same term). When terms are
not definitionally equal, users must resort to manual equational reasoning
using propositional equality, which is a cumbersome process as Agda lacks
automated proof-discharge tactics. Maximizing definitional equalities thus
directly reduces manual effort (and allows for more complex intrinsic
constructions that avoid `transfer hell').

Beyond standard features such as indexed inductive types and dependent pattern
matching~\cite{10.1145/3236770}, this work is based on two more language
features.

\subsection*{Rewrite Rules}
User-defined rewrite rules~\cite{10.1145/3434341, cockx:LIPIcs.TYPES.2019.2}
extend Agda’s computation by treating propositional equalities as reduction
rules. A function $\AgdaFunction{eq} : (x_1 : A_1) \ldots \to
      \AgdaFunction{f}\, p_1 \ldots p_n \, \AgdaFunction{≡} \, v$ can be registered
as a rewrite rule if:
\begin{enumerate}
      \item The head \AgdaFunction{f} is a postulate, defined function, or constructor with
            distinct variable type parameters.
      \item Every variable $x_i$ appears in a pattern position among $p_1, \ldots, p_n$.
            The following pattern positions are relevent to us:\footnote{The Agda
                  documentation includes a complete definition for pattern positions:
                  \url{https://agda.readthedocs.io/en/latest/language/rewriting.html}}:
            \begin{enumerate}
                  \item $x \, y_1 \ldots y_n$, where $x$ is a pattern variable and $y_1, \ldots, y_n$ are distinct variables that are bound locally in the pattern.
                  \item $\AgdaFunction{f} \, p_1 \ldots p_n$, where $f$ is a postulate, a defined function, a constructor, or a data/record type, and $p_1, \ldots, p_n$ are again patterns.
                  \item $\lambda \, x \to p$, where $p$ is again a pattern.
                  \item $y \, p_1 \ldots p_n$, where $y$ is a variable bound locally  and $p_1, \ldots, p_n$ are again patterns.
            \end{enumerate}
      \item The left side is neutral (it does not further reduce).
\end{enumerate}

\noindent For example, the right identity of addition satisfies these criteria:
\ERewrite{} Once registered via \ERewriteIt{}, Agda treats \AgdaBound{n}
\AgdaFunction{+} \AgdaNumber{0} as definitionally equal to \AgdaBound{n}: \ERewriteEx{}

Users must ensure that the rewrite rule set as a whole is terminating and
confluent to retain logical consistency. Agda provides confluence checks via
\texttt{--confluence-check} and \texttt{--local-confluence-check}. Termination
is not verified, but also not a critical property~\cite{10.1145/3434341}. Given
the rules we rewrite are proven and the rewrite system is terminating, local
confluence preserves consistency, otherwise full confluence is
required~\cite{10.1145/3434341}.

\subsection*{Opaque Blocks}
Opaque definitions~\cite{gratzer2022controlling} let the user treat code as
non-unfolding symbols. Definitions within an \AgdaKeyword{opaque} block are
visible but treated abstractly during type checking: \EOpaque{} Outside this
block, \AgdaFunction{forty-two} does not reduce to \AgdaNumber{42}:
\EOpaqueExO{} However, the \AgdaKeyword{unfolding} keyword can be used to
expose the computational behavior of the underlying definition when needed:
\EOpaqueExT{}

\subsection{Multi-Sorted and Scoped Syntax}\label{sec:pre-syn}
\begin{figure}[t]
      \footnotesize
      \setlength{\mathindent}{0pt}
      \setlength{\AgdaEmptySkip}{\smallskipamount}
      \begin{minipage}[t]{0.43\linewidth}
            \raggedright{}
            \EScoped{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.55\linewidth}
            \raggedright{}
            \EMultiSorted{}
      \end{minipage}
      \caption{Classically vs. Multi-Sorted and Scoped Syntax}\label{fig:pre-svm}
\end{figure}

Many languages feature multiple syntactic categories.
System~F~\cite{girard1972, 10.1007/3-540-06859-7_148}, for instance, has
expressions, types, and kinds. To prevent scoping errors, we use
\textit{intrinsically scoped syntax}, where the syntax data type is indexed
over the number of free variables to ensure terms are correctly scoped by
construction. \Cref{fig:pre-svm} (left) shows a standard implementation: types
are indexed by the amount of type variables, and expressions by both type and
expression variable counts. Variables use de Bruijn indices of type
\AgdaDatatype{Fin} \AgdaBound{n}, that is, natural numbers strictly less than
the number of free variables. This representation restricts the set of terms to
only well-scoped terms. Unfortunately this standard representation requires
defining many substitution operations (e.g., type-in-type, type-in-expr,
expr-in-expr).

To avoid this combinatorial explosion, we unify the syntax in two orthogonal
dimensions, presented also in \cref{fig:pre-svm} (right). Variables and terms
form a single datatype \AgdaBound{S} \AgdaDatatype{⊢[} \AgdaBound{m}
\AgdaDatatype{]} \AgdaBound{s} indexed by a \AgdaDatatype{Mode} \AgdaBound{m},
a target \AgdaDatatype{Sort} \AgdaBound{s} and a \AgdaDatatype{Scope}
\AgdaBound{S}. Modes distinguish constructors for variables and terms.
Variables are represented across multiple sorts simultaneously by natural
numbers of type \AgdaBound{S} \AgdaDatatype{∋} \AgdaBound{s} and act as de
Bruijn indices. The position of \AgdaBound{s} in \AgdaBound{S} directly
corresponds to the debruijn index of the variable. Using the unified syntax, we
can later define scoped and multi-sorted renamings and substitutions that
operate uniformly across all sorts, thereby avoiding vector substitions.% TODO: mehr text? 

\subsection{The Sigma Caclulus}\label{sec:pre-sig}
\begin{figure}[t]
      \centering
      \footnotesize
      \begin{minipage}[t]{0.44\textwidth}
            \raggedright
            \textbf{Traversal Rules}
            \begin{alignat*}{2}
                  \mathsf{lam} \quad & (\textcolor{agdablue}{λ.}\, t)                                         & \tdot σ
                                     & = \textcolor{agdablue}{λ.} (t \tdot (\textcolor{agdablue}{\uparrow}σ))           \\
                  \mathsf{app} \quad & (t_1 \ t_2)                                                            & \tdot σ
                                     & = (t_1 \tdot σ) \ (t_2 \tdot σ)
            \end{alignat*}
            \textbf{Monad Rules}
            \begin{alignat*}{2}
                  \mathsf{right\text{-}id} \quad  & t \tdot \textcolor{agdablue}{\mathsf{id}} &  & = t                                         \\
                  \mathsf{compositionality} \quad & (t \tdot σ_1) \tdot σ_2                   &  & = t \tdot (σ_1 \textcolor{agdablue}{;} σ_2)
            \end{alignat*}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright{}
            \textbf{Interaction Rules}
            \begin{alignat*}{2}
                  \mathsf{id}_\mathsf{L} \quad   & \textcolor{agdablue}{\mathsf{id}} \ \textcolor{agdablue}{;} \ σ                                                                             &  & = σ                                                                               \\
                  \mathsf{id}_\mathsf{R} \quad   & σ \ \textcolor{agdablue}{;} \ \textcolor{agdablue}{\mathsf{id}}                                                                             &  & = σ                                                                               \\
                  \mathsf{associativity} \quad   & (σ_1 \ \textcolor{agdablue}{;} \ σ_2) \ \textcolor{agdablue}{;} \ σ_3                                                                       &  & = σ_1 \ \textcolor{agdablue}{;} \ (σ_2 \ \textcolor{agdablue}{;} \ σ_3)           \\
                  \mathsf{distributivity} \quad  & (t \textcolor{agdablue}{\cdot} σ_1) \ \textcolor{agdablue}{;} \ σ_2                                                                         &  & = (t \tdot σ_2) \textcolor{agdablue}{\cdot} (σ_1 \ \textcolor{agdablue}{;} \ σ_2) \\
                  \mathsf{interaction} \quad     & \textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \ (t \textcolor{agdablue}{\cdot} σ)                                             &  & = σ                                                                               \\
                  \eta\mathsf{\text{-}id} \quad  & (\textcolor{agdablue}{\mathsf{zero}}) \textcolor{agdablue}{\cdot} \textcolor{agdablue}{\mathsf{wk}}                                         &  & = \textcolor{agdablue}{\mathsf{id}}                                               \\
                  \eta\mathsf{\text{-}law} \quad & (\textcolor{agdablue}{\mathsf{zero}} \tdot σ) \textcolor{agdablue}{\cdot} (\textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \ σ) &  & = σ
            \end{alignat*}
      \end{minipage}
      \caption{The Sigma Calculus Rules}\label{fig:pre-sig}
\end{figure}
We review the variant of the $\sigma$-calculus which also appears in the
first version of \textsc{Autosubst}~\cite{schafer2015autosubst}. Variables $x$
represent natural numbers and terms $t := x \,|\, \textcolor{agdablue}{λ.}\, t
      \,|\, t₁ \, t₂ $ include the standard lambda calculus constructors as an
example for any single sorted syntax with binding. A substitution $\sigma$ maps
variables to terms. It helps to view a substitution as a stream of terms $(t_0,
      t_1, \dots)$ that supports a shift operation for binders. This perspective
motivates the definition of the extension operation $t
      \textcolor{agdablue}{\cdot} \sigma$, the identity
$\textcolor{agdablue}{\mathsf{id}}$ and the weakening substitution
$\textcolor{agdablue}{\mathsf{wk}}$
\begin{align*}
      (t \textcolor{agdablue}{\cdot} \sigma)(0)   & := t         & \textcolor{agdablue}{\mathsf{id}}(x) & := x     \\
      (t \textcolor{agdablue}{\cdot} \sigma)(x+1) & := \sigma(x) & \textcolor{agdablue}{\mathsf{wk}}(x) & := x + 1
\end{align*}

We then define the application of a substitution to a term $\tdot$, referred to
as instantiation, mutually recursively with composition and the
\bsym{\textsf{lift}} operator which pushes substitutions under binders:
\begin{align*}
      (\textcolor{agdablue}{λ.}\, t)  \, \tdot \, σ
                                             & = \textcolor{agdablue}{λ.} (t \tdot (\textcolor{agdablue}{\uparrow}σ)) & (\sigma_1 \
      \textcolor{agdablue}{⨟} \ \sigma_2)(x) & = \sigma_1(x) \tdot \sigma_2                                                                                                                           \\
      (t_1 \ t_2)                            \, \tdot \, σ
                                             & = (t_1 \tdot σ) \ (t_2 \tdot σ)                                        & \textcolor{agdablue}{\uparrow}\sigma & := \textcolor{agdablue}{\mathsf{zero}}
      \textcolor{agdablue}{\cdot} (\sigma \ \textcolor{agdablue}{⨟} \
      \textcolor{agdablue}{\mathsf{wk}})
\end{align*}
Lifting
preserves the bound variable while it weakens the terms of the substitution to
maintain correct scoping.

\Cref{fig:pre-sig} presents the accompanying rewrite system. It traditionally also includes the
definition of the instantiation function.
We follow Stark~\cite{Stark:2020:Mechanising} and categorize the reduction rules into three groups.
\begin{itemize}
      \item \textbf{Traversal} rules govern propagation through terms and under binders.
      \item \textbf{Monad rules} define the behavior of substitutions applied to terms.
      \item \textbf{Interaction rules} describe equalities between substitution expressions.
\end{itemize}
We refer the reader to the original $\sigma_{SP}$-calculus paper~\cite{10.1145/2676724.2693163}
for a detailed description of the rule set selection.
\section{Strictifying the Sigma Calculus}\label{sec:mis}

The definition of instantiation via mutual recursion with composition
complicates termination. Agda specifically cannot determine that this
definition is structurally recursive. Because of that we follow
Adams~\cite{10.1007/11617990_1} to resolve this issue and first define
instantiation for renamings. We then extend the above categories to handle
first class renamings and to connect substitutions with renamings analogous of
Autosubst 2~\cite{10.1145/3293880.3294101}. We use the multi-sorted and scoped
version of System F from \Cref{fig:pre-svm} as an example for any scoped
syntax. The approach described in this section translates directly to any
multi-sorted and scoped syntax as well as simple intrinsically typed syntax
where the type index of the syntax has type \AgdaDatatype{Set}.

\subsection{Renaming and Substitution}\label{sec:mis-sub}
\begin{figure}[t]
      \setlength{\mathindent}{0pt}
      \setlength{\AgdaEmptySkip}{\smallskipamount}
      \begin{minipage}[t]{0.33\linewidth}
            \raggedright{}
            \ERen{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.55\linewidth}
            \raggedright{}
            \ESub{}
      \end{minipage}
      \caption{The Primitives for Renaming and substitution}\label{fig:mis-ras}
\end{figure}
The key to rewriting the $\sigma$-calculus rules already shows in the definitions of renamings and substitutions where we will mark certain definitions opaque.
The corresponding code is presented in \Cref{fig:mis-ras}.

We begin with the definition of renamings \AgdaFunction{\_→ᴿ\_} which map
variables of sort \AgdaBound{s} from scope \AgdaBound{S₁} to variables of the
same sort in scope \AgdaBound{S₂}. We then define the renaming primitives
identity \AgdaFunction{id} and weakening \AgdaFunction{wk} and forward
composition \AgdaFunction{\_∘\_}.

Lifting \AgdaFunction{\_↑ᴿ\_} is defined directly to avoid a definition for the
extension of renamings, which is unnecessary because renamings merely need to
shift variables. The traversal operation \AgdaFunction{\_⋯ᴿ\_} propagates the
renaming through the syntax to the variables and applies lifting when it passes
under binders. We define instantiation across both modes to match the
definition of substitution instantiation later. The computational behavior of
renamings follows the behavior of functions almost entirely. We require only a
few additional \AgdaKeyword{REWRITE} rules later to extend the definitional
equalities of renamings.

Substitutions map variables to terms rather than variables. The operator
\AgdaFunction{⟨\_⟩} embeds any renaming into a substitution by wrapping the
resulting variable of the renaming in the variable constructor. We define the
identity substitution \AgdaFunction{idˢ} and weakening substitution
\AgdaFunction{wkˢ} directly from renamings. We \AgdaKeyword{INLINE} these
symbols to prevent Agda from rejecting rewrite rules due to reductions on the
left hand side. Extension \AgdaFunction{\_∙\_} is defined by case analysis on
the incoming variable.

We use renaming with a weakening to define the lifting of substitutions
\AgdaFunction{\_↑ˢ\_}, therby satisfying the requirements of structural
recursion.

Instantiation with a substitution \AgdaFunction{\_⋯ˢ\_} works analogous to the
case of renamings and we design it to work for variables and terms
simultaneously. This allows us to do lookup by usage of the instantiation
operator\footnote{Note that we could have introduced a separate symbol for
      lookup in substitutions but the unified approach allows us to state some rules
      across both modes.}. Finally we define the forward composition of substitutions
\AgdaFunction{\_⨟\_} via instantiation with the weakening renaming.

We declare all substitution primitives as \AgdaKeyword{opaque} to block their
reduction. This abstraction hides the function-like computational behaviour of
the primitives. We do this because we will be able to rewrite all
$\sigma$-calculus rules only on the blocking symbols but not on the unfolding
definitions. For instance, composition would reduce to a lambda function, which
would make some $\sigma$-calculus not admissable for rewriting.
\Cref{sec:mis-ex} details this discrepancy.

\subsection{The Sigma Calculus Rules}\label{sec:mis-sig}
\begin{figure}[t]
      \setlength{\mathindent}{0pt}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \EDefLaws{}
            \EInteractLaws{}
            \ERewriteSys{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ECoincidenceLaws{}
            \ETraversalLaws{}
            \EMonadLaws{}
      \end{minipage}
      \caption{The Rewrite System for the Sigma Calculus with First Class Renamings}\label{fig:mis-sig}
\end{figure}
\Cref{fig:mis-sig} presents the $\sigma$-calculus rules with first class renamings
as Agda equalities that we add as rewrite rules.
Agda accepts the rule set as confluent which is important for safety.
Before rewriting we \emph{prove} all the rules to guarantee logical consistency~\cite{10.1145/3434341}.
We now discuss the changes to the standard $\sigma$-calculus variant from \Cref{sec:pre-sig}.

First class renamings introduce three new categories specifically First Class
Renaming rules and Definitional rules and Coincidence rules.

The \textbf{First Class Renamings rules} include a single rule which states
that the lifting of the identity renaming remains the identity. This property
does not hold definitionally because the lifting of renamings is defined via a
case split on the incoming variable but also it is strictly required for a
confluent account. All other properties we expect of renamings such as
associativity hold definitionally.

The \textbf{Definitional rules} include definitions we blocked earlier in a
slightly modified form. We include the clauses from the definition of extension
but the instantiation operator handles the lookup of variables in a
substitution instead of function application. Lookup in composed substitutions
and lifiting of substitutions (via composition) is also defined in terms of the
instantiation operator for variable lookup in substitutions.

The \textbf{Interaction rules} include a minor change. Since instantiation with
renamings is available as a first class construct we must add a version of the
$\eta$-law for renamings where instantiation appears as a blocking symbol.

The \textbf{Coincidence rules} emerge from the interaction between renamings
and substitutions~\cite{10.1145/3293880.3294101} and allow us to recover
renamings from their embedding as substitutions. We state them uniformly for
variables and terms \AgdaBound{x/t} traversed by a substitution because we also
want to coerce variable lookup in substitutions to variable lookup in
renamings. The extraction of arbitrary renamings from deeply nested
substitutions requires a dedicated solving strategy which we leave for future
work. However we require a specific coincidence variant called
\AgdaFunction{coincidence-fold} for the proof of subject reduction of System F.
Every proof might require more coincidence lemmas and we are currently trying
to figure out the patterns. For instance subject reduction might require the
inclusion of lemmas in the style of \AgdaFunction{coincidence-fold} with $n$
extensions where $n$ is the maximum arity of binders in the object language.

\textbf{Traversal rules} mirror the clauses from the instantiation
definitions in the previous section directly.
We include all clauses except the one for variables.
This exclusion is important because we wanted the term \AgdaBound{x} \AgdaFunction{⋯ˢ} \AgdaBound{σ} to remain stuck and not reduce to function application.

We extend the \textbf{Monad rules} to handle all four combinations of
instantiation with renamings and substitutions. We state the right identity law
only for renamings because the instantiation with the identity substitution
reduces to instantiation with the identity renaming via
\AgdaFunction{coincidence}.

The proofs of the rules are standard and we refer the interested reader to the
supplement. Within the proofs we unfold the opaque definitions and make use of
function extensionality which is conservative over the theory underlying
Agda~\cite{Hofmann1997}.

\subsection{An Example Proof with the Strictified Sigma Calculus}
\begin{figure}[!t]
      \setlength{\mathindent}{0pt}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESPT{}
      \end{minipage}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESR{}
      \end{minipage}
      \caption{Subject Reduction for System F}\label{fig:ext-rst}
\end{figure}
The rewritten equations of the $\sigma$ calculus apply automatically throughout
the subsequent code. We demonstrate this with a proof of subject reduction
which proceeds where we never need to explicitly manage substitutions. We
outline a subject reduction for a standard logical type system for System F
\AgdaDatatype{\_⊢\_:\_} and call-by-value semantics \AgdaDatatype{\_↪\_}. We
refer to the supplement for the full example and all definitions.

To establish subject reduction, we first prove that renaming and substitution
preserve typing. The left side of \cref{fig:ext-rst} displays the proofs for
the substitution-preserves-typing lemma \AgdaFunction{\_⊢⋯ˢ\_}. We omit the
analogous proof for renamings \AgdaFunction{\_⊢⋯ᴿ\_}. The result for renamings
is used to prove that the lifting of a substitution preserves typing
\AgdaFunction{⊢↑ˢ} and subsequently show that general substitution preserves
typing \AgdaFunction{\_⊢⋯ˢ\_}. The proof relies on the predicate of well typed
substitutions \EWTS{}. The variable cases require a lookup of the well typed
variable in the well typed substitution. We apply the preservation lemma for
the lifted substitutions when we pass under a binder. The proofs follow without
any manipulation of substitutions. In particular we do not need to manually
move the substitution under a weakening inside the caes for binders or under a
singleton substitution in the case of type application which is normally
required in standard proofs.

Subject reduction \AgdaFunction{sr} directly follows from the substitution
preserves typing lemma, shown on the right of \cref{fig:ext-rst}. The rewrite
rules automatically handle the otherwise required application of interaction
rules in the cases of $β$-reductions. Here \AgdaFunction{⊢[]} is the well typed
single substitution which can be derived directly from the substitution
preserves typing lemma.

This example demonstrates the applicability on a small scale. We also applied
our approach to the $π$-calculus in an unrelated project to construct a logical
relation. In that setting we also avoided manual reasoning over substitutions
entirely.

\subsection{An Examination of the Issue with Unfolding Definitions}\label{sec:mis-ex}
% We have seen that we try to hide the fact that substitutions are actually
% functions declaring all the primitives opaque. The reasons for this are
% twofold.
% 
% The first issue is the unfolding of composition to a lambda function. If we
% inline the definition for composition, for instance the left hand side (LHS) of
% \AgdaFunction{comp-idₗ} rule would reduce to \EIdLawUnfolded{} and not
% constitute a valid rewrite rule, violating the constraint that rewrite rules
% must be blocking symbols.
% 
% We could think about only blocking the definition of composition, but this is
% still not enough. To see why, we look at the LHS of the \AgdaFunction{η-lawˢ}:
% \EEtaLaw{} If we let the definition of instantiation reduce but keep
% composition unreduced on the LHS, we get this term: \EEtaLawUnfolded{}. But
% this LHS is not a valid rewrite rule ether, because $\sigma$ does not appear in
% pattern position. The first appearance of $\sigma$ is not in pattern position
% because it is applied to \AgdaInductiveConstructor{zero} which violates the
% constraint of the restriction of rewrite rules from \textbf{2.a} in
% \Cref{sec:pre-agd}. The second appearance suffers the same issue after we apply
% condition \textbf{2.c}. We fix the issue by blocking the definition of
% instantiation for variables and then using instantiation instead of function
% application. This successfully fulfills condition \textbf{2.b} and makes
% $\sigma$ appear as a pattern variable. This change to use \AgdaFunction{\_⋯ˢ\_}
% instead of function application must propagate through all definitions so the
% rules also apply when we want to solve equations that use the composition
% operation.

While we are still able to use function application or build substitions using
lambdas, we then obtain fewer definitional equalities. Thus, we recommend using
only instantiation for variable lookup and only the already defined composition
operators.

We also considered an alternative representation for substitutions based on a
vector structure. However the $\eta$ law is not provable in this setting
because then extension corresponds to the cons constructor of the vector. As a
consequence, it would prevent the instantiation of our rewrite system with
proofs to guarantee consistency.

\subsection{Discussion}\label{sec:mis-dis}
The rules presented in \cref{sec:mis-sig} are an extension of the classic
$\sigma$-calculus rules to a setting with renamings, closely following the work
done by the \textsc{Autosubst} team. After careful construction, marking the
relevant symbols opaque, they fulfill the requirements to be registered as
rewrite rules. Moreover Agda can see that the rule set preserves confluence of
the system. Inside the proofs of the rules themselves, the definitions can
still unfold when needed, while externally they behave as uninterpreted symbols
and are reduced only by the $σ$-calculus rules.

This construction reveals a broader concept that serves as a general recipe for
integrating algebraic laws over complex structures into proof assistants:
\begin{itemize}
      \item Define symbols for the structure.
      \item Establish a corresponding confluent rewrite system.
      \item Instantiate the structure with an underlying model to prove the laws of the
            rewrite system inside an \AgdaKeyword{opaque} block.
      \item With the reduction of the model hidden, \AgdaKeyword{REWRITE} the algebraic
            equations.
\end{itemize}

The structure is instantiated to maintain consistency but the underlying
reductions need to be hidden from the outside. In our case we need a
\emph{symbol} for variables instantiated to substitutions, for which native
function application is not suitable, due to the restrictions on rewrite rules,
when substitutions are threated as lambdas.

This concept of Dedukti~\cite{assaf2023deduktilogicalframeworkbased} style
constants and rewrite rules in addition with hidden models could be applied to
other structures like natural numbers, lists or sets. Such an approach would
provide more definitional equalities for indexed types like vectors. To this
end, Agda would benefit greatly from an extension with rewriting modulo
commutativity to support more confluent rewrite systems for common algeraic
structures.

\section{Related and Future Work}\label{sec:rwk}

\subsection{Sigma Calculus and Autosubst}
There exist a variety of explicit substitution calculi starting with the
original $\sigma$-calculus~\cite{10.1145/96709.96712} which includes primitives
for identity and extension and shifting and composition. The
$\sigma_{SP}$-calculus~\cite{10.1145/2676724.2693163} adds further reductions
to ensure confluence. Only the $\sigma_{SP}$-calculus is both sound and
complete which enables the derivation of all equations between terms via
reduction. Mechanized proofs establish both completeness and confluence
termination~\cite{10.1145/2676724.2693163, Stark:2020:Mechanising}. The
extension with first class renamings has not yet been formally verified to be
confluent but Stark~\cite{Stark:2020:Mechanising} conjectured that their
addition preserves confluence. Our implementation confirms this conjecture.

We already discussed \textsc{Autosubst 2} and related
research~\cite{10.1145/3293880.3294101, schafer2015autosubst,
      Stark:2020:Mechanising} extensively throughout this work as it forms the direct
theoretical foundation of our contribution. 
% TALK ABOUT

\subsection{Rewriting and Abstractions over Substitution}
In their recent work on local rewrite rules~\cite{10.1145/3776704}, the authors
also rewrite the rules of the $\sigma$-calculus with first class renamings in
Rocq similar to our approach. They provide a model for renamings and
substitutions as functions as we do but they are unable to rewrite all laws
given the underlying model, because in their case the instantiation for the set
of equations must hold definitionally already and cannot be propositional to
maintain consistency in the presence of local rewrite rules.

Another line of research concerns generic programming
approaches~\cite{allais2021typescopesafeuniverse, 10.1145/3018610.3018613}
which allow the construction of syntax trees from general building blocks that
support sums and products and binder introduction. This approach also allows
for a generic structure that abstracts over renamings and substitutions. The
generic syntax approach adapts to a scoped and multi sorted
setting~\cite{saffrich:LIPIcs.ITP.2024.32}. Importantly, we believe generic
programming and the rewriting of $\sigma$ rules are orthogonal and our
rewriting approach could be applied to the universe of syntaxes with binding.

The \textsc{Abstract Binding Trees} library shares a similar goal with
\textsc{Autosubst} and is used for instance in Siek's
work~\cite{siek2021parameterized}. It permits the construction of an object
language from a generic syntax similar to the universe of syntaxes with binding
approach~\cite{allais2021typescopesafeuniverse, 10.1145/3018610.3018613} but it
supports only extrinsic scoping and single sorted syntaxes. The library mainly
focuses on generic theorems about substitution and abstractions over arbitrary predicates over the object language.
The library also offers incomplete experimental support for rewriting using
$\sigma$-calculus laws but misses some rules of the $\sigma$-calculus and does
not pass the confluence check, therby lacking safety guarantees.

Wadler experiments with explicit substitutions and implements weakening as a
constructor in the syntax~\cite{Wadler_2024}, thereby successfully avoiding
renamings. He also rewrites some of the sigma calculus laws but cannot pass the
confluence checker. A more severe issue is that he would not be able to get his
rewrite system confluent, because weakening is a constrcutor and proving for
instance the $\eta$-law in this case is impossible. For the same reason,
variables in his representation can be represented by multiple terms that are
not definitionally equal which results in the loss of more definitional
equalities.

Wadler and colleagues also investigate the uniform treatment of renamings and
substitutions in a typed setting~\cite{altenkirch2025substitution} which
originates from work by McBride~\cite{ren-sub}. This approach unifies repeated
similar lemmas, such as merging all four compositionality lemmas into one. They
hide the structural dependence of renamings and substitutions in the Mode
structure itself and use termination checking directly to make Agda see this
dependence. For this purpose they unify variables and terms and we drew
inspiration from this concept. Saffrich~\cite{saffrich:LIPIcs.ITP.2024.32}
adopts a different approach and hides the structural dependence behind instance
resolution in a scoped syntax setting. On top he provides reflection-based code
generation for the syntax-dependent $\sigma$-calculus lemmas, which could be
directly applied to our setting.


% The \textsc{Nominal 2} Isabelle package~\cite{Nominal2-AFP} is more distantly
% related. It addresses the $\alpha$-equivalence problem using nominal datatypes
% and freshness conditions rather than de Bruijn indices. Their approach is
% closer to the intuitive notion of variables but the tool does not provide any
% strategy for solving equations involving terms and substitutions.


\section{Conclusion}\label{sec:con}
We have shown how to use the decision procedure of the $\sigma$-calculus to
generate definitional equalities in Agda. To this end we closely followed the
underlying equational theory of Autosubst, which provides the decision
procedure for Coq to produce propositional equalities. We discovered that, to
maintain logical consistency, we want two contrary things: the fully
computational behaviour via a representation with function, for instantiation
of the equational theory with proofs, but also symbolic behaviour to apply
rewrite rules using higher-order unification. We believe that exactly this
conflict lead to all the attempts that failed to preserve logical consistency.

Successfully strictifying the $\sigma$-calculus rules safely also allows to
persue interesting new ventures: More complex interinically typed
representations for syntax that do not end up in transfer hell, the question of
wether this approach can be applied to a uniform threatment of renamings and
substitutions, and if we can safely strictify more algebraic structures this
way.

\bibliography{references}

\end{document}
