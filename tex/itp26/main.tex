
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate,anonymous]{lipics-v2021}
\usepackage{microtype}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\nolinenumbers{}

\usepackage{Agda}

\input{unicodeletters}
\input{agdamacros}

\definecolor{agdablue}{HTML}{0000CD}
\DisableLigatures[-]{encoding=T1}
\newcommand{\bsym}[1]{\textcolor{agdablue}{#1}}
\newcommand{\tdot}{\mkern2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern1mu}

\bibliographystyle{plainurl}
\title{Rewriting the Sigma Calculus}

\author{Marius Weidner}{University of Freiburg, Germany}{weidner@cs.uni-freiburg.de}{0009-0008-1152-165X}{}
\authorrunning{Marius Weidner}
\Copyright{Marius Weidner}

\keywords{Explicit Substitutions, Rewrite Systems, Agda}

\ccsdesc[300]{Theory of computation~Equational logic and rewriting}

\begin{document}

\input{systemf}
\input{examples}

\maketitle

\begin{abstract}

      Choosing a representation of variable bindings and substitutions is a central
      challenge in mechanizing programming language metatheory. De~Bruijn indices
      provide a canonical representation, but developments based on them require
      numerous lemmas about substitution composition and interaction with binders,
      leading to significant proof overhead.

      The $σ$-calculus treats parallel substitutions as first-class objects equipped
      with primitive operations and a terminating and confluent rewrite system that
      normalizes substitution expressions. While previous work has exploited these
      rewrite rules to implement decision procedures, the resulting equalities remain
      propositional.

      Recent support for user-defined rewrite rules in mainstream proof assistants
      enables the promotion of propositional equalities to definitional ones. To
      retain logical consistency the set of equational rules must be confluent and
      supported by proofs. However, obtaining these proofs requires modeling
      substitutions as functions, which in turn leads to violations of the syntactic
      restrictions on rewrite rules.

      In the context of the proof assistant Agda, we embed the rules of the
      $σ$-calculus such that they satisfy the criteria for rewrite rules while
      retaining their provability. This approach yields built-in normalization of
      substitutions while preserving logical consistency and full computational
      behavior.

      Our development is reusable: from an Autosubst specification, we automatically
      generate the required $σ$-calculus infrastructure and rewrite rules. To our
      knowledge, this is the first safe integration of the full $σ$-calculus by
      definitional rewriting in a proof assistant.
\end{abstract}

\section{Introduction}\label{sec:introduction}

Choosing a representation of variable bindings and substitutions is a central
challenge in mechanizing programming language metatheory. De~Bruijn indices
provide a canonical representation, but developments based on them require
numerous lemmas about substitution composition and interaction with binders,
leading to significant proof overhead.

On paper, substitution is often an operation that replaces just a single
variable. However, in proof assistants we commonly use parallel substitutions,
which map variables to terms and replace multiple variables simultaneously when
a term is instantiated with them.

\subsection{The Sigma Calculus in \textsc{Autosubst}}

The $σ$-calculus~\cite{10.1145/96709.96712} treats parallel substitutions as
first-class objects equipped with primitive operations and a terminating and
confluent~\cite{Stark:2020:Mechanising} rewrite system that normalizes
substitution expressions. The $σ_{SP}$~\cite{10.1145/226643.226675} variant
complements the original to a complete~\cite{10.1145/2676724.2693163}
procedure. We refer to the $SP$ variant simply as the $σ$-calculus throughout
this work.

The de~Bruijn algebra, where parallel substitutions are modeled as functions,
constitutes a semantic model of the $σ$-calculus. With a semantic model for the
substitution operations, the $σ$-calculus rules become provable, and therefore
qualify for equational reasoning in proof
assistants~\cite{schafer2015autosubst}.

While previous work has exploited these equations to implement normalization
procedures, the resulting equalities remain propositional.
\textsc{Autosubst}~\cite{schafer2015autosubst} provided the first normalization
procedure using the $σ$-calculus rules for unscoped syntax definitions inside
the Rocq proof assistant. To normalize terms with parallel substitutions one
needs to apply a tactic inside a proof goal.

The successor \textsc{Autosubst 2}~\cite{10.1145/3293880.3294101} is now
regarded as the gold standard for libraries that handle substitution in proof
assistants. \textsc{Autosubst 2} supports intrinsically scoped syntax where the
syntax data type is indexed over the number of free variables and variable
usage is restricted to the variables in scope by construction. Furthermore,
\textsc{Autosubst 2} generates proofs for $σ$-calculus rules that follow by
induction over the syntax from higher-order abstract syntax descriptions. It
also enables reasoning about syntaxes with multiple, mutually dependent, sorts
by packaging parallel substitutions over different sorts into vectors.

Most importantly, \textsc{Autosubst 2}, in contrast to the first version,
includes first-class support for renamings, a special case of substitutions
that map variables to variables. Independently of first-class support in the
equational theory, they are required in proof assistants to model substitutions
in a structurally recursive manner that the termination checker
accepts~\cite{10.1007/11617990_1}. The creators of \textsc{Autosubst 2}
extended the equational theory of the $σ$-calculus with additional rules that
handle renamings. The resulting system is not complete anymore, but the authors
conjecture the extended system preserves
confluence~\cite{Stark:2020:Mechanising}.

\subsection{Definitional Equalities for Substitutions using Rewrite Rules}

Recent support for user-defined rewrite rules in mainstream proof assistants,
such as Agda~\cite{cockx:LIPIcs.TYPES.2019.2, 10.1145/3434341} and
Rocq~\cite{leray_et_al:LIPIcs.ITP.2024.26}, enables the promotion of
propositional equalities to definitional ones. To retain logical consistency
the set of equational rules must be confluent and supported by
proofs~\cite{10.1145/3434341}. However, obtaining these proofs requires
modeling substitutions as functions, which in turn leads to violations of the
syntactic restrictions on rewrite rules.

Agda and other proof assistants perform higher-order pattern
unification~\cite{10.1007/978-3-642-21691-6_5} to detect if a registered
rewrite rule can be applied to a stuck term (one that does not reduce further,
given the built-in reduction rules). To do so, Agda requires that the left-hand
side is a stuck term on a defined symbol. To model parallel substitution in
proof assistants, we have essentially two choices: data types or functions.
When we model substitution as functions, some primitive operations of the
$σ$-calculus generate stuck lambdas, thereby violating the syntactic
restriction that the left-hand side must be a stuck symbol and not a lambda.

Others tried to model substitution with constructors, but then we lack the
computational behavior of substitutions required to instantiate the full rule
set of the $σ$-calculus with proofs and in turn preservation of logical
consistency. Modeling substitutions as vectors does not constitute a complete
semantic model of the $σ$-calculus.

If we wish to rewrite all $σ$-calculus rules, we require more control over the
reduction behavior of symbols. Fortunately, Agda supports opaque
definitions~\cite{gratzer2022controlling}, that allow us to selectively block
and later unfold the implementation of function definitions. With opaque
definitions we can have both: we treat function definitions as stuck symbols,
such that we can apply rewrite rules, but also unfold their definitions to
prove the rules using their underlying model.

\subsection{Content of this Paper}

\subsection*{Contributions}
We show how to rewrite the $σ$-calculus rules, with support for first-class
renamings, in a multi-sorted and scoped syntax setting, in Agda. We do so while
preserving the logical consistency of the system.

As a side effect we support the claim that the extension of the $σ$-calculus
rules with first-class renamings is confluent, via Agda's built-in confluence
checker. We also show that this approach translates to any scoped syntax by
implementing a code generation script for higher-order abstract syntax
descriptions.

\subsection*{Structure}

\Cref{sec:pre} introduces the required background in Agda and for the
$σ$-calculus. \Cref{sec:mis} demonstrates how to register the $σ$-calculus rules
exemplified by System~F. We discuss ongoing and future work in \cref{sec:fwk},
related work in \cref{sec:rwk}
and conclude the paper in \cref{sec:con}.

\section{Preliminaries}\label{sec:pre}
We begin with a review of material from the literature. We summarize
\begin{itemize}
      \item Agda and language features relevant to our work: rewrite rules and opaque
            blocks;
      \item multi-sorted and scoped syntax in Agda and
      \item the $σ$-calculus modeled via the de~Bruijn algebra.
\end{itemize}

\noindent\textbf{All Agda code presented in this paper can be found in the supplement.}

\subsection{Agda and Relevant Language Features}\label{sec:pre-agd}
Agda is a dependently typed functional language and proof assistant based on
Martin-Löf type theory~\cite{MARTINLOF197573}, where proofs are verified by
type checking. Proofs are significantly easier when terms are
\textit{definitionally equal} (i.e.,\ reduce to the same term). When terms are
not definitionally equal, users must resort to manual equational reasoning
using propositional equality, which is a cumbersome process as Agda lacks
automated proof-discharge tactics. Maximizing definitional equalities thus
directly reduces manual effort.

Beyond standard features such as indexed inductive types and dependent pattern
matching~\cite{10.1145/3236770}, this work is based on two more advanced
language features.

\subsection*{Rewrite Rules}
User-defined rewrite rules~\cite{10.1145/3434341, cockx:LIPIcs.TYPES.2019.2}
extend Agda’s normalization-by-evaluation approach for definitional equalities
by treating propositional equalities as reduction rules.

A function is eligible for rewriting if it is of the following form:
\[
      \AgdaFunction{eq} : (x_1 : A_1) \ldots \to \AgdaFunction{f}\, p_1 \ldots p_n
      \, \AgdaFunction{≡} \, v
\]
In addition it needs to satisfy the following conditions:
\begin{enumerate}
      \item The head \AgdaFunction{f} is a postulate, defined function, or constructor with
            distinct variable type parameters.
      \item Every variable $x_i$ appears in a pattern position among $p_1, \ldots,
                  p_n$\footnote{The Agda documentation includes a definition for pattern
                  positions:
                  \url{https://Agda.readthedocs.io/en/latest/language/rewriting.html}}.
      \item The left-hand side is stuck.
\end{enumerate}

\noindent For example, the right identity of addition satisfies these criteria:
\ERewrite{} Once registered via \ERewriteIt{}, Agda treats \AgdaBound{n}
\AgdaFunction{+} \AgdaNumber{0} as definitionally equal to \AgdaBound{n}: \ERewriteEx{}

In addition to the syntactic restrictions, users must ensure that the rewrite
rule set as a whole is terminating and confluent to retain logical consistency.

Termination is not verified, but also not a critical
property~\cite{10.1145/3434341}. Agda provides confluence checks via
\texttt{--confluence-check} and \texttt{--local-confluence-check}. Given that
the rewritten rules are supported by proofs, the rewrite system is terminating,
and the rule set is locally confluent, their registration as rewrite rules
preserves consistency~\cite{10.1145/3434341}.

\subsection*{Opaque Blocks}
Opaque definitions~\cite{gratzer2022controlling} let the user treat code as
non-unfolding symbols. This feature is typically used to improve type checking
times, because normally we want all definitions to unfold, to produce as many
definitional equalities as possible. Their use case in this work will be to
declare relevant definitions opaque, such that the stuck symbols qualify for
rewriting.

Definitions within an \AgdaKeyword{opaque} block are visible but treated
abstractly during type checking: \EOpaque{} Outside this block,
\AgdaFunction{forty-two} does not reduce to \AgdaNumber{42}: \EOpaqueExO{}
However, the \AgdaKeyword{unfolding} keyword can be used to expose the
computational behavior of a symbol when needed: \EOpaqueExT{}

\subsection{Multi-Sorted and Scoped Syntax}\label{sec:pre-syn}
\begin{figure}[t]
      \begin{minipage}[t]{0.45\linewidth}
            \raggedright{}
            \EScoped{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.55\linewidth}
            \raggedright{}
            \EMultiSorted{}
      \end{minipage}
      \caption{Classically Scoped vs. Multi-Sorted Scoped Syntax}\label{fig:pre-svm}
\end{figure}

Many programming languages feature multiple syntactic categories. For instance
System~F~\cite{girard1972, 10.1007/3-540-06859-7_148} has three syntactic
sorts: expressions, types, and kinds. To prevent scoping errors, we use
\textit{intrinsically scoped syntax} to represent the syntax.
\Cref{fig:pre-svm} (left) shows a standard implementation: types are indexed by
the amount of type variables, and expressions by both the amount of type and
expression variable. Variables use de~Bruijn indices of type \AgdaDatatype{Fin}
\AgdaBound{n}, that is, natural numbers strictly less than the number of free
variables. This representation restricts the set of terms to only well-scoped
terms.

We see scoped syntax as the optimal balance between fully extrinsic syntax and
intrinsically typed syntax, in which case the expression syntax is indexed
directly over contexts and types. It is powerful enough to detect scoping
related errors, but one does not need to commit to full blown intrinsic typing,
which can be difficult to work with for more complex systems.

Alas, the standard representation requires us to define many substitution
operations across the different sorts (e.g., type-in-type, type-in-expr,
expr-in-expr). This representation is chosen by \textsc{Autosubst 2}, and
explains why they need vector substitutions, that bundle substitutions over the
different sorts alongside additional normalization rules.

To avoid the combinatorial explosion of substitutions over different syntactic
sorts, we unify the syntax in two orthogonal dimensions, presented also in
\cref{fig:pre-svm} (right). Variables and terms form a single datatype
\AgdaBound{S} \AgdaDatatype{⊢[} \AgdaBound{m} \AgdaDatatype{]} \AgdaBound{s}
indexed by a \AgdaDatatype{Mode} \AgdaBound{m}, a target \AgdaDatatype{Sort}
\AgdaBound{s} and a list of sorts \AgdaDatatype{Scope} \AgdaBound{S}. Modes
distinguish constructors for variables and terms. Variables are represented
across multiple sorts simultaneously by natural numbers of type \AgdaBound{S}
\AgdaDatatype{∋} \AgdaBound{s} and act as de~Bruijn indices. The position of
\AgdaBound{s} in \AgdaBound{S} directly corresponds to the de~Bruijn index of
the variable. Using the syntax unified over sorts, we can later define
renamings and substitutions that operate uniformly across all sorts, thereby
avoiding vector substitutions. Unifying over modes, allows us to state some
$σ$-calculus laws parametric over the mode.

\subsection{The Sigma Calculus modeled via the de~Bruijn Algebra}\label{sec:pre-sig}
\begin{figure}[t]
      \centering
      \begin{minipage}[t]{0.40\textwidth}
            \raggedright
            \textbf{Traversal Rules}
            \begin{alignat*}{2}
                  \mathsf{lam} \quad & (\textcolor{agdablue}{λ.}\, t)                                         & \tdot σ
                                     & = \textcolor{agdablue}{λ.} (t \tdot (\textcolor{agdablue}{\uparrow}σ))           \\
                  \mathsf{app} \quad & (t_1 \ t_2)                                                            & \tdot σ
                                     & = (t_1 \tdot σ) \ (t_2 \tdot σ)
            \end{alignat*}
            \textbf{Monad Rules}
            \begin{alignat*}{2}
                  \mathsf{right\text{-}id} \quad & t \tdot \textcolor{agdablue}{\mathsf{id}} &  & = t                                         \\
                  \mathsf{comp} \quad            & (t \tdot σ_1) \tdot σ_2                   &  & = t \tdot (σ_1 \textcolor{agdablue}{;} σ_2)
            \end{alignat*}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.40\textwidth}
            \raggedright{}
            \textbf{Interaction Rules}
            \begin{alignat*}{2}
                  \mathsf{id}_\mathsf{L} \quad & \textcolor{agdablue}{\mathsf{id}} \ \textcolor{agdablue}{;} \ σ                                                                             &  & = σ                                                                               \\
                  \mathsf{id}_\mathsf{R} \quad & σ \ \textcolor{agdablue}{;} \ \textcolor{agdablue}{\mathsf{id}}                                                                             &  & = σ                                                                               \\
                  \mathsf{assoc} \quad         & (σ_1 \ \textcolor{agdablue}{;} \ σ_2) \ \textcolor{agdablue}{;} \ σ_3                                                                       &  & = σ_1 \ \textcolor{agdablue}{;} \ (σ_2 \ \textcolor{agdablue}{;} \ σ_3)           \\
                  \mathsf{dist} \quad          & (t \textcolor{agdablue}{\cdot} σ_1) \ \textcolor{agdablue}{;} \ σ_2                                                                         &  & = (t \tdot σ_2) \textcolor{agdablue}{\cdot} (σ_1 \ \textcolor{agdablue}{;} \ σ_2) \\
                  \mathsf{interaction} \quad   & \textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \ (t \textcolor{agdablue}{\cdot} σ)                                             &  & = σ                                                                               \\
                  η\mathsf{\text{-}id} \quad   & (\textcolor{agdablue}{\mathsf{zero}}) \textcolor{agdablue}{\cdot} \textcolor{agdablue}{\mathsf{wk}}                                         &  & = \textcolor{agdablue}{\mathsf{id}}                                               \\
                  η\mathsf{\text{-}law} \quad  & (\textcolor{agdablue}{\mathsf{zero}} \tdot σ) \textcolor{agdablue}{\cdot} (\textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \ σ) &  & = σ
            \end{alignat*}
      \end{minipage}
      \caption{The Sigma Calculus Rules}\label{fig:pre-sig}
\end{figure}
We review the variant of the $σ$-calculus modeled via the de~Bruijn algebra which also appears in the
first version of \textsc{Autosubst}~\cite{schafer2015autosubst}, without first-class renamings. Variables $x$
represent natural numbers and terms $t := x \,|\, \textcolor{agdablue}{λ.}\, t
      \,|\, t₁ \, t₂ $ include the standard lambda calculus constructors as an
example for any single sorted, unscoped syntax with binding.
A substitution $σ$ maps
variables to terms. It helps to view a substitution as a stream $(t_0,
      t_1, \dots)$, where the index of the term in the map directly corresponds to the de~Bruijn variable it replaces. Binders make things complicated and require support for a shift operation to increment de~Bruijn indices, when substitutions containing variables are pushed under binders. This perspective
motivates the semantic definitions for the extension operation $t
      \textcolor{agdablue}{\cdot} σ$, the identity
$\textcolor{agdablue}{\mathsf{id}}$ and the weakening
$\textcolor{agdablue}{\mathsf{wk}}$ primitives, treating substitutions as functions:
\begin{align*}
      (t \textcolor{agdablue}{\cdot} σ)(\textcolor{agdablue}{\mathsf{zero}})    & := t    & \textcolor{agdablue}{\mathsf{id}}(x) & := x                                      \\
      (t \textcolor{agdablue}{\cdot} σ)(\textcolor{agdablue}{\mathsf{suc}}\, x) & := σ(x) & \textcolor{agdablue}{\mathsf{wk}}(x) & := \textcolor{agdablue}{\mathsf{suc}}\, x
\end{align*}
We then define the application of a substitution to a term $\tdot$, which we refer to
as instantiation, mutually recursively with composition and the
lifiting operator which pushes substitutions under binders using shifting:
\begin{align*}
      (\textcolor{agdablue}{λ.}\, t)  \, \tdot \, σ
                                        & = \textcolor{agdablue}{λ.} (t \tdot (\textcolor{agdablue}{\uparrow}σ)) & (σ_1 \
      \textcolor{agdablue}{⨟} \ σ_2)(x) & = σ_1(x) \tdot σ_2                                                                                                                                \\
      (t_1 \ t_2)                            \, \tdot \, σ
                                        & = (t_1 \tdot σ) \ (t_2 \tdot σ)                                        & \textcolor{agdablue}{\uparrow}σ & := \textcolor{agdablue}{\mathsf{zero}}
      \textcolor{agdablue}{\cdot} (σ \ \textcolor{agdablue}{⨟} \
      \textcolor{agdablue}{\mathsf{wk}})
\end{align*}
Lifting
preserves the bound variable while it weakens the terms of the substitution to
maintain correct scoping. Composition retrieves the term from the first substitution and then instantiates the resulting term with the second. Instantiation traverses the term homomorphically
to push the substitution to the leaves.

\Cref{fig:pre-sig} presents the accompanying rewrite system. It traditionally also includes the
clauses of the instantiation function.
We follow Stark~\cite{Stark:2020:Mechanising} and categorize the rules into three groups.
\begin{itemize}
      \item \textbf{Traversal rules} govern propagation through terms and under binders.
      \item \textbf{Monad rules} define the behavior of substitutions applied to terms.
      \item \textbf{Interaction rules} describe equalities between substitution expressions.
\end{itemize}

We refer the reader to the original $σ_{SP}$-calculus
paper~\cite{10.1145/2676724.2693163} for a detailed description of the rule set
selection, and to Schäfer et al~\cite{10.1145/2676724.2693163} for the reason
these rules suffice to normalize all substitution expressions.

\section{Rewriting the Sigma Calculus}\label{sec:mis}

The definition of instantiation by mutual recursion with composition
complicates termination. Agda cannot determine that this definition is
structurally recursive (and also lacks mechanisms to justify termination by
well-founded recursion), so we follow Adams~\cite{10.1007/11617990_1} to
resolve the issue by first defining instantiation with renamings. We then
extend the equational theory to handle first-class renamings and to connect
substitutions with renamings with the rules from \textsc{Autosubst 2}. We use
the multi-sorted and scoped version of System~F from \Cref{fig:pre-svm} as an
example for any scoped syntax. The approach described in this section directly
translates to any multi-sorted and scoped syntax as well as simple
intrinsically typed syntax where the type index of the syntax has type
\AgdaDatatype{Set}.

\subsection{Renaming and Substitution}\label{sec:mis-sub}
\begin{figure}[t]
      \AgdaNoSpaceAroundCode{}
      \setlength{\mathindent}{0pt}
      \setlength{\AgdaEmptySkip}{\smallskipamount}
      \begin{minipage}[t]{0.35\linewidth}
            \raggedright{}
            \ERen{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.53\linewidth}
            \raggedright{}
            \ESub{}
            \ESubT{}
      \end{minipage}
      \caption{The Primitives for Renaming and Substitution}\label{fig:mis-ras}
\end{figure}

The definitions for renaming and substitution are presented in
\Cref{fig:mis-ras}. The definitions are mostly standard, but we will mark
nearly all symbols for primitives \AgdaKeyword{opaque}, and describe their
behavior later through rewrite rules.

We begin with the type alias for renamings \AgdaFunction{\_→ᴿ\_}: renamings are
functions that map variables of sort \AgdaBound{s} from scope \AgdaBound{S₁} to
variables of the same sort in scope \AgdaBound{S₂}. We then define the renaming
primitives identity \AgdaFunction{id}, weakening \AgdaFunction{wk} and forward
composition \AgdaFunction{\_∘\_}. The identity renaming is just the identity
function, that ignores the explicit sort argument, which we could not leave
implicit, because Agda fails to infer it most of the time, complicating proofs
unnecessarily. Weakening applies the \AgdaInductiveConstructor{suc} constructor
to all variables of a renaming and composition of two renamings is defined as
forward function composition. Extension \AgdaFunction{\_∙ᴿ\_} inserts the
respective variable for de Bruijn index \AgdaInductiveConstructor{zero} into
the renaming. Lifting \AgdaFunction{\_↑ᴿ\_} is defined in terms of extension
with variable \AgdaInductiveConstructor{zero} and composition with the
weakening renaming. We do not mark lifting opaque, because it is merely a alias
for a term constructed from the primitives. The traversal operation
\AgdaFunction{\_⋯ᴿ\_} propagates the renaming through the nodes to the leaves
and applies lifting when it passes under binders. We define instantiation
across both modes for reasons explained later.

Substitutions are functions from variables to terms instead of variables. The
operator \AgdaFunction{⟨\_⟩} embeds any renaming into a substitution by
wrapping all variables with the variable constructor. With the embedding
operator we define aliases for the identity substitution \AgdaFunction{idˢ} and
weakening substitution \AgdaFunction{wkˢ} directly from renamings. To prevent
Agda from rejecting rewrite rules due to reductions on the left-hand side of
equations, we \AgdaKeyword{INLINE} these symbols.

Extension \AgdaFunction{\_∙ˢ\_} is defined by case analysis on the incoming
variable and maps the term we extend with to variable
\AgdaInductiveConstructor{zero}. We use instantiation with the weakening
renaming to define the lifting of substitutions \AgdaFunction{\_↑ˢ\_}, thereby
satisfying the requirements of structural recursion. In constrast to the
lifting operator for renamings, we keep it's computational behavior hidden, and
later rewrite it in terms of substitution composition. Instantiation with a
substitution \AgdaFunction{\_⋯ˢ\_} works analogous to the case of renamings and
we also design it to work for variables and terms simultaneously, for reasons
that become clear shortly. Finally we define the forward composition of
substitutions \AgdaFunction{\_⨟\_} via instantiation.

The definitions of instantiation over both modes, allows us to do lookup of a
variable in a substitution (or renaming) also by usage of the stuck symbol for
instantiation, instead of function application. Because we need to state the
equations we wish to rewrite later only in terms of stuck symbols, without
using lambdas or function application, we require the one for variable lookup.
We go into more detail in \Cref{sec:mis-ex}.

\subsection{The Sigma Calculus Rules}\label{sec:mis-sig}
\begin{figure}[t]
      \AgdaNoSpaceAroundCode{}
      \setlength{\mathindent}{0pt}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \EDefLaws{}
            \EInteractLaws{}
            \ERewriteSys{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ECoincidenceLaws{}
            \ETraversalLaws{}
            \EMonadLaws{}
      \end{minipage}
      \caption{The Rewrite System~For the Sigma Calculus with First-Class Renamings}\label{fig:mis-sig}
\end{figure}

\Cref{fig:mis-sig} presents the part of $σ$-calculus rules with first-class renamings
as Agda equalities admissable for rewriting.
Agda accepts the rule set as confluent which is important for safety.
We are also able to prove all the rules before rewriting them, to guarantee consistency.
first-class renamings introduce three new categories. We now discuss the
changes to the standard $σ$-calculus variant from \Cref{sec:pre-sig}.

The \textbf{Definitional rules} include definitions we blocked earlier in
modified form. We include the clauses from the definition of extension but use
the instantiation operator to handle lookup of variables in substitutions
instead of function application. Similarly, lookup in composed substitutions is
defined in terms of the instantiation operator. We rewrite the lifting operator
in terms of composition with the weakening substitution, which was not possible
to define earlier, due to the aforementioned termination issues. This change
allows us to draw on the complete theory of the $σ$-calculus, when solely
reasoning about substitutions. To save space, we have omitted the definitional
rules for renamings, but they follow analogously.

The \textbf{Interaction rules} are exactly those presented in
\Cref{sec:pre-sig}. In the figure we have omitted a copy of the interaction
rules for renamings, which we also include in the rewrite system.

The \textbf{Coincidence rules} emerge from the interaction between renamings
and substitutions~\cite{10.1145/3293880.3294101}. They allow us to recover some
renamings from their embedding as substitutions. The extraction of renamings
from deeply nested substitutions in general requires a dedicated solving
strategy~\cite{10.1145/3293880.3294101}. In addition to the obvious
\AgdaFunction{coincidence} rule, we require a specific coincidence variant
called \AgdaFunction{coincidence-fold} for the proof of subject reduction for
System~F later. However, others proofs might require more coincidence lemmas.
For instance, proving subject reduction in general requires the inclusion of
lemmas in the style of \AgdaFunction{coincidence-fold} with $n$ extensions
where $n$ is the maximum arity of binders in the object language. The inclusion
of more coincidence lemmas usually does not affect confluence.

The \textbf{Traversal rules} mirror the clauses from the definitions of
instantiation in the previous section directly. We include all clauses except
the one for variables. This exclusion is important because we wanted the term
\AgdaBound{x} \AgdaFunction{⋯ˢ} \AgdaBound{σ} to remain stuck, so we can apply
rewrite rules where instantiation of variables is the head symbol. We have
omitted the analogous traversal rules for renamings.

We extend the \textbf{Monad rules} to handle all four combinations of
instantiation with renamings and substitutions. We state the right identity law
only for renamings because the instantiation with the identity substitution
reduces to instantiation with the identity renaming via
\AgdaFunction{coincidence}.

The proofs of the rules are standard, and we refer the interested reader to the
supplement. Within the proofs we unfold the opaque definitions and make use of
function extensionality which is conservative over the theory underlying
Agda~\cite{Hofmann1997}.

\subsection{An Example Proof with the Rewritten Sigma Calculus}
\begin{figure}[!t]
      \AgdaNoSpaceAroundCode{}
      \setlength{\mathindent}{0pt}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESPT{}
      \end{minipage}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESR{}
      \end{minipage}
      \caption{Subject Reduction for System~F}\label{fig:ext-rst}
\end{figure}
The rules of the $σ$-calculus apply automatically throughout
the subsequent code. We briefly demonstrate this with a proof of subject reduction
where we never need to explicitly manage substitutions. The
proof is carried out for a standard logical type system
\AgdaDatatype{\_⊢\_:\_} and call-by-value small-step operational semantics \AgdaDatatype{\_↪\_}. We
refer to the supplement for the definitions of both.

To establish subject reduction, we first prove that renaming and substitution
preserve typing. The left side of \cref{fig:ext-rst} displays the proofs for
the substitution-preserves-typing lemma \AgdaFunction{\_⊢⋯ˢ\_}. We omit the
analogous proof for renamings.

The signature of the proof relies on the definition for well typed
substitutions: \EWTS{} Contexts \AgdaDatatype{Ctx} \AgdaBound{S} are maps from
scoped variables to scoped types. Well typed substitutions are then defined as
functions from variables \AgdaBound{x} typed in \AgdaBound{Γ₁} to terms
\AgdaBound{x} \AgdaFunction{⋯ˢ} \AgdaBound{σ} typed in \AgdaBound{Γ₂}.

The preservation result for renamings is used to prove that the lifting of a
substitution preserves typing \AgdaFunction{⊢↑ˢ} and subsequently used inside
the substitution-preserves-typing proof, again respecting the termination
constraints. The variable cases require a lookup of the well typed variable
inside the well typed substitution. We apply the preservation lemma for lifting
substitutions when we pass under a binder. All cases follow without any
manipulation of substitutions. In particular we do not need to manually move
the substitution under a weakening inside the cases
\AgdaInductiveConstructor{λx\_} and \AgdaInductiveConstructor{Λα\_} or under a
singleton substitution in the case of type application
\AgdaInductiveConstructor{\_•\_} which are normally required in standard
proofs.

Subject reduction \AgdaFunction{sr} directly follows from the substitution
preserves typing lemma, shown on the right of \cref{fig:ext-rst}. Inside the
$β$-reduction cases \AgdaFunction{⊢[]} denotes the well typed single
substitution which can be derived directly from the substitution preserves
typing lemma. The rewrite rules automatically handle the otherwise required
application of interaction rules in the cases of $β$-reductions.

\subsection{An Examination of the Issue with Unfolding Definitions}\label{sec:mis-ex}
Blocking the reduction behavior of renaming and substitution primitives allowed
us to successfully rewrite all $σ$-calculus rules. We now explain why this
approach works, and more specifically why other attempts did not work.

The primary issue is that composition unfolds to lambda abstractions. If we
unfold the definition for the composition operator, then for instance the left
hand side of \AgdaFunction{comp-idₗ} rule would reduce to~\EIdLawUnfolded{}~,
violating the constraint that rewrite rules must have stuck symbols on the
left. However, when we block the reduction of composition, we still need to be
able to describe how variables are looked up inside two composed substitutions.

We tried to keep using function application to describe variable lookup, that
is, rewriting the following: \EFunAppInterp{}. This equation effectively
re-establishes the computational behavior of composition and to our surprise,
Agda accepts this rule together with the interaction rules, such as
\AgdaFunction{comp-idₗ}, but it fails to perform higher-order pattern
unification correctly afterwards. More specifically, it does not apply the
$η$-laws anymore, even though manual application using propositional equality
reasoning works. We argue Agda should reject such a construction.

Instead we use the instantiation operator to perform variable lookup. Doing so
requires us to propagate this change through all rules, using instantiation
every time we would want to use function application for variable lookup.

We note that, while we are still able to use function application or build
renamings and substitutions using lambdas, we then obtain fewer definitional
equalities. We thus recommend only to use the instantiation operator for
variable lookup and only the two already defined composition operators.

\subsection*{Using Vectors instead of Functions}

We also considered an alternative representation for substitutions based on a
vector-like data type. This data type would at least need to include an
extension constructor, to fill the vector with terms. Because composition is
then defined via case distinction on the vector, it correctly behaves as a
stuck symbol suitable for rewriting. However, with extension as constructor the
$η$-law is not instantiatable with a proof, because this would require that the
extension constructor has computational behavior.

Removing the $η$-law from the equational theory preserves confluence, but
removes important definitional equalities. However, the vector representation
could maybe still be useful for an attempt at
type-theory-in-type-theory~\cite{10.1145/2914770.2837638}, where a
representation of substitutions as functions is not possible.

\subsection{Discussion}\label{sec:mis-dis}
The rules presented in \cref{sec:mis-sig} are an extension of the classic
$σ$-calculus rules to a setting with renamings, closely following the work done
by the \textsc{Autosubst 2} authors. After careful construction, marking the
relevant symbols opaque, they fulfill the requirements to be registered as
rewrite rules. Moreover Agda can see that the rule set preserves confluence.

The original $σ$-calculus treats the symbols purely syntactic, also describing
the behavior of lookup with use of the instantiation operator. Then the
de~Bruijn algebra provided a semantic model for the $σ$-calculus, enabling
proofs for the $σ$-calculus rules and applicability for propositional equality
reasoning. In this work we do both: Using the semantic model to prove the laws
but also treating the symbols syntactically to predicably apply rewrite rules.

\section{Ongoing and Future Work}\label{sec:fwk}
\subsection{Code Generation}
\begin{figure}[!t]
      \begin{minipage}[t]{0.48\linewidth}
            \begin{verbatim}
kind : Type
type : Type
expr : Type

-- the constructors for kind 
star : kind

-- the constructors for type
arr : type -> type -> type
all : kind -> (type -> type) -> type
    \end{verbatim}
      \end{minipage}
      \begin{minipage}[t]{0.48\linewidth}
            \begin{verbatim}
-- the constructors for expr
app  : expr -> expr -> expr
lam  : type -> (expr -> expr) -> expr
tapp : expr -> type -> expr
tlam : kind -> (type -> expr) -> expr
      \end{verbatim}
      \end{minipage}
      \caption{Higher-order abstract  syntax specification for System~F}\label{fig:rel-hoa}
\end{figure}

In addition to the theoretical work, \textsc{Autosubst 2} also features
external code generation from higher-order abstract syntax (HOAS) descriptions.
More specifically, they generate the scoped syntax data types and all
substitution lemmas that require induction over the syntax for the Rocq proof
assistant.

To showcase our applicability to custom syntax descriptions, we also provide a
code generation script that translates HOAS descriptions to Agda code, which
includes the $σ$-calculus rules ready for rewriting. The corresponding HOAS
description for our SystemF example can be found in \Cref{fig:rel-hoa}. We are
already able to support some of the features that \text{Autosubst 2} supports:
\begin{itemize}
      \item Vector substitutions: unnecessary due to multi-sorted syntax
      \item Mutual recursive syntax definitions: works out of the box with multi-sorted
            syntax
      \item Binders that bind multiple variables: supported by a generalized lifting
            operation that allows to lift by lists of sorts, instead of only a single sort.
      \item Inline Agda code (e.g.\ lists or products of terms): can already be encoded
            using additional sorts, but one loses the support for lemmas from the standard
            library.
      \item Distinction between sorts with binders and those without: not yet supported,
            but could be modeled with an additional binary index to the \AgdaDatatype{Sort}
            data type, that separates sorts of the two categories.
      \item Variadic syntax: not yet supported, but could be encoded in the future using
            arguments to the sort constructors~\cite{saffrich:LIPIcs.ITP.2024.32}
\end{itemize}

Our code generation script can be found in the supplement, but represents
merely a proof of concept for a standalone library. The script includes a
parser for HOAS descriptions and ad-hoc code generation. It is written in
Python with strict type-checking enabled and includes all the boilerplate Agda
code, so it can serve as a single-file standalone tool for others to try. We
include a dozen Agda files which we generated from HOAS descriptions found in
the examples directory of the \textsc{Autosubst 2} git repository.

\subsection{Opaque Definitions for Rewriting}
The construction from the previous section reveals a broader concept that could
serve as a general recipe for integrating normalization for suitable algebraic
structures into proof assistants:

\begin{itemize}
      \item Define symbols for the structure.
      \item Establish a corresponding confluent rewrite system.
      \item Instantiate the structure with an underlying model to prove the laws of the
            rewrite system inside \AgdaKeyword{opaque} blocks.
      \item With the reduction of the model hidden, \AgdaKeyword{REWRITE} the algebraic
            equations.
\end{itemize}

To illustrate this, consider the example of set-theoretic sets. When reasoning
over sets in Agda, users usually resort to work with lists up to permutation
and a uniqueness predicate, which is tedious to work with and requires lots of
uninteresting code. This overhead is usually not an issue in tactic-based
provers, that feature dedicated solvers for this work.

The characteristic function for sets makes it possible to translate statements
about sets to statements about functions. We shortly outline how our approach
could be adopted to provide built-in normalization for sets using their
characteristic function as the underlying model.

Following the idea above, the type of sets would be defined as: \ESetProp\, for
some $\mathcal{A}$ : \AgdaDatatype{Set} \AgdaBound{ℓ}. Using this model we can
define set operations as opaque functions: \ESetOps{} Although this model is
probably even worse to work with than lists up to permutation, we can define
all set operations and also instantiate a suitable rewrite system with proofs.
This rewrite system might include for example a right identity law of the form:
\ESetLawEx{}. Due to the opaquely defined operations, this equation qualifies
as rewrite rule.

A good starting point for a suitable rewrite system is given by the boolean
ring interpretation of sets~\cite{HSIANG1985255}. This system however, requires
rewriting modulo AC (associativity and commutativity). Other provers, such as
Dedukti~\cite{assaf2023deduktilogicalframeworkbased}, which is purely based on
rewrite rules, already support AC rewriting and we argue that Agda would also
greatly benefit from an extension with rewriting modulo AC. Safe built-in
normalization for common algebraic structures would improve the user experience
of Agda and might allow it to close the gap to tactic-based provers regarding
automation of such proofs.

\subsection{Implications for Intriniscally Typed Syntax}
Complex intrinsically typed syntax, where substitution already appears as an
operation on the type index of the syntax, complicates proofs significantly.
Because substitutions without rewriting enjoy few definitional equalities, we
need to apply general properties of the transfer lemma (\AgdaFunction{subst} in
Agda) every time we manipulate proofs over expressions that involve type
substitution. This issue is commonly referred to as `transfer hell' (or
`transport hell').

The fact that complex intrinsically typed syntax ends up in `transfer hell' is
long-standing issue~\cite{article}. An elaborate example close to our work in
Agda is given by the construction of a binary logical relation for
intrinsically typed System~F~\cite{10.1145/3678000.3678201}, where the authors
spend thousands of lines reasoning about uninteresting manipulation of
transfers. More specifically, while reasoning over type-in-type and
expr-in-expr substitutions is still easy in this scenario, proving lemmas over
type-in-expr substitution is complicated tremendously, because type
substitution also affects the index of the expression that is substituted in.
After rewriting the $σ$-calculus rules for type substitutions, their problems
in the proofs for expression substitutions should effectively be gone
completely.

Rewriting the $σ$-calculus rules on the syntax for the typing index should
easily generalize to other intrinsically typed syntaxes and render explicit
transfers unnecessary, as long we do not attempt to formalize type theory in
type theory~\cite{10.1145/3779031.3779090, 10.1145/3747535}.

\section{Related Work}\label{sec:rwk}
We already discussed \textsc{Autosubst} and related
research~\cite{10.1145/3293880.3294101, schafer2015autosubst,
      Stark:2020:Mechanising}, as well as user-defined rewrite
rules~\cite{10.1145/3434341, cockx:LIPIcs.TYPES.2019.2,
      leray_et_al:LIPIcs.ITP.2024.26} and opaque
definitions~\cite{gratzer2022controlling}, which are both present in Agda and
Rocq, extensively throughout this work.

In their recent work on local rewrite rules~\cite{10.1145/3776704}, the authors
also rewrite rules of the $σ$-calculus with first-class renamings in Rocq
similar to our approach. They also provide a model for renamings and
substitutions as functions, but they are unable to rewrite all laws given the
underlying model. This is because in their case the instantiation for the set
of equations must hold definitionally and cannot be propositional to maintain
consistency in the presence of local rewrite rules. Rocq also allows for global
rewrite rules, but lacks the ability to instantiate the rules with proofs to
maintain consistency~\cite{leray_et_al:LIPIcs.ITP.2024.26}.

Another line of research concerns generic programming
approaches~\cite{allais2021typescopesafeuniverse, 10.1145/3018610.3018613},
that allow the construction of syntax from general building blocks that support
sums, products and binder introduction. This allows for a generic structure
that abstracts over renamings and substitutions. The generic syntax approach
translates to a scoped and multi-sorted
setting~\cite{saffrich:LIPIcs.ITP.2024.32}. Importantly, we believe generic
programming and rewriting the $σ$-calculus rules are orthogonal and our rewrite
system could be applied to the universe of syntaxes with binding, thereby
avoiding external code generation.

The \textsc{Abstract Binding Trees} library for Agda shares a similar goal with
\textsc{Autosubst} and is used for instance in Siek's
work~\cite{siek2021parameterized}. It permits the construction of an object
language from a generic syntax similar to the universe of syntaxes with
binding, but it only supports extrinsic scoping and single sorted syntaxes. The
library mainly focuses on generic theorems about substitution and abstractions
for arbitrary predicates over the object language. Interestingly, the library
also offers incomplete experimental support for rewriting using $σ$-calculus
laws but misses rules of the $σ$-calculus and thus does not pass the confluence
check.

Wadler experiments with explicit substitutions and implements weakening as a
constructor in the syntax~\cite{Wadler_2024}, thereby successfully avoiding
renamings. He rewrites some of the sigma calculus laws but cannot pass the
confluence checker. Because weakening is a constructor, variables in his
representation can be represented by multiple terms that are not definitionally
equal which results in the loss of definitional equalities. Furthermore, he
represents substitutions using vectors, and thus would not be able to support
the full $σ$-calculus rule set with proofs.

Wadler and colleagues also investigate the uniform treatment of renamings and
substitutions in a simply typed setting~\cite{altenkirch2025substitution} which
originates from work by McBride~\cite{ren-sub}. This approach unifies repeated
similar lemmas, such as merging all four compositionality lemmas into one. They
hide the structural dependence of renamings and substitutions in a uniform,
\AgdaDatatype{Mode}-indexed vector (where \AgdaInductiveConstructor{V} is the
index for renamings and \AgdaInductiveConstructor{T} is the index for
substitutions) and use termination checking directly to make Agda see the
structural dependence, of renamings on substitutions, when it matters.

Saffrich~\cite{saffrich:LIPIcs.ITP.2024.32} adopts a different approach and
hides the structural dependence behind instance resolution. They work in a
scoped syntax setting and represent the uniform structure for renamings and
substitutions as functions, similar to the setting in this work. On top he
provides reflection-based code generation for the syntax-dependent $σ$-calculus
lemmas, which could maybe adopted to our setting, again to avoid external code
generation.

Adapting our approach with safe rewrite rules to a setting where renamings and
substitutions can be treated uniformely would be a logical next step. However,
for this to be useful in practice, the equational theory has to be extended in
non-obvious ways, to support uniform proofs over renamings and substitutions.
Furthermore, in this case we need a two-level rewrite system, one on the type
level for normalizing expressions in the lattice of \AgdaDatatype{Mode}s,
generated by \AgdaInductiveConstructor{V} $\sqsubseteq$
\AgdaInductiveConstructor{T}~\cite{altenkirch2025substitution}, and one for the
adapted $σ$-calculus. When expreimenting with this approach, we found that the
interaction of the two layers makes preservation of confluence difficult.

\section{Conclusion}\label{sec:con}
We have shown how to use the normalization procedure of the $σ$-calculus to
generate definitional equalities in Agda. To this end, we closely followed the
underlying equational theory of \text{Autosubst 2}, which provides the
normalization procedure for Rocq to produce propositional equalities. We
discovered that, to rewrite the full equational theory and maintain logical
consistency, we want two contrary things: the full computational behavior by a
modeling substitutions as functions, to instantiate of the equational theory
with proofs, but also symbolic behavior to make the rules eligible for rewrite
rules and higher-order pattern unification.

Successfully rewriting the $σ$-calculus rules safely also allows to pursue
interesting new adventures: More complex intrinsically typed representations
for syntax that do not end up in transfer hell, the question of whether this
approach can be applied to a uniform treatment of renamings and substitutions,
and if we can safely rewrite more algebraic structures this way.

\bibliography{references}

\end{document}
