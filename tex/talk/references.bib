@article{berardi1988towards,
  title={Towards a mathematical analysis of the Coquand-Huet calculus of constructions and the other systems in Barendregt’s cube},
  author={Berardi, Stefano},
  journal={Technica1 report, Carnegie-Me11on University (USA) and Universita di Torino (Ita1y)},
  year={1988}
}
@inproceedings{barendregt1990types,
  title={Types in lambda calculi and programming languages},
  author={Barendregt, Henk and Hemerik, Kees},
  booktitle={European Symposium on Programming},
  pages={1--35},
  year={1990},
  organization={Springer}
}
@article{terlouw1989een,
  title={Een nadere bewijstheoretische analyse van GSTT’s},
  author={Terlouw, Jan},
  journal={Manuscript (in Dutch)},
  year={1989}
}
@inproceedings{knuth1970simple,
  title={Simple word problems in universal algebras},
  author={Knuth, Donald E and Bendix, Peter B},
  booktitle={Computational problems in abstract algebra},
  pages={263--297},
  year={1970},
  organization={Elsevier}
}
% Agda
@phdthesis{norellPracticalProgrammingLanguage2007,
title = {Towards a Practical Programming Language Based on Dependent Type Theory},
author = {Norell, Ulf},
year = {2007},
month = sep,
address = {{SE-412 96 G\"oteborg, Sweden}},
abstract = {Dependent type theories [ML72] have a long history of being used for theorem proving. One aspect of type theory which makes it very powerful as a proof language is that it mixes deduction with computation. This also makes type theory a good candidate for programming	extemdash the strength of the type system allows properties of programs to be stated and established, and the computational properties provide semantics for the programs.},
url = {https://wcl.cs.rpi.edu/pilots/library/papers/TAGGED/4230-Norell (2007) - Towards a practical programming language based on dependent type theory.pdf},
keywords = {Agda},
school = {Department of Computer Science and Engineering, Chalmers University of Technology},
type = {{{PhD Thesis}}} 
}
@inproceedings{10.1007/978-3-662-49498-1_17,
author = {Keuchel, Steven and Weirich, Stephanie and Schrijvers, Tom},
title = {Needle \& Knot: Binder Boilerplate Tied Up},
year = {2016},
isbn = {9783662494974},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-662-49498-1_17},
doi = {10.1007/978-3-662-49498-1_17},
abstract = {To lighten the burden of programming language mechanization, many approaches have been developed that tackle the substantial boilerplate which arises from variable binders. Unfortunately, the existing approaches are limited in scope. They typically do not support complex binding forms such as multi-binders that arise in more advanced languages, or they do not tackle the boilerplate due to mentioning variables and binders in relations. As a consequence, the human mechanizer is still unnecessarily burdened with binder boilerplate and discouraged from taking on richer languages.This paper presents Knot, a new approach that substantially extends the support for binder boilerplate. Knot is a highly expressive language for natural and concise specification of syntax with binders. Its meta-theory constructively guarantees the coverage of a considerable amount of binder boilerplate for well-formed specifications, including that for well-scoping of terms and context lookups. Knot also comes with a code generator, Needle, that specializes the generic boilerplate for convenient embedding in Coq and provides a tactic library for automatically discharging proof obligations that frequently come up in proofs of weakening and substitution lemmas of type-systems.Our evaluation shows, that Needle \& Knot significantly reduce the size of language mechanizations by 40\"{\i} \'{z}\% in our case study. Moreover, as far as we know, Knot enables the most concise mechanization of the POPLmark Challenge 1a + 2a and is two-thirds the size of the next smallest. Finally, Knot allows us to mechanize for instance dependently-typed languages, which is notoriously challenging because of dependent contexts and mutually-recursive sorts with variables.},
booktitle = {Proceedings of the 25th European Symposium on Programming Languages and Systems - Volume 9632},
pages = {419–445},
numpages = {27}
}
@article{Nominal2-AFP,
  author  = {Christian Urban and Stefan Berghofer and Cezary Kaliszyk},
  title   = {Nominal 2},
  journal = {Archive of Formal Proofs},
  month   = {February},
  year    = {2013},
  note    = {\url{https://isa-afp.org/entries/Nominal2.html},
             Formal proof development},
  ISSN    = {2150-914x},
}
@incollection{MARTINLOF197573,
title = {An Intuitionistic Theory of Types: Predicative Part},
editor = {H.E. Rose and J.C. Shepherdson},
series = {Studies in Logic and the Foundations of Mathematics},
publisher = {Elsevier},
volume = {80},
pages = {73-118},
year = {1975},
booktitle = {Logic Colloquium '73},
issn = {0049-237X},
doi = {https://doi.org/10.1016/S0049-237X(08)71945-1},
url = {https://www.sciencedirect.com/science/article/pii/S0049237X08719451},
author = {Per Martin-Löf},
abstract = {Publisher Summary
The theory of types is intended to be a full-scale system for formalizing intuitionistic mathematics as developed. The language of the theory is richer than the languages of traditional intuitionistic systems in permitting proofs to appear as parts of propositions so that the propositions of the theory can express properties of proofs. There are axioms for universes that link the generation of objects and types and play somewhat the same role for the present theory as does the replacement axiom for Zermelo–Fraenkel set theory. The present theory is based on a strongly impredicative axiom that there is a type of all types in symbols. This axiom has to be abandoned, however, after it has been shown to lead to a contraction. This chapter discusses Normalization theorem, which can be strengthened in two ways: it can be made to cover open terms and it can be proved that every reduction sequence starting from an arbitrary term leads to a unique normal term after a finite number of steps. The definition of the notion of convertibility and the proof that an arbitrary term is convertible can no longer be separated because the type symbols and the terms are generated simultaneously.}
}
@article{10.1145/3236770,
author = {Cockx, Jesper and Abel, Andreas},
title = {Elaborating dependent (co)pattern matching},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236770},
doi = {10.1145/3236770},
abstract = {In a dependently typed language, we can guarantee correctness of our programs by providing formal proofs. To check them, the typechecker elaborates these programs and proofs into a low level core language. However, this core language is by nature hard to understand by mere humans, so how can we know we proved the right thing? This question occurs in particular for dependent copattern matching, a powerful language construct for writing programs and proofs by dependent case analysis and mixed induction/coinduction. A definition by copattern matching consists of a list of clauses that are elaborated to a case tree, which can be further translated to primitive eliminators. In previous work this second step has received a lot of attention, but the first step has been mostly ignored so far. We present an algorithm elaborating definitions by dependent copattern matching to a core language with inductive datatypes, coinductive record types, an identity type, and constants defined by well-typed case trees. To ensure correctness, we prove that elaboration preserves the first-match semantics of the user clauses. Based on this theoretical work, we reimplement the algorithm used by Agda to check left-hand sides of definitions by pattern matching. The new implementation is at the same time more general and less complex, and fixes a number of bugs and usability issues with the old version. Thus we take another step towards the formally verified implementation of a practical dependently typed language.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {75},
numpages = {30},
keywords = {Agda, Copatterns, Dependent pattern matching, Dependent types}
}
@article{gratzer2022controlling,
  title={Controlling unfolding in type theory},
  author={Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  journal={arXiv preprint arXiv:2210.05420},
  year={2022}
}
@inproceedings{10.1145/75277.75283,
author = {Wadler, P. and Blott, S.},
title = {How to make ad-hoc polymorphism less ad hoc},
year = {1989},
isbn = {0897912942},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/75277.75283},
doi = {10.1145/75277.75283},
abstract = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the “eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {60–76},
numpages = {17},
location = {Austin, Texas, USA},
series = {POPL '89}
}
@article{10.1145/3434341,
author = {Cockx, Jesper and Tabareau, Nicolas and Winterhalter, Th\'{e}o},
title = {The taming of the rew: a type theory with computational assumptions},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434341},
doi = {10.1145/3434341},
abstract = {Dependently typed programming languages and proof assistants such as Agda and Coq rely on computation to automatically simplify expressions during type checking. To overcome the lack of certain programming primitives or logical principles in those systems, it is common to appeal to axioms to postulate their existence. However, one can only postulate the bare existence of an axiom, not its computational behaviour. Instead, users are forced to postulate equality proofs and appeal to them explicitly to simplify expressions, making axioms dramatically more complicated to work with than built-in primitives. On the other hand, the equality reflection rule from extensional type theory solves these problems by collapsing computation and equality, at the cost of having no practical type checking algorithm. This paper introduces Rewriting Type Theory (RTT), a type theory where it is possible to add computational assumptions in the form of rewrite rules. Rewrite rules go beyond the computational capabilities of intensional type theory, but in contrast to extensional type theory, they are applied automatically so type checking does not require input from the user. To ensure type soundness of RTT—as well as effective type checking—we provide a framework where confluence of user-defined rewrite rules can be checked modularly and automatically, and where adding new rewrite rules is guaranteed to preserve subject reduction. The properties of RTT have been formally verified using the MetaCoq framework and an implementation of rewrite rules is already available in the Agda proof assistant.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {60},
numpages = {29},
keywords = {type theory, termination, rewriting theory, dependent types, confluence}
}
@InProceedings{cockx:LIPIcs.TYPES.2019.2,
  author =	{Cockx, Jesper},
  title =	{{Type Theory Unchained: Extending Agda with Userined Rewrite Rules}},
  booktitle =	{25th International Conference on Types for Proofs and Programs (TYPES 2019)},
  pages =	{2:1--2:27},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-158-0},
  ISSN =	{1868-8969},
  year =	{2020},
  volume =	{175},
  editor =	{Bezem, Marc and Mahboubi, Assia},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.TYPES.2019.2},
  URN =		{urn:nbn:de:0030-drops-130666},
  doi =		{10.4230/LIPIcs.TYPES.2019.2},
  annote =	{Keywords: Dependent types, Proof assistants, Rewrite rules, Higher-order rewriting, Agda}
}
% Tools
@article{siek2021parameterized,
  title={Parameterized cast calculi and reusable meta-theory for gradually typed lambda calculi},
  author={Siek, Jeremy G and Chen, Tianyu},
  journal={Journal of Functional Programming},
  volume={31},
  pages={e30},
  year={2021},
  publisher={Cambridge University Press}
}
@InProceedings{saffrich:LIPIcs.ITP.2024.32,
  author =	{Saffrich, Hannes},
  title =	{{Abstractions for Multi-Sorted Substitutions}},
  booktitle =	{15th International Conference on Interactive Theorem Proving (ITP 2024)},
  pages =	{32:1--32:19},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-337-9},
  ISSN =	{1868-8969},
  year =	{2024},
  volume =	{309},
  editor =	{Bertot, Yves and Kutsia, Temur and Norrish, Michael},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2024.32},
  URN =		{urn:nbn:de:0030-drops-207609},
  doi =		{10.4230/LIPIcs.ITP.2024.32},
  annote =	{Keywords: Agda, Metatheory, Framework}
}
@inproceedings{10.1145/3293880.3294101,
  author = {Stark, Kathrin and Sch\"{a}fer, Steven and Kaiser, Jonas},
  title = {Autosubst 2: reasoning with multi-sorted de Bruijn terms and vector substitutions},
  year = {2019},
  isbn = {9781450362221},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3293880.3294101},
  doi = {10.1145/3293880.3294101},
  pages = {166–180},
  numpages = {15},
  keywords = {sigma-calculus, parallel substiutions, multi-sorted terms, de Bruijn repersentation},
  location = {Cascais, Portugal},
  series = {CPP 2019}
}
@phdthesis{Stark:2020:Mechanising,
  author       = {Kathrin Stark},
  title        = {Mechanising Syntax with Binders in {Coq}},
  school       = {Saarland University},
  address      = {Saarbrücken, Germany},
  year         = {2020},
  month        = {January},
  pages        = {206},
  note         = {Dissertation zur Erlangung des Grades des Doktors der Ingenieurwissenschaften (Dr.-Ing.)},
}
@inproceedings{10.1007/11532231_4,
  author = {Urban, Christian and Tasson, Christine},
  title = {Nominal techniques in Isabelle/HOL},
  year = {2005},
  isbn = {3540280057},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  url = {https://doi.org/10.1007/11532231_4},
  doi = {10.1007/11532231_4},
  booktitle = {Proceedings of the 20th International Conference on Automated Deduction},
  pages = {38–53},
  numpages = {16},
  keywords = {lambda-calculus, nominal logic, structural induction, theorem-assistants},
  location = {Tallinn, Estonia},
  series = {CADE' 20}
}
@misc{allais2021typescopesafeuniverse,
  title={A Type and Scope Safe Universe of Syntaxes with Binding: Their Semantics and Proofs}, 
  author={Guillaume Allais and Robert Atkey and James Chapman and Conor McBride and James McKinna},
  year={2021},
  eprint={2001.11001},
  archivePrefix={arXiv},
  primaryClass={cs.PL},
  url={https://arxiv.org/abs/2001.11001}, 
}
@article{stronglytyped,
  author = {Benton, Nick and Hur, Chung-Kil and Kennedy, Andrew and McBride, Conor},
  year = {2012},
  month = {08},
  pages = {1-19},
  title = {Strongly Typed Term Representations in Coq},
  volume = {49},
  journal = {Journal of Automated Reasoning - JAR},
  doi = {10.1007/s10817-011-9219-0}
}
@unpublished{ren-sub,
  author       = {Conor McBride},
  title        = {Type-preserving renaming and substitution},
  note         = {Unpublished manuscript},
  year         = {2005},
  url          = {http://strictlypositive.org/ren-sub.pdf},
  howpublished = {\url{http://strictlypositive.org/ren-sub.pdf}}
}
@inproceedings{altenkirch2025substitution,
  author       = {Altenkirch, Thorsten and Burke, Nathaniel and Wadler, Philip},
  title        = {Substitution without copy and paste},
  booktitle    = {Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP\,25)},
  year         = {2025},
  date         = {2025-07-19},
  address      = {Birmingham, UK},
  howpublished = {\url{https://nottingham-repository.worktribe.com/output/51884690/substitution-without-copy-and-paste}}
}
@inproceedings{10.1145/2535838.2535856,
author = {Eisenberg, Richard A. and Vytiniotis, Dimitrios and Peyton Jones, Simon and Weirich, Stephanie},
title = {Closed type families with overlapping equations},
year = {2014},
isbn = {9781450325448},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2535838.2535856},
doi = {10.1145/2535838.2535856},
abstract = {Open, type-level functions are a recent innovation in Haskell that move Haskell towards the expressiveness of dependent types, while retaining the look and feel of a practical programming language. This paper shows how to increase expressiveness still further, by adding closed type functions whose equations may overlap, and may have non-linear patterns over an open type universe. Although practically useful and simple to implement, these features go beyond conventional dependent type theory in some respects, and have a subtle metatheory.},
booktitle = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {671–683},
numpages = {13},
keywords = {haskell, system fc, type families, type-level computation},
location = {San Diego, California, USA},
series = {POPL '14}
}

@article{10.1145/2578855.2535856,
author = {Eisenberg, Richard A. and Vytiniotis, Dimitrios and Peyton Jones, Simon and Weirich, Stephanie},
title = {Closed type families with overlapping equations},
year = {2014},
issue_date = {January 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2578855.2535856},
doi = {10.1145/2578855.2535856},
abstract = {Open, type-level functions are a recent innovation in Haskell that move Haskell towards the expressiveness of dependent types, while retaining the look and feel of a practical programming language. This paper shows how to increase expressiveness still further, by adding closed type functions whose equations may overlap, and may have non-linear patterns over an open type universe. Although practically useful and simple to implement, these features go beyond conventional dependent type theory in some respects, and have a subtle metatheory.},
journal = {SIGPLAN Not.},
month = jan,
pages = {671–683},
numpages = {13},
keywords = {haskell, system fc, type families, type-level computation}
}


% Substitutions
@article{goguen1997candidates,
  title={Candidates for substitution},
  author={Goguen, Healfdene and McKinna, James},
  journal={LFCS report series-Laboratory for Foundations of Computer Science ECS LFCS},
  year={1997},
  publisher={UNIVERSITY OF EDINBURGH}
}
@InProceedings{10.1007/11617990_1,
author="Adams, Robin",
editor="Filli{\^a}tre, Jean-Christophe
and Paulin-Mohring, Christine
and Werner, Benjamin",
title="Formalized Metatheory with Terms Represented by an Indexed Family of Types",
booktitle="Types for Proofs and Programs",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--16",
abstract="It is possible to represent the terms of a syntax with binding constructors by a family of types, indexed by the free variables that may occur. This approach has been used several times for the study of syntax and substitution, but never for the formalization of the metatheory of a typing system. We describe a recent formalization of the metatheory of Pure Type Systems in Coq as an example of such a formalization. In general, careful thought is required as to how each definition and theorem should be stated, usually in an unfamiliar `big-step' form; but, once the correct form has been found, the proofs are very elegant and direct.",
isbn="978-3-540-31429-5"
}
@inproceedings{10.1145/96709.96712,
  author = {Abadi, M. and Cardelli, L. and Curien, P.-L. and Levy, J.-J.},
  title = {Explicit substitutions},
  year = {1989},
  isbn = {0897913434},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/96709.96712},
  doi = {10.1145/96709.96712},
  booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages = {31–46},
  numpages = {16},
  location = {San Francisco, California, USA},
  series = {POPL '90}
}
@inproceedings{schafer2015autosubst,
  title={Autosubst: Reasoning with de Bruijn terms and parallel substitutions},
  author={Sch{\"a}fer, Steven and Tebbi, Tobias and Smolka, Gert},
  booktitle={International Conference on Interactive Theorem Proving},
  pages={359--374},
  year={2015},
  organization={Springer}
}
@inproceedings{10.1145/2676724.2693163,
author = {Sch\"{a}fer, Steven and Smolka, Gert and Tebbi, Tobias},
  title = {Completeness and Decidability of de Bruijn Substitution Algebra in Coq},
  year = {2015},
  isbn = {9781450332965},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2676724.2693163},
  doi = {10.1145/2676724.2693163},
  booktitle = {Proceedings of the 2015 Conference on Certified Programs and Proofs},
  pages = {67–73},
  numpages = {7},
  keywords = {finite axiomatization, explicit substitutions, decision procedures, de bruijn terms, coq, completeness, algebra},
  location = {Mumbai, India},
  series = {CPP '15}
}
@article{10.1145/226643.226675,
  author = {Curien, Pierre-Louis and Hardin, Th\'{e}r\`{e}se and L\'{e}vy, Jean-Jacques},
  title = {Confluence properties of weak and strong calculi of explicit substitutions},
  year = {1996},
  issue_date = {March 1996},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {43},
  number = {2},
  issn = {0004-5411},
  url = {https://doi.org/10.1145/226643.226675},
  doi = {10.1145/226643.226675},
  journal = {J. ACM},
  month = mar,
  pages = {362–397},
  numpages = {36},
  keywords = {confluency, explicit substitutions}
}
% System F 
@phdthesis{girard1972,
  author       = {Jean-Yves Girard},
  title        = {Interprétation fonctionnelle et élimination des coupures de l’arithmétique d’ordre supérieur},
  school       = {Éditeur inconnu},
  year         = {1972},
  type         = {PhD thesis},
  language     = {french}
}
% System F Sub
@article{CARDELLI19944,
title = {An Extension of System F with Subtyping},
journal = {Information and Computation},
volume = {109},
number = {1},
pages = {4-56},
year = {1994},
issn = {0890-5401},
doi = {https://doi.org/10.1006/inco.1994.1013},
url = {https://www.sciencedirect.com/science/article/pii/S0890540184710133},
author = {L. Cardelli and S. Martini and J.C. Mitchell and A. Scedrov},
}⏎
# MLTT 
@book{martinlof1984,
  author    = {Per Martin-L{\"o}f},
  title     = {Intuitionistic Type Theory},
  year      = {1984},
  publisher = {Bibliopolis},
  address   = {Naples},
  note      = {Notes by Giovanni Sambin of a series of lectures given in Padua, June 1980}
}