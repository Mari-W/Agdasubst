\documentclass[screen,nonacm]{acmart}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{agda}

\input{agda-generated}
\input{agdamacros}
\input{unicodeletters}

\definecolor{myblue}{HTML}{0000CD}
\newcommand{\bsym}[1]{\textcolor{myblue}{#1}}


\begin{document}

\title{Agdasubst: Reasoning for Substitutions over Scoped and Multi-Sorted Syntaxes}

\author{Marius Weidner}
\email{weidner@cs.uni-freiburg.de}
\affiliation{%
      \institution{University of Freiburg}
      \country{Germany}}
\orcid{0009-0008-1152-165X} % chktex 8
\authornote{
      I hereby declare that I am the sole author and composer of my thesis and that
      no other sources or learning aids, other than those listed, have been used.\\
      Furthermore, I declare that I have acknowledged the work of others by providing
      detailed references of said work.\\
      I hereby also declare that my thesis has not been prepared for another
      examination or assignment, either wholly or excerpts thereof.
      \\
      \\
      \begin{tabular}{p{\textwidth/2} l}
            Freiburg, XX.XX.2025       & yadda yadda                \\ % \includegraphics[width=0.1\textwidth]{signature.png} \\
            \rule{\textwidth/3}{0.4pt} & \rule{\textwidth/3}{0.4pt} \\
            Place, Date                & Signature
      \end{tabular}
}

\begin{abstract}

\end{abstract}

\maketitle

\section{Introduction}\label{sec:introduction}

Mechanizing the metatheory of programming languages within interactive theorem
provers frequently presents a significant and recurring technical challenge
when handling variable binding and substitution. While these details are often
ignored in pen-and-paper proofs, their concrete formalization in proof
assistants demands rigorous definitions and proofs as well as a lot of manual
effort. This burden is notable even for fundamental properties such as subject
reduction of simple calculi.

Historically, substitution has been treated as an meta-level operation. To
formalize this, explicit substitution calculi CITE were introduced to bring
substitutions down to a syntactic level. These calculi define substitution
behavior through a set of reduction rules. With the $σ_{SP}$-calculus CITE, an
extension of the $σ$-calculus, a complete, confluent, and terminating CITE
rewrite system for $λ$-calculus terms with substitution has been discovered.
Applying the reduction rules from left to right until a fixed point has
reached, guarantees a normal form that can be compared syntactically to
another. Notably, the $σ_{SP}$-calculus can be easily adapted to custom
syntaxes, even ones with more than one syntactic category CITE.

Explicit substitution calculi and the formalization of meta theory in proof
assistants are usually based on de Bruijn indices, which provide an automatic
and name-free method for managing variable binding and α-equivalence, thereby
automatically resolving name clashes.

A core issue in mechanizing the theory for substitutions is the need for
separation of renamings (substitutions that map variables only to other
variables) from general substitutions (replacing variables with full terms), to
allow for a structurally recursive definition. This separation often leads to a
code duplication, where key lemmas, such as substitution preserves typing, must
be proven twice, once for renamings and then again for general substitutions
using the result about renamings. The problem is further compounded in
languages supporting multiple variable sorts, where a combinatory explosion of
variable sorts and syntactic categories can lead to numerous near-identical
substitution definitions and lemmas.

The "Kit" abstraction, introduced by McBride CITE, serves to unify renamings
and substitutions. Automation frameworks have been developed to address this
boilerplate. For Coq, the Autosubst framework [Rambeling 2, 465, 467, 382] and
its successor, Autosubst 2, automate much of this boilerplate [Rambeling 2,
            465, 467, 382]. Autosubst 2 functions as an external code generator capable of
handling multi-sorted and mutually inductive syntax, generating definitions for
de Bruijn terms and parallel or "vectorised" substitutions [Rambeling 2, 465,
            466, 383, 476, 480, 486, 509]. While vector substitutions aim to simplify the
equational theory for multiple sorts [Rambeling 2, 476, 487], Autosubst 2 still
operates in "two worlds," separating renamings and substitutions, and thus
requires initial proofs for renamings before tackling general substitution
properties [Rambeling 2, 466, 475, 495]. Agda's introduction of user-defined
REWRITE rules presents a promising avenue for integrating σ-calculus rules
natively [Rambeling 2, 466, 214, 246, 431, 479]. These rules allow users to
extend the language's definitional equality with new computation rules,
effectively turning propositional equalities into computational ones [Rambeling
            2, 466, 222, 399, 403, 431]. However, the power of user-defined rewrite rules
also introduces challenges: arbitrary rules can undermine crucial
metatheoretical properties such as consistency, decidability of type checking,
or even subject reduction, particularly if they are not confluent [Rambeling 2,
            215, 228, 229, 231, 249, 404, 440, 432]. Confluence is particularly important
for the practical feasibility of type checking [Rambeling 2, 215, 228, 229,
            231, 249, 404, 440]. The literature presents a novel Agda library that directly
addresses these challenges by integrating a version of the σ-calculus into Agda
      [Rambeling 2]. This approach draws inspiration from Saffrich's work on
multi-sorted substitutions and McBride's "kit" abstraction, which unifies
renamings and substitutions [Rambeling 2, 364, 386, 398, 422]. The library aims
to resolve the "two-world" problem within Agda by providing a unified
abstraction for renamings and substitutions [Rambeling 2, 358, 479]. This
enables fundamental lemmas, such as "substitution preserves typing," to be
proven once for both concepts, significantly reducing the proof burden
      [Rambeling 2, 358]. By employing Agda's REWRITE rules, the library focuses on
natively embedding a σ-calculus-adjacent rewriting system, ensuring that
substitution operations are not just provable but are definitionally available
within the language [Rambeling 2, 479]. The framework facilitates the reliable
extension of Agda's definitional equality for complex binding structures, while
acknowledging and providing a basis for addressing the inherent metatheoretical
challenges (e.g., confluence and subject reduction) posed by user-defined
rewrite rules, with the aim for a system where confluence can be checked
modularly and automatically [Rambeling 2, 215].

\subsection*{Structure}

\begin{itemize}
      \item \cref{sec:pre} introduces theory and tools used for our developments.

      \item \cref{sec:rel} provides an overview of the current state of the art of libraries for
            proof assistants that deal with substitution machinery.

      \item \cref{sec:emb} shows how do use the a version of the $\sigma$-calculus in agda

      \item \cref{sec:ags} constitutes the main part of this paper and outlines the internal
            workings of the \texttt{Agdasubst} library, as well as thread ren and sub uniformely.

      \item In \cref{sec:ext} we discuss extensions based on the \texttt{Agdasubst} library
            and its extensibility in general.

      \item We look at case studies using \texttt{Agdasubst} in \cref{sec:cas}
\end{itemize}

\textbf{The supplement contains the complete Agda code underlying this paper.}

\section{Preliminaries}\label{sec:pre}
This section introduces the foundational concepts and tools required for the
developments in this work. Our work relies on features of the Agda proof
assistant that go beyond standard dependent types, as well as on syntactic
frameworks for modeling substitutions and binders. We summarize the following
components:

\begin{itemize}
      \item Agda features relevant to this work: \AgdaKeyword{instance} arguments,
            \AgdaKeyword{opaque} blocks, and the \AgdaKeyword{REWRITE} mechanism for
            defining custom reduction rules;
      \item The $\sigma$-calculus, an explicit substitution calculus that is terminating
            and confluent, serving as a foundation for syntactic reasoning about
            substitution;
      \item The use of multi-sorted and intrinsically scoped syntax in Agda.
\end{itemize}

\subsection{Agda, \AgdaKeyword{instance} Arguments, \AgdaKeyword{opaque} Blocks and the Ability to
      \AgdaKeyword{REWRITE}}\label{sec:pre-agd} Agda\footnote{CITE} is a dependently
typed programming language and proof assistant based on Martin-Löf type theory.
It allows users to write programs and proofs in a functional language,
verifying correctness through type checking.

In addition to its well-known features such as implicit arguments, indexed and
parameterized inductive data types, records, and dependent pattern matching,
Agda also supports three less commonly used but important features relevant to
this work: \AgdaKeyword{instance} arguments, \AgdaKeyword{opaque} blocks and
\AgdaKeyword{REWRITE} rules.

\subsection*{Instance Arguments}

Instance arguments, written using double braces \verb|{{...}}|, differ from
implicit arguments \verb|{...}| in that they are automatically resolved via an
instance search algorithm, rather than simple implicit argument resolution
limited to the current scope. When a function expects an instance argument,
Agda attempts to infer and insert it from values in scope marked with the
\AgdaKeyword{instance} keyword. This mechanism enables type-directed
programming patterns similar to type classes in Haskell.

As an example, consider the following definition of a type class for types with
a default value: \EDefault{} The record can be opened using instance argument
resolution for its fields: \EDefFields{} We can now declare an instance for
natural numbers: \EDefInst{} This enables implicit usage of the default value
via instance search: \EDefEx{} Here, Agda infers from the type \verb|ℕ| of
\verb|0| that the instance \verb|default–ℕ| applies for \verb|default|,
inserting it automatically to conclude \verb|default ≡ 0| holds definitionally.

\subsection*{\AgdaKeyword{opaque} Blocks}

Agda also supports opaque definitions, which allow certain parts of the code to
be treated as non-unfolding symbols, similar to postulates. This feature is
useful for controlling definitional equality and can be used to prevent
specific definitions from being unfolded during type checking or conversion
checking.

A block is marked as opaque by preceding it with the \AgdaKeyword{opaque}
keyword. All definitions within the block become opaque, meaning they are
excluded from definitional equality checks. However, their names and types
remain visible and can still be used throughout the code. As an example
consider: \EOpaque{}

In this example, \verb|forty-two| is defined as the numeral \verb|42|, but it
is opaque outside the block. This means that although \verb|forty-two| still
has type \verb|ℕ| and can be used in expressions and proofs, it does not reduce
to \verb|5| outside the block during definitional equality checks: \EOpaqueExO

In subsequent opaque blocks, the type checker can be instructed to selectively
unfold previously opaque definitions using the \AgdaKeyword{unfolding} keyword.

Using \AgdaKeyword{unfolding}, the definition will again reduce as expected:
\EOpaqueExT{}

\subsection*{\AgdaKeyword{REWRITE} Rules}

Another feature of Agda are user-defined \AgdaKeyword{REWRITE}
rules\footnote{CITE} that extend the system’s notion of definitional equality
by integrating them directly into type checking. A rewrite rule in Agda is a
named equation of the form
\[
      \texttt{eq} : (x_1 : A_1)\, \ldots\, (x_k : A_k) \to f\, p_1\, \ldots\, p_n = v
\]
and must satisfy the following \emph{three conditions}\footnote{CITE}:
\begin{enumerate}
      \item The head symbol $f$ must be a \emph{postulate}, a \emph{defined function}, or a
            \emph{constructor} applied to \emph{fully general parameters}, i.e., the
            parameters must be distinct variables.
      \item Each variable $x_1, \ldots, x_k$ must occur at least once in a \emph{pattern
                  position} among $p_1, \ldots, p_n$ (see CITE for the precise definition of
            pattern position).
      \item The left-hand side $f\, p_1\, \ldots\, p_n$ must be \emph{neutral}, i.e., it
            should not reduce any further under existing definitions.
\end{enumerate}

For example: \ERewrite{} The type of the lemma satisfies the conditions above
and can be registered as a rewrite rule using the \AgdaKeyword{REWRITE} pragma:
\ERewriteIt{}

From this point forward, Agda treats \verb|n + 0| as \emph{definitionally
      equal} to \verb|n|: \ERewriteEx

To ensure consistency, Agda requires that all rewrite rules satisfy the three
conditions stated above, and that the combined set of rules is both
\emph{terminating} and \emph{confluent}. However, termination is not currently
checked by Agda; it is only observable indirectly when type checking fails to
terminate. Confluence can be checked using the
\texttt{--local-confluence-check} and \texttt{--confluence-check} flags, but
both checks are necessarily conservative.

\subsection{Explicit Substitution Calculi}\label{sec:pre-sig}

Calculi of explicit substitutions were introduced to formalize the
traditionally meta-theoretic treatment of substitutions. Unlike the standard
method, where substitution is a meta-level operation, these calculi internalize
substitutions as first-class syntactic constructs, governed by reduction rules.
This explicit treatment enables a detailed analysis of operational
properties~\cite{CITE1}.

Several explicit substitution calculi have been proposed. The
$\sigma$-calculus~\cite{CITE3} introduces substitution primitives such as
identity, extension, shifting, and composition. The
$\sigma^\Uparrow$-calculus~\cite{CITE4} extends this framework with a primitive
for lifting. Among these, the $\sigma_{SP}$-calculus~\cite{CITE5} distinguishes
itself by enhancing the reduction system to ensure confluence while maintaining
termination.

The $\sigma_{SP}$-calculus is of particular interest because it is sound,
confluent, and complete with respect to equality in the de Bruijn algebra of
the $\lambda$-calculus~\cite{CITE}. Consequently, any valid equality between
terms involving substitutions can be derived solely using its reduction rules.

In the following, we introduce the syntax and reduction semantics of our own
versions of the $\sigma$-calculus in two stages:

\begin{itemize}
      \item We first use the $\lambda$-calculus as an example to present the a variant that
            closely resembles the $\sigma_{SP}$-calculus;
      \item Next, we extend the above with renamings[CITE].
\end{itemize}

We believe the following calculi to be terminating and confluent. Although we
do not provide a formal proof, they are reasonable variants of the
$\sigma_{SP}$-calculus. Since renamings are necessary in theorem prover
settings and are believed to cause loss of completeness[CITE], we do not
consider completeness an important property in this context.

\subsection*{The three-sorted $\sigma$-calculus}
We present a three-sorted version of the $\sigma$-calculus in
Figure~\ref{fig:pre:sig}.

The syntax is sorted into: de~Bruijn variables, terms, and substitution
primitives. Variables $x$ range over de~Bruijn variables, $t$ over terms, and
$\sigma$ over substitutions. The expression $\textcolor{myblue}{\uparrow}
      \sigma$ is syntactic sugar for
$(\texttt{\`{}}\textcolor{myblue}{\mathsf{zero}}) \textcolor{myblue}{\cdot}
      (\sigma \ \textcolor{myblue}{;} \ \textcolor{myblue}{\mathsf{wk}})$. Our
presentation differs from the standard literature by including explicit syntax
for variable usage within terms. This requires distinguishing between
\bsym{\textsf{suc}} and \bsym{\textsf{wk}}, depending on whether they are used
as variable or substitution primitives.

The reduction rules are classified into four categories:
\begin{itemize}
      \item \textbf{Definitional laws} describe how variables are looked up in substitutions
      \item \textbf{Interaction laws} express equalities between substitutions
      \item \textbf{Traversal laws} describe how substitutions traverse terms and go under binders
      \item \textbf{Monad laws} show how substitutions behave when applied to terms
\end{itemize}

\subsubsection*{Remark}
We do not include reduction rules for the language itself, such as
$\beta$-reduction. The reduction strategy for terms is considered part of the
language and is left to the user of our library to define. The only
term syntax dependent laws we require are those concerned with traversal, that is,
applying substitutions to terms.

\begin{figure}[t]
      \centering
      \small
      {\raggedright \textbf{\Large Symbols} \par}
      \vspace{1.5em}

      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Variables} $x$
            \begin{align*}
                  \text{innermost variable} \quad & \textcolor{myblue}{\mathsf{zero}}    \\
                  \text{outer variables} \quad    & \textcolor{myblue}{\mathsf{suc}}\; x
            \end{align*}\\
            \vspace{1em}
            \textbf{Terms} $t$
            \begin{align*}
                  \text{variable usage} \quad           & \textcolor{myblue}{\texttt{\`{}}}x                                                                                                  \\
                  \text{abstraction} \quad              & \textcolor{myblue}{\lambda.}\, t                                                                                                    \\
                  \text{application} \quad              & t_1 \ t_2                                                                                                                           \\
                  \text{substitution application} \quad & t \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu \sigma
            \end{align*}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Substitutions} $\sigma$
            \begin{align*}
                  \text{identity} \quad    & \textcolor{myblue}{\mathsf{id}}              \\
                  \text{extension} \quad   & t \textcolor{myblue}{\cdot} \sigma           \\
                  \text{weakening} \quad   & \textcolor{myblue}{\mathsf{wk}}              \\
                  \text{composition} \quad & \sigma_1 \ \textcolor{myblue}{;} \  \sigma_2 \\
                  \text{lookup} \quad      & x \textcolor{myblue}{\;\&\;} \sigma
            \end{align*}
      \end{minipage}

      {\raggedright \vspace{2.0em} \textbf{\Large Reduction} \par}
      \vspace{1.5em}
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Definitional Laws}
            \begin{alignat*}{2}
                  \mathsf{id}      \quad          & x \textcolor{myblue}{\;\&\;} \textcolor{myblue}{\mathsf{id}}                                        &  & = \textcolor{myblue}{\texttt{\`{}}} x                                                                                                                                         \\
                  \mathsf{ext}_\mathsf{Z}  \quad  & \textcolor{myblue}{\mathsf{zero}} \textcolor{myblue}{\;\&\;} (t \textcolor{myblue}{\cdot} \sigma)   &  & = t                                                                                                                                                                           \\
                  \mathsf{ext}_\mathsf{S}   \quad & \textcolor{myblue}{\mathsf{suc}}\;x \textcolor{myblue}{\;\&\;} (t \textcolor{myblue}{\cdot} \sigma) &  & = x \textcolor{myblue}{\;\&\;} \sigma                                                                                                                                         \\
                  \mathsf{wk}      \quad          & x \textcolor{myblue}{\;\&\;} \textcolor{myblue}{\mathsf{wk}}                                        &  & = \texttt{\`{}}(\textcolor{myblue}{\mathsf{suc}} \ x)                                                                                                                         \\
                  \mathsf{comp}    \quad          & x \textcolor{myblue}{\;\&\;} (\sigma_1 \ \textcolor{myblue}{;} \  \sigma_2)                         &  & = (x \textcolor{myblue}{\;\&\;} \sigma_1) \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu \sigma_2
            \end{alignat*}\\
            \vspace{1em}
            \textbf{Traversal Laws}
            \begin{alignat*}{2}
                  \mathsf{var} \quad & (\textcolor{myblue}{\texttt{\`{}}} x) \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu \sigma
                                     & \quad                                                                                                                                                                   & = x \textcolor{myblue}{\;\&\;} \sigma                                                                                                                                                                                                                                                 \\
                  \mathsf{lam} \quad & (\textcolor{myblue}{\lambda.}\, t) \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu  \sigma
                                     &                                                                                                                                                                         & = \textcolor{myblue}{\lambda.} (t  \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu (\textcolor{myblue}{\uparrow}\sigma))                                                                                   \\
                  \mathsf{app} \quad & (t_1 \ t_2) \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu \sigma
                                     &                                                                                                                                                                         & = (t_1  \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu \sigma) \ (t_2  \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu \sigma)
            \end{alignat*}

      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Interaction Laws}
            \begin{alignat*}{2}
                  \mathsf{comp\text{-}id}_\mathsf{L} \quad & \textcolor{myblue}{\mathsf{id}} \ \textcolor{myblue}{;} \  \sigma                                                                                                   &  & = \sigma                                                                                                                                                                                                 \\
                  \mathsf{comp\text{-}id}_\mathsf{R} \quad & \sigma \ \textcolor{myblue}{;} \  \textcolor{myblue}{\mathsf{id}}                                                                                                   &  & = \sigma                                                                                                                                                                                                 \\
                  \mathsf{associativity}          \quad    & (\sigma_1 \ \textcolor{myblue}{;} \  \sigma_2) \ \textcolor{myblue}{;} \  \sigma_3                                                                                  &  & = \sigma_1 \ \textcolor{myblue}{;} \  (\sigma_2 \ \textcolor{myblue}{;} \  \sigma_3)                                                                                                                     \\
                  \mathsf{distributivity}           \quad  & (t \textcolor{myblue}{\cdot} \sigma_1) \ \textcolor{myblue}{;} \  \sigma_2                                                                                          &  & = (t \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \sigma_2) \textcolor{myblue}{\cdot} (\sigma_1 \ \textcolor{myblue}{;} \  \sigma_2) \\
                  \mathsf{interact}       \quad            & \textcolor{myblue}{\mathsf{wk}} \ \textcolor{myblue}{;} \  (t \textcolor{myblue}{\cdot} \sigma)                                                                     &  & = \sigma                                                                                                                                                                                                 \\
                  \eta\mathsf{\text{-}id}        \quad     & (\textcolor{myblue}{\texttt{\`{}}\mathsf{zero}}) \textcolor{myblue}{\cdot} \textcolor{myblue}{\mathsf{wk}}                                                          &  & = \textcolor{myblue}{\mathsf{id}}                                                                                                                                                                        \\
                  \eta\mathsf{\text{-}law}       \quad     & (\textcolor{myblue}{\mathsf{zero}} \textcolor{myblue}{\;\&\;} \sigma) \textcolor{myblue}{\cdot} (\textcolor{myblue}{\mathsf{wk}} \ \textcolor{myblue}{;} \  \sigma) &  & = \sigma
            \end{alignat*}\\
            \vspace{1em}
            \textbf{Monad Laws}
            \begin{alignat*}{2}
                  \mathsf{right\text{-}id} \quad          & t  \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu
                  \mathsf{id}                             &                                                                                                                                & = t                                                                                                                             \\
                  \mathsf{compositionality}         \quad & (t  \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu
                  \sigma_1)  \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu
                  \sigma_2                                &                                                                                                                                & = t  \mkern2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern-2mu \textcolor{myblue}{\cdotp} \mkern1mu
                  (\sigma_1 ; \sigma_2)
            \end{alignat*}
      \end{minipage}
      \caption{Syntax and reduction rules of the three-sorted $\sigma$-calculus.}
      \label{fig:pre:sig}
\end{figure}

\subsection*{Extension with Renamings}

\subsection{Scoped and Multi-Sorted Syntaxes with Substitutions}\label{sec:pre-syn}
\begin{figure}[h]
      \centering
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \EScoped{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \EMultiSorted{}
      \end{minipage}
      \caption{Classic Scoped Syntax vs. Multi-Sorted and Scoped Syntax}
      \label{fig:pre:svm}
\end{figure}

\begin{figure}[h]
      \centering
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ERen{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESub{}
      \end{minipage}
      \caption{Scoped and Multi-Sorted Renamings and Substitutions}
      \label{fig:pre:ras}
\end{figure}

% sorts -> sorts syntax into e.g. types and expr. 
% define syntax in one data type 

\section{The Multi-Sorted and Scoped $\sigma$-Calculus in Agda}\label{sec:mis}
% straight forward way to embed the sigma calculus in agda, but with ren and subs
% multiple laws 
% recall syntax from preliminaries 
% define substitutions etc
% proven in supplement
% not induction on t in monad laws
% funext dependence
% they all are rewritable
\begin{figure}[h]
      \centering

      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \EDefLaws{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth})
            \raggedright{}
            \EMonadLaws{}
      \end{minipage}

      \vspace{1em}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ERewriteSys{}
      \end{minipage}
      \hfill
      \raisebox{7.5em}[0pt][0pt]{%
            \begin{minipage}[t]{0.48\linewidth}
                  \raggedright{}
                  \EInteractLaws{}
            \end{minipage}
      }
      \caption{The $\sigma$-calculus rules for Renamings and Substitutions}
      \label{fig:six-frame-layout}
\end{figure}

\subsection{}

\subsection{Discussion}\label{sec:rsn-dis}
% putting 1 and 2 together to gain new library
% that enables one to prove stuff easy for sub
% and ren in proof theoretic setting

\section{The Agdasubst Library}\label{sec:ags}
\subsection{Related Work: Abstractions for Multi-Sorted Substitutions}

% shows the implementation
% explain main idea
% running example will be system f
% show how to but ren and sub together!

\subsection{Kits and Traversal}\label{sec:ags-kit}

% tags
% symbols are abstract
% ren and sub instances
% symbols in explicit substitutions are not meta -> they are
% symbols, make them opaque
% footnote? % functions != fields % locking

\subsection{Composition and Compositionality}\label{sec:ags-kit}
% compose kits (symbols etc)
% new operator lookup/traverse `/id
% we will need extensions to the calculus

% commutativity issue
% postulated the uniqueness
% bounded semi lattice structure to calculate the 3rd kit of the compose kit 
% footnote tried only 2 but not general enough

\subsection{The Final Set of Rules}\label{sec:ags-rls}
\begin{figure}[t]
      \centering
      \small
      {\raggedright \textbf{\Large Symbols} \par}
      \vspace{1.5em}

      \begin{minipage}[t]{0.48\textwidth}
            \raggedright{}
            \textbf{Variables} $x$ \\
            \vspace{0.5em}
            \AZero{}\\
            \ASuc{}\\
            \vspace{1em}
            \textbf{Terms} $t$ \\
            \vspace{0.5em}
            \AVarC{}\\
            \emph{.. custom object language ..}\\
            \AAppKit{}      
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright{}
            \textbf{Variables or Terms} $q$\\
            \vspace{0.5em}
            \ALookup{}\\
            \ALookOrApp{}\\
            \vspace{1em} 
            \textbf{Kits} $K$ \\
            \vspace{0.5em}
            \AKRen{}\\
            \AKSub{}\\
            \AKLub{}\\
            \vspace{1em}
            \textbf{Renamings or Substitutions} $ϕ$\\
            \vspace{0.5em}
            \AId{}\\
            \AWk{}\\
            \AExtend{}\\
            \AComp{}\\
      \end{minipage}
      
      {\raggedright \vspace{2.0em} \textbf{\Large Reduction} \par}
      \vspace{1.5em}
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Definitional Laws}\\
            \vspace{0.5em}
            
            % todo space and align
            %\AIdDef{}\\
            \AExtDefZ{}\\
            \AExtDefS{}\\
            %\AWkDef{}\\
            \ACompDef{}\\

            \vspace{1em}
            \textbf{Instantiation Laws}\\
            \vspace{0.5em}
            \AVarDef{}\\
            \ATrmDef{}\\
            \ALookAppDefR{}\\
            \ALookAppDefS{}\\
            \AIdRDef{}\\
            \AIdSDef{}\\
            \AWkRDef{}\\
            \AWkSDef{}\\
            \vspace{1em}
            \textbf{Traversal Laws}\\
            \vspace{0.5em}
            \AVarTrav{}\\
            \AAppVar{}\\
            \emph{.. custom object language traversal ..}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Kit Laws}\\
            \vspace{0.5em}
            \AKIdem{}\\
            \AKBR{}\\
            \AKBL{}\\
            \AKTR{}\\
            \AKTL{}\\
            \AKAssoc{}\\
            \vspace{1em} 
            \textbf{Interaction Laws}\\
            \vspace{0.5em}
            \ACompIdL{}\\
            \ACompIdR{}\\
            \AAssoc{}\\
            \ADist{}\\
            \AInteract{}\\
            \AEtaId{}\\
            \AEtaLaw{}\\
            \ANormId{}\\
            \vspace{1em}
            \textbf{Monad Laws}\\
            \vspace{0.5em}
            \ARightId{}\\
            \ACompositionality{}
            \AAppComp{}\\
            \AAppRightId{}
      \end{minipage}
      \caption{Syntax and reduction rules of the \AgdaFunction{Kit}-based, multi-sorted $\sigma$-calculus.}
      \label{fig:ags:fin}
\end{figure}

\subsection{Limitations}\label{sec:ags-lim}
% assoc problem, because we dont know the kit on the left
% new symbols introduce need for more rules 
% agda does not deem the calculus confluent
% % -> see how many critical pairs the sigma calculus even has! 

\section{Extensions}\label{sec:ext}
\subsection{Generic Syntax}\label{sec:ext-uni}
\subsection{Typing Kits}
% generic syntax allows to prove substitution lemmas only once. 
% sometimes inconvenient to use in agda
% generics and 
% typing kits
% room for more! e.g. linear types / resources etc or semantics e.g. confluence

\section{Case Studies}\label{sec:cas}
\subsection{System F}\label{sec:cas-sf}
\cite{girard1972}
\subsection{System F with Subtyping}\label{sec:cas-sfsub}

\subsection{Martin-Löf Type Theory}\label{sec:cas-mltt}

\section{Related Work}\label{sec:rel}
% the next works are essential building blocks for agdasubst and we build on both
% only really take the idea of autosubst

% \subsection{Autosubst 2}\label{sec:rel-aut}
% Autosubst 2 (coq)
% Nominal 2 (isabelle)
% Abstract Binding Tree Library (agda)

\section{Future Work}\label{sec:wrk}
% make it more complete?
% fix the assoc problem (see last sections)
% obviously improve user exp (i.e. derive code, documentation etc)

\subsection{Extensions to the Calculus}\label{sec:wrk-ext}
% variadic bindings
% lists / map
% .. the kathrins thesis
\subsection{Meta Theory}\label{sec:wrk-prp}
% meta theoretics
% termination
% confluence
% make it more complete?
\subsection{More Generality}\label{sec:wrk-prp}
% abstracting away the sorting to arbitrary, well behaved telescopes (by axiom)
% suitable for intrinsic typing

\section{Conclusions}\label{sec:con}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput
