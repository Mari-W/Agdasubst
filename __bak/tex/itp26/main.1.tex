
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
\usepackage{microtype}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\nolinenumbers
\usepackage{agda}

\input{unicodeletters}
\input{agdamacros}
\input{agda-generated}
\input{agda-generated-examples}

\definecolor{agdablue}{HTML}{0000CD}
\DisableLigatures[-]{encoding=T1}
\newcommand{\bsym}[1]{\textcolor{agdablue}{#1}}
\newcommand{\tdot}{\mkern2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern1mu}

\bibliographystyle{plainurl}
\title{How to REWRITE the Sigma Calculus in Agda}

\author{Marius Weidner}{University of Freiburg, Germany}{weidner@cs.uni-freiburg.de}{0009-0008-1152-165X}{}
\authorrunning{M. Weidner}
\Copyright{Marius Weidner}

\keywords{Explicit Substitutions, Sigma Calculus, Kits, Agda}

\ccsdesc[300]{Theory of computation~Equational logic and rewriting}

\begin{document}

\maketitle

\begin{abstract}

      Mechanizing the metatheory of programming languages in proof assistants
      inevitably involves recurring challenges related to variable binding and
      substitution. Each formalization requires proving standard substitution lemmas,
      such as those characterizing the behavior of composition and the interaction of
      substitutions with binders.

      Historically, substitution has been treated as an meta-level operation. To
      formalize this, explicit substitution calculi were introduced to bring
      substitutions down to a syntactic level. The $σ$-calculus provides syntactic
      reduction rules for terms and substitutions, ensuring confluence and strong
      normalization, thereby enabling equations between them to be solved by
      comparing their normal forms. By applying the reduction rules until a normal
      form is reached, we obtain an automatic procedure that eliminates the need for
      manually choosing the correct substitution lemmas.

      To apply this automatic procedure within Agda proofs, the $σ$-calculus rules
      can be registered as native reduction rules using Agda’s rewrite mechanism.
      Embedding the $σ$-calculus rules as reduction rules in Agda is challenging
      because it requires precise control over the reduction behavior of definitions,
      substitutions must be defined structurally in terms of renamings, and multiple
      variable sorts must be supported. We address the latter by adapting the
      $σ$-calculus to intrinsically scoped and multi-sorted syntax. We first treat
      renamings and substitutions separately, and then present a uniform treatment
      that allows results about both to be proven once, avoiding duplication. In both
      cases, thanks to the $σ$-calculus laws embedded as rewrite rules, equations are
      solved automatically by reduction, yielding definitional equalities in cases
      where substitution lemmas would otherwise need to be applied manually.
\end{abstract}

\section{Introduction}\label{sec:introduction}
Mechanizing the metatheory of programming languages in proof assistants
inevitably involves recurring challenges related to variable binding and
substitution. While such details are usually ignored in pen-and-paper proofs,
their mechanization in proof assistants requires precise definitions and a
significant amount of manual effort.

Historically, substitution has been treated as an meta-level operation. To
formalize substitutions, explicit substitution
calculi~\cite{10.1145/96709.96712} were introduced to bring substitutions down
to a syntactic level. These calculi define substitution behavior through a set
of reduction rules. With the $σ$-calculus, a terminating,
confluent~\cite{10.1145/226643.226675} and
complete~\cite{10.1145/2676724.2693163} rewrite system for $λ$-calculus terms
with substitution has been discovered. Repeatedly applying the rules
left-to-right yields a normal form, which can then be compared for equality.

The $σ$-calculus laws can be generalized to custom syntaxes without much
difficulty. Consequently, it is possible to use the $σ$-calculus laws in proof
assistants to automatically generate proofs for equations in which only
syntactic expressions and substitutions appear. The creators of
\textsc{Autosubst}~\cite{schafer2015autosubst} were one of the first to realize
this opportunity and provided a tactic that applies the $σ$-calculus rules to
solve goals in Rocq (formerly Coq). \textsc{Autosubst
      2}~\cite{10.1145/3293880.3294101} improves on its predecessor by addressing
three fundamental limitations.

First, \textsc{Autosubst} originally only supported unscoped syntax. In Rocq,
it is possible define intrinsically scoped syntax, represented as a set of
terms indexed by their free variables. Variables are restricted to de Bruijn
indices smaller than the index that represents the number of free variables.
Hence, every syntax tree built in this style is well-scoped by construction.
\textsc{Autosubst 2} supports intrinsically scoped syntaxes directly.

Second, combining several syntactic categories that have variables can cause a
combinatorial explosion of near-identical substitution definitions and lemmas.
To address the combinatorial explosion problem, \textsc{Autosubst 2} introduces
vector substitutions, which bundle substitutions over different variable sorts
into a single structure.

Third, in a proof assistant setting, it is necessary to distinguish between
renamings, substitutions mapping variables to variables, and general
substitutions, which map variables to terms, in order to obtain structurally
recursive definitions~\cite{10.1007/11617990_1}. The developers of
\textsc{Autosubst 2} recognized that maintaining the separation in full
generality is useful, as there are situations where reasoning about renamings
alone is required. To accommodate this, they extended \textsc{Autosubst} with
first-class renamings, effectively duplicating the substitution infrastructure
to handle renamings independently.

In Agda, there are several options for defining syntax: extrinsically scoped
and typed syntax, intrinsically scoped but extrinsically typed syntax, and
intrinsically scoped and typed syntax. We argue that the intrinsically scoped
but extrinsically typed approach represents the sweet spot between the two
extremes. In contrast to intrinsically typed syntax, scoped syntax allows all
syntactic categories to be combined into a single multi-sorted and scoped data
type, indexed not only by its free variables, but also by the syntactic
categories. Using a multi-sorted and scoped syntax avoids the combinatorial
explosion and the need for vector substitutions, as substitution can be defined
uniformly across all sorts.

As we will see, adapting the $σ$-calculus with first-class renamings to a
setting with multi-sorted, scoped syntax is relatively straightforward. In
particular, when we are careful with the reduction behavior of our definitions,
Agda’s rewrite mechanism~\cite{10.1145/3434341} allows the $σ$-calculus laws to
be registered as native reduction rules, yielding definitional equalities where
otherwise explicit application of substitution lemmas would be required.

Unfortunately, the need for renamings causes duplication. Lemmas, such as
substitution-preserves-typing, must be proven twice, once for renamings and
once for substitutions, with the latter relying on the former. To mitigate the
duplication issue, we build on the notion of Kits~\cite{ren-sub}, a structure
that captures the behavior common to both variables and terms, originally
developed in an intrinsically typed setting and later extended to multi-sorted,
scoped syntax~\cite{saffrich:LIPIcs.ITP.2024.32}. From Kits, we can define
Maps, a uniform structure for renamings and substitutions. Our work adapts the
$σ$-calculus laws to Kits and Maps over multi-sorted and scoped syntax,
treating renamings and substitutions uniformly and shows how to embed the laws
as reduction rules into Agda via rewrite rules. The resulting framework
constitutes the first version of the \textsc{Agdasubst} library.

\subsection*{Structure}
The paper is organized into several sections.\ \cref{sec:pre} introduces the
theoretical background and tools.\ \cref{sec:mis} presents an embedding of the
$σ$-calculus as native reduction rules into Agda for multi-sorted, scoped
syntax, treating renamings and substitutions separately.\ \cref{sec:its} shows
how the rewriting approach prevents the transfer hell problem for complex
intrinsically typed syntax. \cref{sec:ags} explains how to adapt the laws to a
setting where renamings and substitutions can be treated uniformly.\ Finally,
we outline directions for future work in \cref{sec:wrk}, discuss related work
in \cref{sec:rwk} and conclude the paper in \cref{sec:con}.

\subsection*{Contributions}
The main contributions of this work are
\begin{itemize}
      \item an embedding of the $σ$-calculus with first-class renamings into Agda, in a
            scoped and multi-sorted setting, using rewrite rules, exemplified with System~F
            (\cref{sec:mis});
      \item
      \item a novel version of the $σ$-calculus, formulating the $σ$-calculus laws in a
            Kit- and Map-based setting, where we effectively lift the distinction between
            variables and terms, as well as between renamings and substitutions, from the
            syntactic to the type level.
\end{itemize}

\noindent\textbf{The supplement contains the complete Agda code underlying this paper.}

\section{Preliminaries}\label{sec:pre}
This section introduces the concepts and tools required for the developments in
this work. We summarize
\begin{itemize}
      \item Agda and language features relevant to our work: instance arguments, rewrite
            rules and opaque blocks;
      \item The $σ$-calculus;
      \item Multi-sorted and scoped syntaxes in Agda.
\end{itemize}

\subsection{Agda and Relevant Language Features}\label{sec:pre-agd}
Agda is a dependently typed functional language and proof assistant based on
Martin-Löf type theory~\cite{MARTINLOF197573}, where proofs are verified via
type checking. Proofs are significantly simplified when terms are
\textit{definitionally equal}. When terms are not definitionally equal, users
must resort to manual equational reasoning using propositional equality, which
is a cumbersome process as Agda lacks automated proof-discharge tactics.
Maximizing definitional equalities thus directly reduces manual effort.

Beyond standard features like indexed inductive types and dependent pattern
matching~\cite{10.1145/3236770}, this work utilizes three specific mechanisms.

\subsection*{Instance Arguments}
Instance arguments (\AgdaSymbol{\{\{\dots\}\}}) are resolved via an automated,
type-directed search similar to Haskell type
classes~\cite{10.1145/75277.75283}. Agda infers these arguments from values
marked \AgdaKeyword{instance}. Consider a record for types with a default
value: \EDefault{} Opening this record with \EDefFields{} allows Agda to
resolve the \AgdaField{default} field automatically:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefInst{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefInstS{}
\end{minipage}

\noindent These instances enable implicit usage of default values for natural numbers and strings:

\noindent \begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefEx{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefExS{}
\end{minipage}

\noindent Agda infers the appropriate instance (\AgdaFunction{default–ℕ} or \AgdaFunction{default–String}) from the required type, ensuring these equations hold definitionally.

\subsection*{Rewrite Rules}
User-defined rewrite rules~\cite{10.1145/3434341, cockx:LIPIcs.TYPES.2019.2}
extend Agda’s computation by treating propositional equalities as reduction
rules. A function $\AgdaFunction{eq} : (x_1 : A_1) \ldots \to
      \AgdaFunction{f}\, p_1 \ldots p_n \, \AgdaFunction{≡} \, v$ can be registered
as a rewrite rule if:
\begin{enumerate}
      \item The head \AgdaFunction{f} is a postulate, defined function, or constructor with
            distinct variable type parameters.
      \item Every variable $x_i$ appears in a pattern position among $p_1, \ldots,
                  p_n$\footnote{The Agda documentation includes a precise definition for pattern
                  positions:
                  \href{https://agda.readthedocs.io/en/latest/language/rewriting.html}{Link to
                        Agda Documentation}}.
      \item The left side is neutral (it does not further reduce).
\end{enumerate}

\noindent For example, the right identity of addition satisfies these criteria: \ERewrite{} Once registered via \ERewriteIt{}, Agda treats \AgdaBound{n} \AgdaFunction{+} \AgdaNumber{0} as definitionally equal to \AgdaBound{n}: \ERewriteEx{} Users must ensure rules are terminating and confluent to retain logical consistency. While Agda provides conservative confluence checks via \texttt{--confluence-check}, termination is not verified.

\subsection*{Opaque Blocks}
Opaque definitions~\cite{gratzer2022controlling} treat code as non-unfolding
symbols. Definitions within an \AgdaKeyword{opaque} block are visible but
treated abstractly during type checking: \EOpaque{} Outside this block,
\AgdaFunction{forty-two} does not reduce to \AgdaNumber{42} during equality
checks: \EOpaqueExO{} However, the \AgdaKeyword{unfolding} keyword can be used
to manually expose the underlying definition when needed: \EOpaqueExT{}

\subsection{The Sigma Calculus}\label{sec:pre-sig}
\begin{figure}[t]
      \centering
      \footnotesize
      \setlength{\jot}{0pt} % Minimal vertical gap between math lines

      {\raggedright \textbf{\large Symbols} \par}
      \vspace{0.3em}

      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Variables} $x$
            \begin{align*}
                  \text{innermost variable} \quad & \textcolor{agdablue}{\mathsf{zero}}    \\
                  \text{outer variables} \quad    & \textcolor{agdablue}{\mathsf{suc}}\; x
            \end{align*}\\[-1ex]
            \textbf{Terms} $t$
            \begin{align*}
                  \text{variable usage} \quad           & \textcolor{agdablue}{\texttt{\`{}}}x \\
                  \text{abstraction} \quad              & \textcolor{agdablue}{λ.}\, t         \\
                  \text{application} \quad              & t_1 \ t_2                            \\
                  \text{substitution lookup} \quad      & x \textcolor{agdablue}{\;\&\;} σ     \\
                  \text{substitution application} \quad & t \tdot{} σ
            \end{align*}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Substitutions} $σ$
            \begin{align*}
                  \text{identity} \quad    & \textcolor{agdablue}{\mathsf{id}}                                                                           \\
                  \text{extension} \quad   & t \textcolor{agdablue}{\cdot} σ                                                                             \\
                  \text{composition} \quad & σ_1 \ \textcolor{agdablue}{;} \  σ_2                                                                        \\
                  \text{weakening} \quad   & \textcolor{agdablue}{\mathsf{wk}}                                                                           \\
                  \text{lifting} \quad     & \textcolor{agdablue}{\uparrow}σ ≐ ((\textcolor{agdablue}{\texttt{\`{}}}\textcolor{agdablue}{\mathsf{zero}})
                  \textcolor{agdablue}{\cdot} (σ \ \textcolor{agdablue}{;} \
                  \textcolor{agdablue}{\mathsf{wk}}))
            \end{align*}
      \end{minipage}

      \vspace{0.8em}
      {\raggedright \textbf{\large Reduction} \par}
      \vspace{0.3em}

      \begin{minipage}[t]{0.38\textwidth}
            \raggedright
            \textbf{Definitional Laws}
            \begin{alignat*}{2}
                  \mathsf{id}      \quad          & x \textcolor{agdablue}{\;\&\;} \textcolor{agdablue}{\mathsf{id}}                                     &  & = \textcolor{agdablue}{\texttt{\`{}}} x                                       \\
                  \mathsf{ext}_\mathsf{Z}  \quad  & \textcolor{agdablue}{\mathsf{zero}} \textcolor{agdablue}{\;\&\;} (t \textcolor{agdablue}{\cdot} σ)   &  & = t                                                                           \\
                  \mathsf{ext}_\mathsf{S}   \quad & \textcolor{agdablue}{\mathsf{suc}}\;x \textcolor{agdablue}{\;\&\;} (t \textcolor{agdablue}{\cdot} σ) &  & = x \textcolor{agdablue}{\;\&\;} σ                                            \\
                  \mathsf{comp}    \quad          & x \textcolor{agdablue}{\;\&\;} (σ_1 \ \textcolor{agdablue}{;} \  σ_2)                                &  & = (x \textcolor{agdablue}{\;\&\;} σ_1) \tdot σ_2                              \\
                  \mathsf{wk}      \quad          & x \textcolor{agdablue}{\;\&\;} \textcolor{agdablue}{\mathsf{wk}}                                     &  & = \textcolor{agdablue}{\texttt{\`{}}}(\textcolor{agdablue}{\mathsf{suc}} \ x)
            \end{alignat*}\\[-1ex]
            \textbf{Traversal Laws}
            \begin{alignat*}{2}
                  \mathsf{var} \quad & (\textcolor{agdablue}{\texttt{\`{}}} x)                                 & \tdot σ
                                     & = x \textcolor{agdablue}{\;\&\;} σ                                                 \\
                  \mathsf{lam} \quad & (\textcolor{agdablue}{λ.}\, t)                                          & \tdot  σ
                                     & = \textcolor{agdablue}{λ.} (t  \tdot (\textcolor{agdablue}{\uparrow}σ))            \\
                  \mathsf{app} \quad & (t_1 \ t_2)                                                             & \tdot σ
                                     & = (t_1  \tdot σ) \ (t_2  \tdot σ)
            \end{alignat*}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.58\textwidth} % Slightly wider to prevent line breaks in interaction laws
            \raggedright
            \textbf{Interaction Laws}
            \begin{alignat*}{2}
                  \mathsf{comp\text{-}id}_\mathsf{L} \quad & \textcolor{agdablue}{\mathsf{id}} \ \textcolor{agdablue}{;} \  σ                                                                                                    &  & = σ                                                                                                                                                                                                 \\
                  \mathsf{comp\text{-}id}_\mathsf{R} \quad & σ \ \textcolor{agdablue}{;} \  \textcolor{agdablue}{\mathsf{id}}                                                                                                    &  & = σ                                                                                                                                                                                                 \\
                  \mathsf{associativity}          \quad    & (σ_1 \ \textcolor{agdablue}{;} \  σ_2) \ \textcolor{agdablue}{;} \  σ_3                                                                                             &  & = σ_1 \ \textcolor{agdablue}{;} \  (σ_2 \ \textcolor{agdablue}{;} \  σ_3)                                                                                                                           \\
                  \mathsf{distributivity}           \quad  & (t \textcolor{agdablue}{\cdot} σ_1) \ \textcolor{agdablue}{;} \  σ_2                                                                                                &  & = (t \mkern2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} σ_2) \textcolor{agdablue}{\cdot} (σ_1 \ \textcolor{agdablue}{;} \  σ_2) \\
                  \mathsf{interact}       \quad            & \textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \  (t \textcolor{agdablue}{\cdot} σ)                                                                    &  & = σ                                                                                                                                                                                                 \\
                  \eta\mathsf{\text{-}id}        \quad     & (\textcolor{agdablue}{\texttt{\`{}}\mathsf{zero}}) \textcolor{agdablue}{\cdot} \textcolor{agdablue}{\mathsf{wk}}                                                    &  & = \textcolor{agdablue}{\mathsf{id}}                                                                                                                                                                 \\
                  \eta\mathsf{\text{-}law}       \quad     & (\textcolor{agdablue}{\mathsf{zero}} \textcolor{agdablue}{\;\&\;} σ) \textcolor{agdablue}{\cdot} (\textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \  σ) &  & = σ
            \end{alignat*}\\[-1ex]
            \textbf{Monad Laws}
            \begin{alignat*}{2}
                  \mathsf{right\text{-}id} \quad          & t  \tdot \mathsf{id}      &  & = t                                          \\
                  \mathsf{compositionality}         \quad & (t  \tdot σ_1)  \tdot σ_2 &  & = t  \tdot (σ_1 \textcolor{agdablue}{;} σ_2)
            \end{alignat*}
      \end{minipage}
      \caption{The three-sorted $σ$-calculus}\label{fig:pre-sig}
\end{figure}

The $\sigma$-calculus~\cite{10.1145/96709.96712} formalizes substitutions via
explicit reduction rules. We utilize a three-sorted variant of the
$σ_{SP}$-calculus~\cite{10.1145/2676724.2693163}, which provides a sound,
confluent~\cite{10.1145/226643.226675}, and
complete~\cite{10.1145/2676724.2693163} foundation. Our instantiation for the
$λ$-calculus is presented in \cref{fig:pre-sig}.

The syntax distinguishes between de~Bruijn variables, terms, and parallel
substitutions. Parallel substitutions map variables to terms and support
composition. Unlike standard accounts, we include explicit syntax for variable
usage, requiring distinct symbols for \bsym{\textsf{suc}} and
\bsym{\textsf{wk}} to shift variables or substitutions, respectively. Applying
\bsym{\textsf{wk}} to a term shifts all internal variables. We also define a
\textit{lifting} shorthand to push substitutions under binders; lifting
preserves the bound variable while weakening the substitution's terms to
maintain correct scoping.

Following~\cite{Stark:2020:Mechanising}, we categorize reduction rules into
four groups:
\begin{itemize}
      \item \textbf{Definitional}: Variable lookup in substitutions.
      \item \textbf{Interaction}: Equalities between substitution expressions.
      \item \textbf{Traversal}: Propagation through terms and under binders.
      \item \textbf{Monad}: Behavior of substitutions applied to terms.
\end{itemize}
We omit object-language reductions (e.g., $β$-reduction) to focus strictly on
substitution behavior. While renamings as first-class constructs will break
completeness~\cite{10.1145/3293880.3294101}, we prioritize a large space of
solvable equations. We maintain that our three-sorted variant remains
terminating and confluent.

\subsection{Multi-Sorted and Scoped Syntaxes in Agda}\label{sec:pre-syn}
\begin{figure}[t]
      \centering
      \footnotesize % Standard for dense Agda code blocks in LIPIcs
      \begin{minipage}[t]{0.40\linewidth}
            \raggedright
            % Optional: add a small negative \vspace if your code commands have built-in padding
            \EScoped{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.58\linewidth}
            \raggedright
            \EMultiSorted{}
      \end{minipage}
      \vspace{-1em} % Pull the caption closer to the code to save vertical space
      \caption{Classically Scoped Syntax vs. Multi-Sorted and Scoped Syntax}\label{fig:pre-svm}
\end{figure}

Unlike $λ$-calculus, many languages feature multiple syntactic categories.
System~F~\cite{girard1972, 10.1007/3-540-06859-7_148}, for instance, has
expressions, types, and kinds. To prevent scoping errors, we utilize
\textit{intrinsically scoped syntax}, where inductive syntax definitions are
indexed by free variables to ensure terms are correctly scoped by construction.
\Cref{fig:pre-svm} (left) shows a standard implementation: types are indexed by
type-variable counts, and expressions by both type and expression variable
counts. Variables use de Bruijn indices (\AgdaDatatype{Fin} \AgdaBound{n}).
% While the \AgdaDatatype{Kind} type could technically be omitted here since types are well-formed by construction. 
This separate-datatype approach requires defining many substitution
permutations (e.g., type-in-type, type-in-expr, expr-in-expr).

To avoid this combinatorial explosion, we define the uniform, multi-sorted
syntax in \cref{fig:pre-svm} (right). Terms form a single datatype
(\AgdaBound{S} \AgdaDatatype{⊢} \AgdaBound{s}) indexed by a target sort
\AgdaBound{s} and a \AgdaDatatype{Scope} \AgdaBound{S} (a list of variable
sorts). Variables are represented by membership proofs (\AgdaBound{S}
\AgdaDatatype{∋} \AgdaBound{s}) that act as de Bruijn indices. This unified
structure enables renamings and substitutions to operate uniformly across all
sorts.

% This differs from Pure Type Systems~\cite{berardi1988towards,
%       10.1007/3-540-52592-0_53, terlouw1989een}, where sorts are universe types (like
% Agda's \AgdaDatatype{Set}) within one category; in our multi-sorted syntax,
% sorts differentiate the syntactic categories themselves.

% \section{Closely Related Work}\label{sec:rel}
% Two works are particularly closely related to ours and warrant discussion
% upfront. Our work can essentially be seen as a combination of the two.
% 
% \subsection{Autosubst}
% Most of this work is inspired by the theoretical foundations developed in the
% context of the \textsc{Autosubst}~\cite{schafer2015autosubst} library. The
% original work makes use of the $σ$-calculus laws to automatically solve
% equations between unscoped, uni-sorted terms and substitutions in Rocq.
% Version~2~\cite{10.1145/3293880.3294101, Stark:2020:Mechanising} extends the
% original work with scoped syntax, first-class renamings and introduces new
% rules that connect renamings and substitutions. \textsc{Autosubst 2} uses
% vectors to bundle renamings and substitutions over multiple variable sorts and
% provides additional laws to support the interactions between vector
% substitutions. Because Rocq is tactic-oriented, the library provides tactics to
% apply the $σ$-calculus laws to proof obligations. It further supports code
% generation of syntax-dependent definitions and laws from a Higher-Order
% Abstract Syntax (HOAS) specification.
% 
% \subsection{Kits and Maps}
% The idea of Kits, structures that abstract over variables and terms and allow
% reasoning about both simultaneously, was originally proposed by \cite{ren-sub}
% in an intrinsically typed setting. \cite{saffrich:LIPIcs.ITP.2024.32} extended
% the Kit concept to scoped syntax, defining a uniform, multi-sorted, and scoped
% structure for renamings and substitutions called Maps. Their focus was on
% abstractions over typing relations and the semantics of the object language
% while maintaining a uniform treatment of renamings and substitutions. The
% framework includes a Typing Kit structure, which abstracts over typed renamings
% and substitutions with respect to a typing relation. The abstraction enables
% proving substitution-preserves-typing using a single uniform lemma over Maps,
% eliminating the need to first prove it separately for renamings.
% 
% \subsection{Contributions}
% We combine the approach of \textsc{Autosubst 2} with abstractions over
% multi-sorted, scoped syntax and substitutions.
% 
% Before introducing Kits and Maps, we first apply the $σ$-calculus laws to a
% scoped syntax setting with first-class renamings, following the approach of
% \textsc{Autosubst 2}, but implemented in Agda. Unlike \textsc{Autosubst 2}, we
% do not rely on vectors for multiple variable sorts, but instead use parallel,
% multi-sorted renamings and substitutions. We avoid tactics and embed the laws
% as rewrite rules to produce definitional equalities. For illustration purposes,
% we present a version using System~F in \cref{sec:mis}. This version is later
% subsumed by the full \textsc{Agdasubst} library in \cref{sec:ags}, which
% supports custom syntaxes.
% 
% In \textsc{Agdasubst}, we adopt the notions of Kits and Maps, and formulate
% $σ$-calculus laws in that setting. Informally, the adapted laws lift the
% distinction between variables and terms, as well as between renamings and
% substitutions, from the syntactic to the type level, allowing abstraction over
% both. For instance, the uniform Typing Kit-based substitution-preserves-typing
% lemma of \cite{saffrich:LIPIcs.ITP.2024.32} is substantially simplified, as our
% laws integrate seamlessly with this framework, eliminating the need for manual
% application of Map lemmas.

\section{The Sigma Calculus with Separate Renamings and Substitutions}\label{sec:mis}
This section presents a direct embedding of the $σ$-calculus rules with
first-class renamings, following the conceptual theory underlying
\textsc{Autosubst 2}, as native reduction rules in Agda using its rewrite
mechanism. We use the multi-sorted and scoped version of SystemF
from~\cref{fig:pre-svm} as an example for any custom syntax. The approach
described in this section directly translates to any multi-sorted and scoped
syntax definition.

\subsection{Scoped and Multi-Sorted Renamings and Substitutions}\label{sec:mis-sub}
\begin{figure}[t]
      \centering
      \footnotesize % Consistent with previous small figures
      \begin{minipage}[t]{0.25\linewidth}
            \raggedright
            \ERen{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.60\linewidth}
            \raggedright
            \ESub{}
      \end{minipage}
      \vspace{-0.5em} % Tightens the gap between the code and the caption
      \caption{Scoped and Multi-Sorted Renamings and Substitutions}\label{fig:mis-ras}
\end{figure}

We define renamings (\AgdaFunction{\_→ᴿ\_}) and substitutions
(\AgdaFunction{\_→ˢ\_}) uniformly over all variable sorts by indexing them over
scopes, as shown in \cref{fig:mis-ras}. A renaming from scope \AgdaBound{S₁} to
\AgdaBound{S₂} maps each variable of a given sort in \AgdaBound{S₁} to a
variable of the same sort in \AgdaBound{S₂}. Similarly, substitutions map
variables to terms of the corresponding sort.

We first define the renaming type and its primitive operations: identity
(\AgdaFunction{idᴿ}), weakening (\AgdaFunction{wkᴿ}) and extension
(\AgdaFunction{\_·ᴿ\_}). Substitution primitives mirror those for renamings,
but use the superscript S instead of R, except for weakening, which is strictly
a renaming. The order of definitions is chosen carefully to obtain a
structurally recursive definition. We use the structurally smaller weakening
renaming to define lifting of substitutions (\AgdaFunction{\_↑ˢ\_}).

To support all composition combinations of renamings and substitutions, we
provide four forward composition primitives: renaming composed with renaming
(\AgdaFunction{\_;ᴿᴿ\_}), renaming with substitution
(\AgdaFunction{\_;ᴿˢ\_})\footnote{The first two composition operators can
      technically be merged into a single definition. Both are simply forward
      function composition, but we choose to keep them separated.}, substitution with
renaming (\AgdaFunction{\_;ˢᴿ\_}), and substitution with substitution
(\AgdaFunction{\_;ˢˢ\_}).

The traversal functions (\AgdaFunction{\_⋯ᴿ\_} for renaming and
\AgdaFunction{\_⋯ˢ\_} for substitution) are defined by structural induction on
the syntax. Each clause applies a renaming or substitution to a object language
term, lifting the renaming or substitution, when going under a binder. The
clauses in both definitions correspond directly to the traversal laws of the
$σ$-calculus, and therefore, we want these functions to reduce during type
checking. When adapting this approach to arbitrary custom syntaxes, the
traversal functions are the only definitions that must be provided by the user.
All other definitions can be stated independently of the concrete syntax.

Renaming and substitution primitives are declared opaque, which blocks their
reduction. This abstraction is crucial for rewriting the $σ$-calculus laws,
where the primitives must act as uninterpreted symbols rather than as concrete
functions. Blocking reduction in this way allows rewrite rules to apply
predictably. The types for renamings and substitutions are declared opaque to
prevent their misuse as actual functions. Renamings and substitutions should
not behave as functions, because rewriting cannot be performed on a stuck
function applied to an argument. Instead, we introduce explicit syntax for
function application (\AgdaFunction{\_\&ᴿ\_} and \AgdaFunction{\_\&ˢ\_}) to
allow rewriting on a renaming or substitution applied to a variable.

\subsection{The Sigma Calculus with First-Class Renamings}\label{sec:mis-sig}
\begin{figure}[t]
      \centering

      \begin{minipage}[t]{0.38\linewidth}
            \raggedright{}
            \EDefLaws{}
            \ERewriteSys{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.58\linewidth}
            \raggedright{}
            \EInteractLaws{}
            \EMonadLaws{}
      \end{minipage}
      \caption{The Scoped and Multi-Sorted $σ$-calculus with First-Class Renamings}\label{fig:mis-sig}
\end{figure}

While we could opt to restrict the relevance of renamings to the structural
definition of substitutions and state the laws only for substitutions, it is
often useful to reason about renamings directly, for instance in the context
morphism lemma~\cite{goguen1997candidates}. We therefore, similar to Autosubst,
treat renamings as first-class constructs.\ \cref{fig:mis-sig} presents the
$σ$-calculus laws with first-class renamings. They all satisfy the requirements
from \cref{sec:pre-agd} and qualify as rewrite rules.

The \textbf{Definitional Laws} now involve primitives for both renamings and
substitutions. The \textbf{Interaction Laws} likewise cover all operators. Many
of these laws are similar in shape. For instance, we require eight
associativity laws. The \textbf{Traversal Laws} follow directly from the
definition of traversal given in the previous section.

Most of the laws can be proven independently of the concrete syntax. In
contrast, the \textbf{Monad Laws} must be shown by induction over the syntax
and vary for each object language definition. We highlight syntax-dependent
laws in red throughout this work.

\cite{10.1145/3293880.3294101} noticed that a further category emerges from the interaction between
renamings and substitutions. The \textbf{Coincidence Laws} govern the case where
substitutions are intertwined with renamings, but the renamings can be
separated from them, and applied to a term separately.
The coincidence and the coincidence-fold laws
enable us to recover renamings from their embedding as substitutions via the
identity substitution. Extracting arbitrary renamings from deeply nested substitutions would require a
dedicated solving strategy, which we leave for future work but consider
important for a more complete account.

In her PhD thesis, \cite{Stark:2020:Mechanising} proves the
\AgdaFunction{coincidence} law by induction over the syntax. The law is not
syntax-dependent when composition between renamings and substitutions is
included in the theory and the monad laws are available: \ECoincidenceProof{}
The remaining coincidence laws follow analogously.

The exact influence of coincidence laws on the metatheory of the rule set as a
whole still needs to be examined in detail but it is believed their addition
preserves termination and confluence~\cite{10.1145/3293880.3294101}. Agda
cannot determine that the set of rewrite rules is confluent using its built-in
checks. To make the rules amenable to such analysis, a critical pair analysis
in the spirit of the Knuth-Bendix completion algorithm~\cite{Knuth1983} would
be required to split the rules into components that Agda can recognize as
collectively confluent.

To prove the $σ$-calculus laws presented in \cref{fig:mis-sig}, we need to
unfold the definitions of the renamings and substitutions primitives. Laws
colored blue can be proven syntax-independently, while laws colored in red need
to be proven by structural induction over the syntax. Our implementation, found
in the supplement, makes use of function extensionality, which is safe to
postulate in Agda. It is known that with a little more effort, this assumption
is not necessary.

\subsection{Discussion}\label{sec:mis-dis}
The laws presented in \cref{sec:mis-sig} are an extension of the classic
$σ$-calculus rules to a setting with renamings. They fulfill the requirements
to be registered as rewrite rules without further modification. This is a
consequence of marking the relevant symbols opaque. Inside the proofs of the
laws themselves, the definitions can still unfold when needed, while externally
they behave as uninterpreted symbols and are reduced only by the $σ$-calculus
laws.

The main drawback of the approach with separated renamings and substitutions is
the unavoidable duplication of similar definitions and proofs. Associativity
laws pose little difficulty as they can be stated independently of the syntax,
but the definition of traversal and monad laws must be provided explicitly.
These include two traversal definitions, two right-identity laws, and four
compositionality laws, all similar in shape. Even if syntax-dependent
definitions and laws are derived automatically, every subsequent result about
substitutions would still need to be proven twice, once for renamings and once
for general substitutions.

\section{The Agdasubst Library}\label{sec:ags}
This section introduces the \textsc{Agdasubst} library. It builds on the ideas
from \cref{sec:mis} but removes the strict separation between variables and
terms by the introduction of a construct that can represent either, which we
call Kits. Using Kits, renamings and substitutions can be defined uniformly
through a single notion, called Maps. With Kits and Maps in place, definitions
and proofs from \cref{sec:mis} that were previously similar in shape can now be
unified.

We first recall the relevant definitions from the work of
\cite{saffrich:LIPIcs.ITP.2024.32} in \cref{sec:ags-kit,sec:ags-com}. Most
implementation details of Kits and Maps are omitted, except for those directly
relevant to the $σ$-calculus laws. For a complete account of Kits, Maps, and
their extensions, we refer the reader to \cite{saffrich:LIPIcs.ITP.2024.32}. We
then show how the $σ$-calculus laws can be formulated in the setting of Kits
and Maps and discuss the challenges in doing so. In particular, it is
challenging to formulate the laws, such that they satisfy the requirements to
be registered as rewrite rules.

The library, and the following chapter, abstracts over a set of sorts
\ASortParam, a scoped and multi-sorted syntax \AScopedT, that must have a
variable constructor \AVarCstr.

\subsection{Kits}\label{sec:ags-kit}
A Kit is a structure that abstracts over terms and variables. The intended
usage is to instantiate the Kit structure exactly twice, first for variables
and then for terms. Definitions can be written uniformly, parameterized over a
Kit, and are consequently applicable to both cases.

\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AKit{}
      \AOpenKit{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AModeDef{}
      \AImage{}
\end{minipage}

\noindent To distinguish the two instances of Kits on the type level, Kits are indexed over
a boolean-like structure \AgdaDatatype{Mode}. The \AgdaFunction{image} function computes,
given a fixed \AgdaDatatype{Mode}, whether the Kit corresponds to a variable or
term. The Kit record has multiple fields.
\begin{itemize}
      \item \AgdaField{K-id/‘} converts a variable into a variable or term \AgdaBound{S} \AgdaBound{∋/⊢ᴷ} \AgdaBound{s}.
            For the Variable Kit, \AgdaBound{\_∋/⊢ᴷ\_} is instantiated to \AgdaDatatype{\_∋\_}, so the operation needs to act as the identity.
            For the Term Kit, it is instantiated to \AgdaField{\_⊢\_}, so the operation corresponds to the variable constructor.
      \item \AgdaField{K-‘/id} converts an element of type \AgdaBound{S} \AgdaBound{∋/⊢ᴷ} \AgdaBound{s} into a term of type \AgdaBound{S} \AgdaField{⊢} \AgdaBound{s}, and works analogous to \AgdaField{K-id/‘}.
      \item \AgdaField{K-wk} shifts the de Bruijn indices in a variable or term.
            The newly introduced, unused variable \AgdaInductiveConstructor{zero} can assume any sort \AgdaBound{s′}.
            For variables, \AgdaField{K-wk} corresponds to the successor constructor \AgdaInductiveConstructor{suc}.
            For terms, \AgdaField{K-wk} needs to apply a weakening renaming to the term.
\end{itemize}

\noindent The \AgdaDatatype{Kit} record further includes fields for axioms that constrain
its instantiation. We will not cover these axioms, because for both variables
and reasonable syntaxes, all of them hold almost by definition.

Because rewrite rules cannot mention record fields directly, we provide for
each field, except \AgdaField{K-wk}, a corresponding version without the
\AgdaBound{K}-prefix. These are declared as opaque functions, so they can be
used as symbols in rewrite rules, while still be selectively unfolded to the
actual fields when needed. Going forwards, we assume all opaque definitions
unfolding any time throughout this section. It is only outside the library,
when we have the $σ$-calculus laws in place, when we want definitions to act as
uninterpreted symbols.

We can now define the usual operations for renamings and substitutions. The
definitions are included directly inside the \AgdaDatatype{Kit} record, so they
are implicitly parameterized over a Kit \AgdaBound{K} with Mode \AgdaBound{M}
and can be uniformly stated. All the primitives are marked
\AgdaKeyword{opaque}.

\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AMapA{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AMapB{}
\end{minipage}

\noindent The type for Maps \AgdaBound{S₁} \AgdaFunction{→ᴷ} \AgdaBound{S₂} unifies
renamings \AgdaBound{S₁} \AgdaFunction{→ᴿ} \AgdaBound{S₂} and substitutions
\AgdaBound{S₁} \AgdaFunction{→ˢ} \AgdaBound{S₂}. For \AgdaBound{M} specialized
to \AgdaInductiveConstructor{Vᴹ} the \AgdaFunction{image} function computes to
the type of variables and as a result the Map acts as renaming. Similarly, in
the case that \AgdaBound{M} is equal to \AgdaInductiveConstructor{Tᴹ}, the Map
corresponds to a substitution. The identity Map, as well as lookup and
extension operations behave analogously in both the renaming and substitution
cases.

Term traversal is not yet available, because it requires Kits to be defined
first, as traversal is formulated for Maps directly, parameterized by a Kit. At
the same time, traversal is needed to define composition for Maps, because
composing with a substitution on the right relies on traversal, and composition
is in turn required to define lifting: \ALifting{}To break this dependency
cycle, we introduce a generalized weakening operator \AgdaFunction{\_;wk},
which can later be rewritten as an actual composition with the weakening
primitive \AgdaFunction{wk}, which we also define in terms of the generalized
version.

Similarly, once term traversal is available, the \AgdaFunction{id/‘} and
\AgdaFunction{‘/id} operators can be expressed entirely in terms of the
primitive operations. We also provide syntax to refer to Kits explicitly inside
square brackets:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AKitExplicit{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AExpId{}
\end{minipage}

\noindent To define the Term Kit instance, we need to know how a Map is
applied to a term. The user has to provide the Kit-based traversal function and
a proof that applying the identity Map leaves a term unchanged by structural induction over their syntax:
\ATraversal{}Equipped with the traversal function we can define the two
intended instances for Kits:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AInstanceRen{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AInstanceSub{}
\end{minipage}

\noindent In the \AgdaField{K-wk} field for the Term Kit, we use the \AgdaFunction{wk} primitive from the
Variable Kit. The Variable Kit is automatically resolved using
instance search.

\subsection{Composition}\label{sec:ags-com}
We aim to abstract over the four composition options for renamings and
substitutions, enabling unified composition lemmas, such as one associativity
law, instead of separate laws for each of the eight valid combinations. To this
end, we define the \AgdaDatatype{ComposeKit} record, parameterized over three
Kits. Inside the record, we can later define a single, more general composition
of a \AgdaBound{K₁}-Map with a \AgdaBound{K₂}-Map, yielding a
\AgdaBound{K₁⊔K₂}-Map. \AComposeKit{}The operation \AgdaField{C-\_\&/⋯\_}
unifies lookup and traversal. It takes a variable or term \AgdaBound{x/t}
(according to \AgdaBound{K₁}) and a renaming or substitution \AgdaBound{ϕ}
(according to \AgdaBound{K₂}), and applies \AgdaBound{ϕ} to \AgdaBound{x/t},
yielding a variable or term (according to \AgdaBound{K₁⊔K₂}). From unified
lookup/traversal, for which we also provide an opaque function version without
the $C$-prefix, we derive Map composition: \ACompDef{}The Map composition
operator, such as the unified lookup/traversal operator, is implicitly
parameterized over a Compose Kit. It takes an renaming or substitution
\AgdaBound{ϕ₁} (according to \AgdaBound{K₁}) and a renaming or substitution
\AgdaBound{ϕ₂} (according to \AgdaBound{K₂}) as arguments, and composes it to a
renaming or substitution (according to \AgdaBound{K₁⊔K₂}). When \AgdaBound{x}
\AgdaFunction{\&} \AgdaBound{ϕ₁} yields a variable, we need to look up the
resulting variable in \AgdaBound{ϕ₂}, or if we have a term, we traverse the
term with \AgdaBound{ϕ₂}. We also define versions of both the unified
lookup/traversal operator and the composition operator where the Compose Kit is
given explicitly: \ACompExp\ and \ALoAExp.

As with Kits, we now require a user-provided proof about traversal. We need the
user to show that the chosen syntax and traversal function satisfy
compositionality. This proof can only be established by induction on the
syntax: \ACompositionality{}Finally, to cover the four possible instances of
Compose Kits, we provide two generic instances that suffice:

\noindent\begin{minipage}{0.43\linewidth}
      \raggedright{}
      \AInstanceCRen{}
\end{minipage}
\begin{minipage}{0.53\linewidth}
      \raggedright{}
      \AInstanceCSub{}
\end{minipage}

\noindent The \AgdaFunction{Cᴿ} instance corresponds to the Compose Kit for composition
between a renaming and another \AgdaBound{K}-Map. Similarly, \AgdaFunction{Cˢ} covers the
composition between a substitution and another \AgdaBound{K}-Map, and assumes that
composition of a \AgdaBound{K}-Maps with renamings is already available.

The third parameter \AgdaBound{K₁⊔K₂} of a Compose Kit can be understood as a
functional dependency, uniquely determined by the choice of \AgdaBound{K₁} and
\AgdaBound{K₂}. It is instantiated to \AgdaFunction{V} if and only if both
\AgdaBound{K₁} and \AgdaBound{K₂} are \AgdaFunction{V}, otherwise it is
\AgdaFunction{T}. In other words, only renamings compose to a renaming, while
every other case yields a substitution. We can put this more algebraically: if
$\varphi_1$ is a $K_1$-Map and $\varphi_2$ is a $K_2$-Map, then the result is a
$(K_1 \sqcup K_2)$-Map, where $\sqcup$ refers to the join-semilattice on $\{V,
      T\}$ generated by $V < T$. A natural question is why we do not simply compute
\AgdaBound{K₁⊔K₂}. Computing \AgdaBound{K₁⊔K₂} is in fact possible and even
necessary to define the $σ$-calculus rules so that they still adhere to
restrictions on the shape of rewrite rules.

\subsection{Structural Kit Order}\label{sec:ags-sko}
We define a least upper bound operation on Modes that mirrors the behavior of
composing two Maps, indexed by Kits of these Modes, inside an opaque
block:\AModeLub{}By case analysis, all the join-semilattice laws are easily
verified: \AModeLubLaws{}All laws can be embedded as rewrite rules in Agda,
except for \AgdaFunction{⨆-comm}, which is evidently non-terminating. The
lattice laws for Modes must be registered as rewrite rules to define the
semilattice laws for Kits. Without the rewrite rules, explicit type coercions
would be necessary, because Modes appear in the type of Kits. We then define
the least upper bound for Kits: \AKitLub{}and prove the join-semilattice laws:
\AKitLubLaws{}The \AgdaFunction{⊔-comm} law requires the transfer lemma in its
type, because \AgdaFunction{⨆-comm} for Modes could not be rewritten earlier.
All other laws can be registered as rewrite rules to produce definitional
equalities whenever applicable, enabling effective use of the least upper bound
operator without the need to apply additional lemmas. The Kit least upper bound
laws follow by case distinction on their Modes, but examining a proof in detail
reveals a subtle issue. As an example, consider the proof for the
\AgdaFunction{⊔-idem} law. The remaining laws follow analogously.
\AKitLubExcerpt{}If we split on the Mode \AgdaBound{M} of the Kit
\AgdaBound{K}, we must prove in both cases that \AgdaBound{K} is either
\AgdaFunction{V} or \AgdaFunction{T}, according to the definition of
\AgdaFunction{\_⊔\_} and the chosen Mode. We run into the problem, that
\AgdaBound{K} is inferred by instance resolution, and Agda cannot deduce that
there is only one possible choice in both cases, \AgdaFunction{V} for
\AgdaInductiveConstructor{Vᴹ} and \AgdaFunction{T} for
\AgdaInductiveConstructor{Tᴹ}. Nor can the uniqueness of instances be assumed
in general, as external code might declare additional instances.

Agda does not provide a notion of closed type classes, where instance
declarations outside a module can be prohibited. In Haskell, such behavior can
be encoded using closed type families~\cite{10.1145/2578855.2535856}. In Agda,
closed type classes can be simulated, by requiring a field \ALockField{} of
type \ALock\ in the construction of a record instance. Because
\AgdaDatatype{Lock} is private, it can only be constructed from within the
library. Any attempt to declare an instance outside the library would fail,
because the required field \AgdaField{K-lock} of type \AgdaDatatype{Lock}
cannot be filled.

We can now postulate the uniqueness of Kits after manually verifying that only
two instances exist and that we rely solely on Kits provided by instance
resolution, never creating them locally: \AUniqueKits{}The postulates are
declared private and cannot cause inconsistencies for users outside the
library. There also exists a version \AgdaFunction{unique–K} that computes
whether a given Kit is \AgdaFunction{V} or \AgdaFunction{T}, based on its Mode.

\subsection{Computing Compose Kits}\label{sec:ags-cck}
Our original goal was to compute the third parameter of a Compose Kit. To
motivate this and, more generally, the computation of Compose Kits from Kits,
we consider a first attempt of the definition for the associativity law of the
$σ$-calculus, which in our Kit-based setting corresponds to the associativity
of Map composition:\AAssocTryO{}Here \AgdaBound{C₁} to \AgdaBound{C₄} denote
the four Compose Kits that are required for the compositions. For clarity we
apply them to the composition operators explicitly, although instance
resolution would perform this step automatically. This yields the most general
formulation of the associativity law for Maps, where arbitrary Kits are
admitted as long as both sides reduce to a \AgdaBound{K₅}-Map. Our current
formulation of the law, however, is not a valid rewrite rule. Both
\AgdaBound{C₃} and \AgdaBound{C₄}, required for the right side, appear only
there, violating the condition that all arguments of a rewrite rule must occur
on the left. Moreover, the law requires the instance argument \AgdaBound{K₆},
used as the result of composing the \AgdaBound{K₂}-Map with that of
\AgdaBound{K₄}, which is only used on the right. Because \AgdaBound{K₆} can be
computed via the least upper bound operation we defined before, the main
difficulty is to compute \AgdaBound{C₃} and \AgdaBound{C₄}.

We can try to define a function \ACompCKitSafe{}, that evaluates to
\AgdaFunction{Cᴿ}, if \AgdaBound{K₁} has Mode \AgdaInductiveConstructor{Vᴹ} and
to \AgdaFunction{Cˢ}, if \AgdaBound{K₁} has Mode \AgdaInductiveConstructor{Tᴹ}.
The function can be readily defined, but its correctness relies not only on the
uniqueness of Kit instances, but also on the uniqueness of Compose Kit
instances:\AUniqueCKits{}As before we require a value of \AgdaDatatype{Lock} in
the creation of Compose Kits. By manual inspection we confirm that
\AgdaFunction{Cᴿ} and \AgdaFunction{Cˢ} are the only instances and that none
are created locally.

Yet the function \AgdaFunction{\_;ᴷ\_} is insufficiently general. Computing
\AgdaBound{C₄} from the associativity law yields $C_4 = K_2 \;
      \AgdaFunction{;ᴷ} \; K_4 = \AgdaDatatype{ComposeKit}\; K_2\; K_4\; (K_2$
\AgdaFunction{⊔} $K_4)$. Consequently, \AgdaBound{C₃} evaluates to $C_3 = K_1
      \; \AgdaFunction{;ᴷ} \; (K_2 \; \AgdaFunction{⊔} \; K_4) =
      \AgdaDatatype{ComposeKit}\; K_1\; (K_2$ \AgdaFunction{⊔} $ K_4)\; (K_1$
\AgdaFunction{⊔} $ (K_2 $ \AgdaFunction{⊔} $ K_4))$. The final Map on the right
of the equation computes to a $(K_1 $ \AgdaFunction{⊔} $ (K_2$ \AgdaFunction{⊔}
$ K_4))$-Map, whereas the Map on the left is a $K_5$-Map. Adjusting the
\AgdaBound{K₅} parameter in \AgdaBound{C₂} to $(K_1 $ \AgdaFunction{⊔} $ (K_2$
\AgdaFunction{⊔} $ K_4))$ is not possible, as Compose Kits whose third
parameter involves least upper bounds cannot be inferred by instance
resolution. Defining instances that would permit the inference of Compose Kits
with arbitrary least upper bound computation in the third parameter is hard and
would increase instance resolution runtime dramatically. Additionally, Agda
generally refused to infer such instances during higher-order pattern
unification, performed when checking if a rewrite rule applies. A second
approach, defining the least upper bound operation syntactically as a
constructor in the \AgdaDatatype{Mode} type, fails because the lattice laws can
no longer be stated and rewritten. As a solution, we require an even more
general, but also unsafe, function: \ACKitUnsafe{}Because it is declared
non-covering, evaluation may get stuck, yielding a value for a Compose Kit that
should not exist. For this reason, every use of the function requires manual
verification. Computed Compose Kits are reduced to the actual instances, when
applicable, using the rewrite rules \ACKitRenRed{} for \AgdaFunction{Cᴿ} and
\ACKitSubRed{} for \AgdaFunction{Cˢ}. The unsafe function is only available
from within the library, but we can define the safe version from before as a
special case of the unsafe function: \ACompCKitSafeDef{}. We can now state a
version of the associativity law eligible for rewriting: \AAssocTryT{}With the
unsafe operator, we can connect $K_1$ \AgdaFunction{⊔} $ (K_2 $
\AgdaFunction{⊔} $K_4)$ with \AgdaBound{K₅} in the outer Compose Kit on the
right side of the equation. It remains to check that whenever the incoming
Compose Kits $C_1$ and $C_2$ are valid, the outgoing ones, computed using our
unsafe function, are as well. By exhaustively checking all eight valid
combinations of values for $C_1$ and $C_2$, we confirm that in each case the
outgoing Compose Kits are valid. Inside the associativity proof, the remaining
cases must be refuted under the assumption of valid and unique incoming Compose
Kits, and the non-existence of invalid Compose Kits: \AUnqiueCKitsImp{}As
before, each use of these postulates requires manual verification to avoid
inconsistencies, but cannot leak to the user, because they are declared
\AgdaKeyword{private}.

All other $σ$-calculus laws, generalized to Maps, follow the same structure as
the \AgdaFunction{associativity} law. On the left side of the equations we rely
on Kits and Compose Kits inferred via instance resolution, while on the right
we compute the resulting Kits and Compose Kits using the least upper bound
operation together with the unsafe \AgdaFunction{\_,\_,\_} operator, where we
manually verify that its use is sound. The proofs are carried out by case
analysis on the Modes of the Kit instance arguments and rely on the uniqueness
of (Compose-) Kits as well as the refutation of invalid ComposeKit Kits. Apart
from these aspects, their structure closely resembles the familiar separated
proofs for renamings and substitutions.

\subsection{The Scoped and Multi-Sorted $σ$-Calculus with Kits and Maps}\label{sec:ags-rls}
\begin{figure}[tp]
      \centering
      \small
      {\raggedright{} \textbf{\Large Symbols} \par}
      \vspace{1.5em}

      \begin{minipage}[t]{0.48\textwidth}
            \small{}
            \raggedright{}
            \textbf{Sorts} $s$ \\
            \ESortTy{}\\
            \vspace{0.5em}
            \emph{..\ object language sorts\..}\\
            \vspace{0.5em}
            \textbf{Scopes} $S$ \\
            \EScopeDefTy{}\\
            \vspace{0.5em}
            \EScopeDef{}\\
            \vspace{0.5em}
            \textbf{Variables} $x$ \\
            \EVarsTy{}\\
            \vspace{0.5em}
            \EVars{}\\
            \vspace{0.5em}
            \textbf{Terms} $t$ \\
            \ETmC{}\\
            \vspace{0.5em}
            \EVarC{}\\
            \emph{..\ object language\..}\\
            \vspace{1.0em}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \small{}
            \raggedright{}
            \textbf{Kits} \AgdaBound{K} \\
            \EKitDefTy{}\\
            \vspace{0.5em}
            \EKitDef{}\\
            \vspace{0.5em}
            \textbf{Maps} $ϕ$\\
            \EPrimsTy{}\\
            \vspace{0.5em}
            \EPrims{}\\
            \vspace{0.5em}
            \textbf{Variables or Terms} $x/t$\\
            \EVarTrmTy{}\\
            \vspace{0.5em}
            \EVarTrmApp{}
      \end{minipage}

      {\raggedright{} \vspace{2.0em} \textbf{\Large Reduction} \par}
      \vspace{1.5em}
      \begin{minipage}[t]{0.40\textwidth}
            \small{}
            \raggedright{}
            \textbf{Kit Laws}\\
            \ETypeLevel{}\\
            \vspace{0.5em}
            \textbf{Definitional Laws}\\
            \vspace{0.5em}
            \EDefLawTy{}\\
            \vspace{0.5em}
            \EDefLaw{}\\
            \vspace{0.5em}
            \textbf{Specialization Laws}
            \ESpecialDefLaws{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.54\textwidth}
            \small{}
            \raggedright{}
            \textbf{Interaction Laws}\\
            \EInteraction{}\\
            \vspace{0.5em}
            \textbf{Coincidence Laws}\\
            \ECoincidence{}
            \vspace{0.5em}
            \textbf{Traversal Laws}\\
            \ETravL{}\\
            \emph{..\ object language traversal\..}\\
            \vspace{0.5em}
            \textbf{Monad Laws}\\
            \EMonad{}\\
      \end{minipage}
      \caption{The Scoped and Multi-Sorted $σ$-Calculus with Kits and Maps}\label{fig:ags-fin}
\end{figure}

\cref{fig:ags-fin} states the $σ$-calculus laws in the Kit-setting.
The figure lists the symbols and laws as they are used in \textsc{Agdasubst}.
For readability we omit the Kit and ComposeKit instance arguments. In the
library, Kits and ComposeKits carry data, and Kits must be disambiguated on the
type level by their Modes. Here we treat Kits as markers, which lets us elide
the Mode lattice laws. Similarly, ComposeKits serve as markers for admissible
compositions and are written explicitly for each operator in square brackets.

The symbols are grouped into several categories. Sorts and scopes provide
intrinsic scoping at the type level. Variables are supplied by the library,
while terms are user-defined, subject only to the requirement of a variable
constructor of the appropriate form. We define the type of Kits together with
the Variable Kit, the Term Kit, and the least upper bound operation. We then
define the type of Maps and the four Map primitives, parameterized by Kits. The
operator \AgdaFunction{wk} is specialized directly to a renaming to avoid
duplication, as it can always be embedded as a substitution by composition with
the identity substitution. When the Kit in the type index of Maps is known to
be \AgdaFunction{V} or \AgdaFunction{T}, we use the variables $ρ$ and $σ$
respectively. From Kits we also obtain the combined type of variables and
terms, together with the unified lookup/traversal operator. While there are
distinct type definitions for variables, terms, and variables-or-terms, there
is only a single type definition for Maps, specialized through the Kit index.
There is no technical obstacle to unifying variables and terms in the same way.
However, unlike renamings, substitutions, and Maps, terms are user-defined,
whereas variables are provided by the library and therefore justify a distinct
type definition.

We already discussed the \textbf{Kit Laws} in \cref{sec:ags-sko}, so we now
turn to the remaining ones. We begin with the type-level reduction laws
\AgdaFunction{imgⱽ} and \AgdaFunction{imgᵀ} inside the \textbf{Definitional
      Laws}, which rewrite the type of variables-or-terms to either the type of
variables or the type of terms when the Kit index is known to be
\AgdaFunction{V} or \AgdaFunction{T}, respectively.

Next comes the definition of lookup on the identity substitution
\AgdaFunction{idˢ}. It is given in terms of the unified lookup/traversal
operator. The laws \AgdaFunction{wk}, \AgdaFunction{ext₀}, and
\AgdaFunction{extₛ} are the direct generalizations of their familiar
counterparts for renaming and substitution.

Lookup on the identity renaming does not require a separate law, as it is
already subsumed by the generalized \AgdaField{right-id} from the \textbf{Monad
      Laws}. The \AgdaField{right-id} law accounts for both a term traversed by an
identity substitution and a variable looked up in the identity renaming. This
coincidence suggests a deeper connection between definitional laws and monad
laws when there is only a single unified lookup/traversal operator. We can
confirm our suspicion when examining the \AgdaFunction{comp} and
\AgdaField{compositionality} law. There exists a fundamental symmetry between
the definition of composition, given via the unified lookup/traversal operator,
and the compositionality law in full generality:

\noindent\begin{minipage}{0.45\linewidth}
      \raggedright{}
      \ECompGeneral{}
\end{minipage}
\begin{minipage}{0.55\linewidth}
      \raggedright{}
      \ECompoGeneral{}
\end{minipage}

\noindent Viewed side by side, these laws exhibit an inherent symmetry. If both were admitted into the
rewrite system, they would trigger infinite loops. This symmetry is no accident, intuitively, one law pushes variables into maps, while the other pushes maps into other maps, away from terms. The unification of lookup and traversal into a single operator makes this symmetry explicit.
To avoid non-termination, we adopt the following heuristic:
\begin{itemize}
      \item In variable position ($K_5 = $ \AgdaFunction{V}) use the definition of
            composition. In this case all other indices $K_1,\dots,K_4$ are forced to
            \AgdaFunction{V}, and $x/t$ must be a variable. This yields exactly the
            specialized \AgdaFunction{comp} law shown in the figure.
      \item In term position ($K_5 = $ \AgdaFunction{T}) use \AgdaField{compositionality}.
            Here no restrictions on the other indices arise, so the law is preserved in
            most of its generality and appears under the Monad Laws.
\end{itemize}

\noindent If neither condition applies ($K_5$ not fixed), the user must explicitly choose from the fully
general laws which law to apply, either by equational reasoning or by using
\AgdaKeyword{rewrite}.

With the position heuristic the \AgdaFunction{comp} law is rather restricted.
We now miss cases where we would make progress by applying the
\AgdaFunction{comp} law, when $\varphi_1$ and $\varphi_2$ are not both
renamings. Hence, we consider all situations where progress would be made
directly after applying \AgdaFunction{comp}, by specializing on $\varphi_1$.
The laws, where $\varphi_1$ or $\varphi_2$ is fixed to a primitive and progress
can be inlined, appear under the name \textbf{Specialization Laws}.

The \textbf{Interaction Laws} are the direct generalizations of their original
$σ$-calculus counterparts to Kits. Next come the \textbf{Traversal Laws}.
Because we are independent of the object syntax except for the required
variable constructor, we only show the law specific to the traversal of a
variable. When a variable constructor is applied to a map, the variable it
holds is mapped accordingly. To turn the result back into a term, as it may
otherwise be either a variable or a term, depending on the map, we subsequently
apply the identity substitution.

To illustrate another case for traversal, consider an object language that
supports $λ$-abstractions. The corresponding user-supplied traversal function,
needed to construct the Term Kit, would then include a clause \FSLambdaExT.
However, the clause does not directly corresponds to a traversal law. It must
first be lifted from the traversal operator to the unified lookup/traversal
operator: \FSLambdaExL. The equation can be proven by reflexivity, when we
unfold the definition of the unified lookup/traversal operator. It can then be
added to our equational theory.

Finally, the \textbf{Coincidence Laws} generalize from renamings to Maps and
enable Maps to be pulled out of substitutions when possible. As discussed
earlier, these laws do not exhaustively describe every possible way in which
Maps can be extracted from substitutions.

\subsection{Discussion}
The Kit-based version of the $σ$-calculus laws required unsafe computation and
a careful formulation of the laws so that they remain valid rewrite rules while
still delegating Kit and ComposeKit inference to the instance resolution
algorithm. We believe the Kit-based variant, derived from the $σ$-calculus used
in \textsc{Autosubst}, remains terminating and confluent, even though Agda’s
built-in checker cannot verify confluence. From the Kit-based laws, we can
readily derive the specialized laws from \cref{sec:mis} and rewrite them if we
wish to reason about renamings and substitutions separately.

The key difficulty in adapting the laws to the Kit-setting emerges from the
symmetry between the general definition of composition \AgdaFunction{comp} and
the \AgdaField{compositionality} law. Our solution is a heuristic that resolves
this conflict by restricting the laws to cases where the context is known to be
variable or term position. When the position is unknown, the flow of the laws
becomes ambiguous, and the user must resort to manual application.

Compared to the laws from \cref{sec:mis}, the Kit-based formulation has the
advantage that properties can be established directly for Maps, without
requiring separate but structurally identical proofs for renamings and
substitutions.

\section{Case Studies}\label{sec:ext}
We present two examples illustrating the usage of the \textsc{Agdasubst}
library. The first concerns proofs of subject reduction for System F with
subtyping. We begin by a presentation of the proof using the laws from
\cref{sec:mis-sig} and then revisit it using the Kit-based laws from
\cref{sec:ags-rls}. We then extend the latter version with subtyping. The
second example, based on work by \cite{allais2021typescopesafeuniverse},
provides an instantiation for a generic universe of scoped syntax.
\subsection{System F}\label{sec:ext-syf}

\begin{figure}[!t]
      \centering
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ETyping{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESemantics{}
      \end{minipage}
      \caption{Typing and semantics for System F}\label{fig:ext-tas}
\end{figure}

Recall the multi-sorted and scoped syntax from the right side of
\cref{fig:pre-svm}. We outline the proof of subject reduction, first using the
laws from \cref{sec:mis-sig} and then using the \textsc{Agdasubst} library. The
type system and semantics are the same in both cases and are presented once in
\cref{fig:ext-tas}. In both settings, we use the functions \EWk{} and \ESubst{}
to increment all variable indices within a term and to substitute a term for
the most recently bound variable in another term. These functions can be
defined directly from the primitives in both cases. Within the typing relation,
we rely on the lookup relation \ELookup{} to retrieve the type of a variable
from the typing context. The type of the lookup and typing relation is
expressed using the \AgdaFunction{\_∶⊢\_} operator. This operator computes the
sort of the third index of the relations based on the sort of the second. With
the \AgdaFunction{\_∶⊢\_} operator, we can define a single lookup and typing
relation for well-typed expressions and well-kinded types. For System F, it can
be defined as follows:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EUpArrow{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \ETypeOf{}
\end{minipage}

\subsection*{Separated Renamings and Substitutions}
\begin{figure}[!t]
      \centering
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ERPT{}
      \end{minipage}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESPT{}
      \end{minipage}
      \caption{Renaming and Substitution Preserve Typing}\label{fig:ext-rst}
\end{figure}

We have already seen the instantiation of the $σ$-calculus for System F, where
renamings and substitutions are treated separately, in \cref{sec:mis-sig}. To
establish subject reduction, we first prove that renaming and substitution
preserves typing. The proofs for the preservation lemmas can be found in
\cref{fig:ext-rst}. We prove renaming preserves typing
(\AgdaFunction{\_⊢⋯ᴿ\_}), and then, using this result in the proof for the fact
that lifting of a substitution preserves typing (\AgdaFunction{⊢↑ˢ}, omitted),
show that general substitution preserves typing (\AgdaFunction{\_⊢⋯ˢ\_}) as
well.

The types of both proofs rely on the types for well-typed renamings \EWTR{} and
well-typed substitutions \EWTS{}, whose definitions are omitted here. In the
cases for variables, we look up the well-typed variable in the corresponding
renaming or substitution. When going under a binder, we apply the preservation
lemma for lifting renamings and substitutions. Thanks to the automatic
application of the $σ$-calculus laws, both proofs follow directly by induction,
including the cases under binders.

Using the two results, we can then prove subject reduction for
System~F:\ESR{}All cases proceed without any explicit application of
substitution lemmas. In particular, in the $β$-reduction cases, we can directly
apply the substitution-preserves-typing lemma, whereas normally the interaction
law would need to be applied manually as well.

\subsection*{Using \textsc{Agdasubst}}
We first instantiate the library by providing the traversal function and the
syntax-dependent laws. For System F, the traversal function is given
by:\SFTraversal{}In the case of variables, we convert the result of the lookup
on the Map, whether a variable or a term, into a term. We then proceed to prove
the monad laws:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \small
      \raggedright{}
      \SFId{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \small
      \raggedright{}
      \SFCompo{}
\end{minipage}

\noindent We omit the proofs, but they follow directly by structural induction because
the library already provides and permits rewriting of the necessary laws.
Specifically, for right identity under a binder, we rely on
\AgdaFunction{id↑≡id}\;:\;\AIdLift{}, and for compositionality under a binder,
we rely on \AgdaFunction{dist–↑–;}\;:\;\ADistLift{}. Both additional laws
follow directly from the rules of the $σ$-calculus and do not cause any issues
when admitted as rewrite rules, in addition to the $σ$-calculus laws, rewritten
later. We omit the syntax-dependent laws needed to lift the traversal operator
to the unified lookup/traversal operator, when traversing a term. To complete
the instantiation, lookup and traversal are redefined using the unified
lookup/traversal operator:

\noindent \begin{minipage}[t]{0.48\linewidth}
      \small
      \raggedright{}
      \SFLookupSH{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \small
      \raggedright{}
      \SFTraversalSH{}
\end{minipage}

\noindent To prove that renaming and substitution preserve typing in a single lemma, we
make use of Typing Kits, following the approach of \cite{saffrich:LIPIcs.ITP.2024.32}. Typing
Kits abstract over typed renamings and substitutions depending on a Kit, in a
way analogous to how Maps abstract over renamings and substitutions based on
a Kit. Within the library, they are instantiated exactly twice, once for the
Variable Kit and once for Term Kit. For a
more detailed description, we refer the reader to the already mentioned work.
The unified proof that Maps preserve typing mirrors the shape of the separate
proofs: \SFSPT{}In the variable case, we need to convert a typed
variable or term into a typed term. \textsc{Agdasubst} automatically solves all equations occurring
from lifting. Compared with the proofs presented by
\cite{saffrich:LIPIcs.ITP.2024.32} in Section 5.5\footnote{Additionally available online: \href{https://github.com/m0rphism/kitty/blob/bc86948c60f2d827593ad23e539197f9660178aa/src/Kitty/Examples/SystemF/SubjectReduction.agda\#L9}{Link to proof on GitHub}}, there is no need to
manually move the Map under a weakening for binders or under a singleton
substitution in the case of type application.

The proof of subject reduction is exactly the same as the one presented before.
The only difference is that, instead of using the substitution preserves typing
lemma, we use the more general lemma that Maps preserve typing in the cases of
$β$-reductions: \SFSR{} Normally, we would additionally need to apply the
interaction law manually in the case of \AgdaFunction{β-λ}\footnote{See the
      proof provided by \cite{saffrich:LIPIcs.ITP.2024.32}:
      \href{https://github.com/m0rphism/kitty/blob/bc86948c60f2d827593ad23e539197f9660178aa/src/Kitty/Examples/SystemF/SubjectReduction.agda\#L32}{Link
            to proof on GitHub}}.

\subsection{Generic Syntax}\label{sec:ext-uni}
The class of object languages supported by \textsc{Agdasubst} can be described
by the definition of a generic syntax à la
\cite{allais2021typescopesafeuniverse}, adapted to the intrinsically scoped
setting~\cite{saffrich:LIPIcs.ITP.2024.32}:

% \noindent\begin{minipage}[t]{0.48\linewidth}
%       \raggedright{}
%       \GDesc{}
% \end{minipage}
% \begin{minipage}[t]{0.48\linewidth}
%       \raggedright{}
%       \GDenot{}
%       \GTms{}
% \end{minipage}
% 
% \noindent We can describe our object
% language syntax using sums \AgdaInductiveConstructor{`σ}, products
% \AgdaInductiveConstructor{`X} that introduce binders, and
% \AgdaInductiveConstructor{‘■} to terminate a construct. The \AgdaDatatype{Tm} type turns a syntax description into a data structure that separates variables from the other object language constructors, which are built using sums, products, and equality inside the \AgdaFunction{⟦\_⟧} function.

All laws required for instantiation of the \textsc{Agdasubst} library can be
proven once and for all over the generic syntax. Users can define their own
syntax directly from these building blocks without implementing traversals or
reproving syntax-specific laws.

% Albeit the \AgdaInductiveConstructor{`X}
% constructor permits the addition of \AgdaBound{S′} many binders, the current
% version of \textsc{Agdasubst} does not support variadic binders, that is,
% binders introducing an unknown number of newly bound variables. The rewrite
% rules only apply correctly when \AgdaBound{S′} is fixed. For instance, the
% $σ$-calculus laws apply automatically to the following encoding of the lambda
% calculus, where the generic encoding has a single sort of expressions,
% \GSort{}, and two labels, one for abstraction and one for application,
% \GLabel{}:
% 
% \noindent\begin{minipage}[t]{0.48\linewidth}
%       \raggedright{}
%       \GDescL{}
% \end{minipage}
% \begin{minipage}[t]{0.48\linewidth}
%       \raggedright{}
%       \GPattern{}
% \end{minipage}

While the generic approach is very convenient, the main drawback is that Agda
sometimes unfolds the pattern definitions inside holes, leaking details of the
encoding, which results in proof states that are hard to read.

\section{Further Work}\label{sec:wrk}
This section outlines possible directions for improving \textsc{Agdasubst} in
the future.

In contrast to most of the other substitution libraries, users of
\textsc{Agdasubst} still need to manually provide the definition for traversal
and the syntax-dependent proofs (Monad and Coincidence Laws).
\cite{saffrich:LIPIcs.ITP.2024.32} has shown that definitions and proofs for
scoped syntax can be derived automatically using Agda's reflection mechanism.
There is no reason why the same approach could not be applied for the
definitions and proofs required to instantiate \textsc{Agdasubst}.

\cite{Stark:2020:Mechanising} introduced several interesting extensions to the $σ$-calculus that could also be implemented in \textsc{Agdasubst}. One extension is support for variadic bindings (unknown number of variables bound), useful for languages with pattern matching. Another extension is support for lists of terms, allowing an unknown number of terms in the syntax tree. This would, for example, enable support for languages with $n$-ary application.
The latter can already be encoded in the current system by inlining the list
data structure directly into the syntax definition and treating
them as terms of a new sort.

In its current state, \textsc{Agdasubst} completely lacks a meta-theoretical
analysis. While we conjecture it to be terminating and confluent, it would be
interesting to formally establish these properties.

As noted, \textsc{Agdasubst} is not complete when reasoning simultaneously
about renamings, substitutions and Maps. It would therefore be worthwhile to
investigate additional laws, in the spirit of the coincidence laws, to increase
the space of solvable equations. \textsc{Autosubst 2} already provides a more
sophisticated tactic for the separation of renamings from substitutions, which
could serve as a useful starting point for deriving such additional laws in
\textsc{Agdasubst}.

At the moment, the performance of \textsc{Agdasubst} is, to be honest, very
poor. For instance, the proof of subject reduction for System~F with subtyping
requires several minutes to check. Our analysis shows that most of this time is
spent on instance resolution and function coverage analysis (i.e., verifying
that pattern matching clauses are exhaustive). Currently, we have no concrete
strategy to improve these aspects, without decreasing user-experience, except
that we know, that the addition of the coincidence laws dramatically increases
type-checking time.

\section{Related Work}\label{sec:rwk}

\subsection*{Explicit Substitution Calculi}
There exist a variety of explicit substitution calculi, but we focus on the
original $σ$-calculus~\cite{10.1145/96709.96712}, which includes identity,
extension, shifting, and composition primitives, and the
$σ_{SP}$-calculus~\cite{10.1145/2676724.2693163}, which adds further reductions
to ensure confluence. Only the $σ_{SP}$-calculus is both sound and complete,
enabling all equations between terms to be derived via reduction. Both
completeness and convergence are established through mechanized
proofs~\cite{10.1145/2676724.2693163, Stark:2020:Mechanising}.

\subsection*{Abstractions over Variables/Terms and Renamings/Substitutions}
We already discussed the original work on Kits~\cite{ren-sub} and their
adaptation to multi-sorted and scoped syntax~\cite{saffrich:LIPIcs.ITP.2024.32}
throughout \cref{sec:ags}.

The intrinsically scoped version of this approach also appears in recent work,
for example in a paper written by \cite{altenkirch2025substitution}, where a
uniform treatment of renaming and substitution is explored in an intrinsically
typed setting. Their work also includes a structure and definitions similar to
the structural kit order we defined in \cref{sec:ags-sko}. They additionally
unify variables and terms, which we deliberately do not do, as variables are
library-defined while terms are user-supplied. A further application of the Kit
approach is given by \cite{Wood_2021}, who use it to reason about metatheory in
the context of linear languages.% TODO

Another line of research concerns generic programming
approaches~\cite{allais2021typescopesafeuniverse, 10.1145/3018610.3018613},
which allow the construction of syntax trees from general building blocks
supporting sums, products, and binder introduction. The generic programming
approach also allows for a generic structure that abstracts not only over
renamings and substitutions, but also over semantics and other relevant
language structures. The generic syntax approach can be adapted to a scoped and
multi-sorted setting~\cite{saffrich:LIPIcs.ITP.2024.32}. Importantly, generic
programming and the \textsc{Agdasubst} library are orthogonal, as shown
in~\cref{sec:ext-uni}.

\subsection*{Substitution Libraries for Proof Assistants}
We have already discussed \textsc{Autosubst 2}~\cite{10.1145/3293880.3294101,
      schafer2015autosubst, Stark:2020:Mechanising} which forms the direct
theoretical foundation of our work.

There exists another Agda library with a similar goal to \textsc{Agdasubst},
called \textsc{Abstract Binding Trees}, used for instance by
\cite{siek2021parameterized}. It permits constructing an object language from a
generic syntax, similar to the approach in \cref{sec:ext-uni}, but it supports
only extrinsic scoping and single-sorted syntaxes. The library provides
abstractions over arbitrary predicates about the object language, rather than
focusing on specific relations such as
typing~\cite{saffrich:LIPIcs.ITP.2024.32}. The library also offers incomplete
experimental support for rewriting using $\sigma$-calculus laws, but only
handles renamings and substitutions separately, similar to the approach in
\cref{sec:mis-sig}, rather than in a uniform treatment.

More distantly related is \textsc{Nominal 2}~\cite{Nominal2-AFP}, an Isabelle
package that addresses the $α$-equivalence problem not via de Bruijn indices,
but using nominal datatypes and freshness conditions. Their approach is closer
to the intuitive notion of variables, but the tool does not provide any
strategy for solving equations involving terms and substitutions.

Additionally, there are tools such as \textsc{Needle and
      Knot}~\cite{10.1007/978-3-662-49498-1_17}, which is a code generator for
unscoped syntax using de Bruijn indices. The tool generates substitution and
interaction lemmas for single-pointed substitutions for languages that feature
multiple variable sorts and variadic binders.

\section{Conclusion}\label{sec:con}
We have shown how to take advantage of the $σ$-calculus laws to automatically
solve equations inside proofs about syntaxes with binding in Agda, similar to
\textsc{Autosubst 2} in Rocq.

We first embedded the $σ$-calculus with first-class renamings directly into
Agda as reduction rules, using its rewrite mechanism to yield definitional
equalities for a formalization of System~F.

We then wanted to unify proofs about renamings and substitutions, which led to
the current state of the \textsc{Agdasubst} library. To achieve our goal, we
introduced the notions of Kits and Maps from prior work and adapted the
$σ$-calculus laws to a Kit and Map setting.

We demonstrated how \textsc{Agdasubst} can be used to prove properties
involving substitutions for formal languages, including subject reduction for
System F with subtyping using a single substitution-preserves-typing lemma, and
provided an instantiation of a scoped universe of syntaxes with binding.

The \textsc{Agdasubst} library does not constitute a stable release candidate
yet. We have outlined potential directions for future development and plan to
continue improving the library over time.

\bibliography{references}

\end{document}
