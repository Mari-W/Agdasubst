\documentclass[manuscript,screen,review,anonymous,acmsmall]{acmart}
\usepackage[capitalize,noabbrev]{cleveref}

\usepackage{agda}
\usepackage{stmaryrd}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

\input{examples}
\input{SystemF1}
\input{STLC}
\input{SystemFo}
\input{unicodeletters}

\begin{document}

\title{Intrinisically Typed Syntax That Works (Functional Pearl)}

\author{Peter Thiemann}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}

\author{Marius Weidner}
\email{weidner@cs.uni-freiburg.de}
\affiliation{%
  \institution{University of Freiburg}
  % \city{Hekla}
  \country{Germany}}
\orcid{0009-0008-1152-165X}

\begin{abstract}
Intrinsically typed syntax promises elegant mechanizations: well-typed
terms are represented by well-typed data, substitution preserves
typing by construction, and type safety proofs collapse to
straightforward induction. For simple calculi such as the simply-typed
lambda calculus this promise is fulfilled. For realistic systems, however,
the technique often becomes impractical. In dependently typed proof
assistants, intrinsically typed encodings of polymorphic calculi lead
to pervasive type-changing equalities: renamings and substitutions
indexed by other substitutions force proofs to transport terms across
equal types that are not definitionally equal. This
phenomenon---informally known as transfer hell---causes even routine
metatheoretic arguments to be dominated by administrative reasoning.  

This functional pearl shows how to make intrinsically typed syntax
work in practice for polymorphic calculi. We give extacts of a
mechanization of the metatheory of System F and extend
it to System F$\omega$ in Agda while avoiding transfer reasoning almost
entirely. The key idea is to internalize the equational theory of the
$\sigma$-calculus for substitutions as definitional equality. We rely
on proved $\sigma$-calculus laws for a functional representation of substitutions and
install them into Agda’s rewrite mechanism, obtaining canonical
behavior for substitution and renaming without explicit
transports. The main technical challenge is ensuring that the
resulting rewrite system remains terminating and confluent together
with Agda’s built-in definitional equality. 
 
The resulting development dramatically simplifies proofs: typing
preservation becomes definitional, substitution lemmas disappear, and 
type conversion in System F$\omega$ can be handled intrinsically. Our
experience suggests a general methodology: when intrinsically typed
syntax generates transports, the correct solution is often not more
lemmas but better definitional equality. We distill practical
guidelines for mechanizing typed calculi in dependently typed proof
assistants. 
\end{abstract}

\maketitle
\keywords{Intrinisically Typed Syntax, Strictification, Agda}

\section{Introduction}
\label{sec:introduction}

Intrinsically typed syntax is widely recommended for mechanizing type
systems in dependently typed proof assistants. By representing
well-typed terms as well-typed data, typing invariants hold by
construction as in a Church-style presentation, i.e., making typing
preservation trivial. For small 
calculi this approach works beautifully. However, for realistic
polymorphic calculi such as System F, mechanizations often become
complicated: conceptually simple proofs become cluttered with
transports across equal types and administrative equalities. 

\begin{figure}[tp]
  \begin{minipage}[t]{0.49\linewidth}
  \STLCTypeCtx
  \STLCVar
  \STLCExpr 
  \end{minipage}
  ~
  \begin{minipage}[t]{0.49\linewidth}
    \STLCSmallStep
    \STLCProgress
  \end{minipage}
  \caption{Call-by-name simply-typed lambda calculus}
  \label{fig:simply-typed-syntax}
\end{figure}
The simply-typed lambda calculus is the prime example where
intrinsically typed syntax works like a charm. \Cref{fig:simply-typed-syntax}
shows typical definitions of the 
syntax of types, type contexts, variables, and expressions, which are
indexed by contexts and types (left column). Building on these definitions it is
straightforward to define a small-step operational semantics and
proving type safety. This is because subject reduction holds by construction and progress
follows by a simple inductive proof (right column). The style of these
definitions is adapted from the textbook by
\citet{DBLP:journals/scp/KokkeSW20}. We elide the definition  of the
substitution operator $\_[\_]$, as we discuss substitutions in detail
in \cref{sec:types}.

The simply-typed lambda calculus therefore represents the ideal
scenario: intrinsic typing elides type preservation proofs, thus
making type safety proofs so concise that they can serve as textbook
examples \cite{DBLP:journals/scp/KokkeSW20}. Nothing comparable to
transport reasoning arises in this development as only definitional
properties of substitutions are required. The remainder of this paper
explains why the same approach breaks down for polymorphic calculi and
how to recover some of its simplicity.


Transfer hell is the colloquial term for being forced to apply
type-changing lemmas to terms that are already known to be equal.
The root problem is that substitutions that are propositionally equal
are not definitionally equal, so terms must repeatedly be transported
across equal types. 
This situation is annoying because proof assistants like Agda or Coq plainly
refuse to let users even state this equality.\footnote{A situation
  that can be addressed using heterogeneous equality introduced in
  Conor McBride's thesis~\cite{DBLP:conf/types/McBride00}.
  \citet{DBLP:journals/jar/BentonHKM12} discuss this approach in the
  context of an adequacy proof for a logical relation.}
This phenomenon appears when substitutions themselves carry dependent typing
information. In System F and F$\omega$, expression substitutions
depend on type substitutions and type substitutions depend on
renamings; composing them yields types that are equal only
propositionally, forcing transports throughout proofs. 
One workaround is to state definitions and
proofs with explicit equivalence relations, but this practice is
cumbersome, inefficient, and far away from the holy grail of
definitional equality, which just works.

To our knowledge, previous intrinsically typed mechanization of
System~F$\omega$ (e.g., \cite{10.1007/978-3-030-33636-3_10})
follow a natural design: expression syntax is indexed by typing
derivations and substitutions are indexed by substitutions at the type
level. While elegant at the level of definitions, this design makes
proofs brittle. Because expression substitutions depend on type
substitutions, and type substitutions depend on renamings, which again
depend on type renamings, routine equalities require repeated
transport across equal types, leading to directly to transfer hell. 

The message of this pearl is simple: when intrinsically typed syntax
becomes complicated, the problem is often not the encoding of terms
but the definition of equality on substitutions. Strengthening
definitional equality can simplify metatheory more effectively than
adding automation or additional lemmas.

In this paper, we examine the transfer hell arising by
intrinsically-typed syntax encodings of System~F and
System~F$\omega$. Specifically, we consider the problems arising with
type-renaming-indexed renamings and type-substitution-indexed
substitutions.
Our solution is to strengthen definitional equality rather than to add
more lemmas. We make substitution compute canonically by internalizing
the equational theory of substitutions (the $\sigma$-calculus) as
definitional equality using Agda’s rewriting mechanism. As a
consequence, extensionally equal substitutions normalize to the same
form and transports disappear from routine proofs. 
This approach is inspired by the tactics of Autosubst
\cite{schafer2015autosubst,Stark:2020:Mechanising,10.1145/3293880.3294101},
but internalized by rewriting \cite{10.1145/3434341}. We build on a
standard functional representation of renamings and substitutions
\cite{DBLP:journals/jar/BentonHKM12}, prove the lemmas underlying the
equational laws of the sigma calculus, and then inject these equations
into Agda's rewrite engine, i.e., make the sigma calculus equations
definitional (for type substitutions). The technical challenge is to
ensure that the added equations remain terminating and confluent
together with the proof assistant’s built-in definitional equality. 

We first exercise this program for plain System~F in
\cref{sec:system-f}, significantly simplifying the transfer-ridden approach used by
\citet{10.1145/3678000.3678201}, 
and then apply the same techniques to System~F$\omega$ in
\cref{sec:system-fomega}. In the latter, the main difference to
previous work \cite{10.1007/978-3-030-33636-3_10} lies in our
intrinsic treatment of type conversion, which leads to significant
simplifications.
In particular, in our developments, transport lemmas disappear, subject
reduction holds by construction, and type conversion in System F$\omega$ is handled intrinsically.

In summary, intrinsically typed syntax fails for polymorphic calculi
because substitutions lack canonical equality; making them compute
canonically restores the original promise of intrinsic typing.


\subsection*{Contributions}
This functional pearl demonstrates how to mechanize polymorphic
calculi using intrinsically typed syntax without pervasive transport
reasoning. 
\begin{itemize}
\item We identify the fundamental cause of ``transfer hell'' in intrinsically typed
  encodings of System F and System F$\omega$: renamings and substitutions
  indexed by other substitutions produce equal types that are not
  definitionally equal.
\item 
  We show how to eliminate these transports by installing the
  equational laws of the $\sigma$-calculus for substitutions as definitional
  equality using Agda’s rewriting mechanism, taking care to make the
  equations compatible with the built-in definitional equality.
\item 
  We demonstrate that the resulting rewrite system is compatible with Agda’s
  definitional equality (in particular, terminating and confluent) for
  the functional representation of substitutions
  and verify that the resulting rewrite system is terminating and
  confluent with respect to the proof assistant’s definitional
  equality. 
\item 
  We mechanize parts of the metatheory of System F and extend it to System F$\omega$,
  obtaining substantially simpler proofs and an intrinsic treatment of
  type conversion for the latter.
\item 
  From this experience we extract practical guidelines for designing
  intrinsically typed syntax in dependently typed proof assistants.
\end{itemize}

\section{System F}
\label{sec:system-f}

\subsection{Types}
\label{sec:types}

\begin{figure}[tp]
  \begin{minipage}[t]{0.49\linewidth}
    \SFTypeRenaming
    \SFTypeRenamingOpaque
  \end{minipage}
  \begin{minipage}[t]{0.49\linewidth}
    \SFTypeSubstitution
    \SFTypeSubstitutionOpaque
  \end{minipage}
  \caption{Renamings and substitutions on types}
  \label{fig:system-f-ren-sub}
\end{figure}

The syntax of System~F types uses the standard de Bruijn encoding of
variables by natural numbers. The index $n$ stands for the number of
type variables in scope. Variables are drawn from the type $\AgdaDatatype{Fin}\ n$, i.e.,
the set $\{0,\dots, n-1\}$. The  \AgdaInductiveConstructor{$\forall\alpha$}-binder introduces a new type
variable, and \AgdaInductiveConstructor{$\Rightarrow$} is the infix function type constructor.
\SFTypeDefinition

\Cref{fig:system-f-ren-sub} contains the first step in defining
type renamings (left column) and substitutions (right column).
A type renaming $\zeta$ maps variables from one scope $n_1$ to
another $n_2$. We write the type of type renamings as $n_1$ \AgdaFunction{$\to^R$} $n_2$.
The definitions comprise (in order) weakening, the identity renaming,
extending a renaming, applying a renaming to a variable,
composing two renamings, lifting a renaming (to move under a
binder), and applying a renaming to a type.

A this point, the astute reader may wonder about the use of
\AgdaKeyword{opaque} in the definitions. The function symbols defined in an
\AgdaKeyword{opaque} block are usable from outside, but their
computational behavior is hidden. Thus, the only normal definition is
\AgdaFunction{$\uparrow^R$} for lifting a renaming. This selective hiding is
essential for our approach because we want to establish new definitional
equalities (i.e., the laws of the sigma calculus with first-class
renamigns) on top of the thus defined symbols. These new equalities 
interfere in a bad way with the standard definitional equalities, thus
we hide the latter. To prove these equalities, we open the opaque
definitions locally and proceed as usual.

For substitutions (right column of \cref{fig:system-f-ren-sub}) we
proceed analogously. A type substitution $\eta$ maps variables from scope
$n_1$ to types defined over scope $n_2$. We write the type of type
substitutions as $n_1$ \AgdaFunction{$\to^S$} $n_2$. The definitions (in order)
comprise
lifting a renaming to a substitution, extending a
substitution, applying a substitution to variable, lifting a
substitution (to move under a binder), applying a substitution to a
type, and composing two substitutions.

\begin{figure}[tp]
  \begin{flushleft}
    \SFTypeRenamingBeta
    \SFTypeSubstitutionBeta
    \SFTypeMonad
    \SFTypeCoincidence
  \end{flushleft}
  \caption{Equational laws of the sigma calculus with first class
    renamings}
  \label{fig:system-f-sigma-calculus}
\end{figure}

\Cref{fig:system-f-sigma-calculus} gives the equational laws of the
sigma calculus with first-class renamings \cite{schafer2015autosubst}.
All of these equalities are supported by proofs using the definitions from
\cref{fig:system-f-ren-sub}, but the proofs are not included because
they are standard.

The first group gives computation rules for renamings, in particular,
how to apply the different forms of renamings to a variable. The
second group presents interaction laws for renamings. Most of them
deal with composition.

The third group presents computation rules for substitutions starting
with the application of a substitution to a variable. There is one
equation for each possible form of a substitution: extended
substitution, lifted renaming, and composition of substitutions. The
final equation in this group characterizes lifting in terms of extension,
weakening, and composition.

The fourth group contains laws about composition of substitutions,
which are mostly analogous to the corresponding laws for renamings.

The fifth group presents laws that govern the composition of different
kinds of term traversal. All four combinations of applying renamings
and substitutions to a type are covered.

The final group contains covers laws that mediate between substitutions and renamings.

Orienting these equations from left to right results in a confluent
and terminating rewrite system that we install in Agda using its
rewrite pragma \cite{10.1145/3434341}. From now on, all equations in
\cref{fig:system-f-sigma-calculus} are definitional!

As a sanity check, we show that lifting a renaming as well as the
action of a renaming satisfy the functor laws. All of these lemmas
hold definitionally, some correspond directly equations from the sigma
calculus in \cref{fig:system-f-sigma-calculus}. The latter are marked
with $*$.\footnote{The naming of the lemmas is taken from
  \citet{10.1007/978-3-030-33636-3_10} to enable direct comparisons.} 
\SFTypeRenFunctorial

We also show analogous results for substitution.
\SFTypeSubFunctorial

\subsection{Expressions}
\label{sec:expressions}

\begin{figure}[tp]
  \begin{minipage}[t]{0.49\linewidth}
  \SFTypeWeaken
  \SFTypeSubzero
  \SFTypeCtx
  \SFTypeVar
  \end{minipage}
  \begin{minipage}[t]{0.49\linewidth}
    \SFExprDefinition
  \end{minipage}
  \caption{Type contexts, variables, and expressions}
  \label{fig:system-f-expressions}
\end{figure}


Working towards intrinsically-typed expressions,
\Cref{fig:system-f-expressions} defines type weakening and
single substitution along with type contexts, expression variables, and the syntax of
expressions. Type contexts and expression variables follow the work of
\citet{10.1007/978-3-030-33636-3_10}. Type contexts \AgdaDatatype{Ctx}
keep track of expression variables and type
variables. Correspondingly, variables are implemented as typed de Bruijn
indices with an extra case \AgdaInductiveConstructor{suc*} to skip
over type variables in the context. Skipping requires weakening of the
type as it is used under one more type binding.

Expressions are indexed by a context and a type. Each expression
constructor corresponds to a typing rule in System~F. The rule for
type application relies on single substitution for types.

The definition of a small-step operational semantics requires
expression renamings and substitution to implement beta reduction for
value abstractions and type abstractions. As before, we aim to define
a call-by-name semantics for concision.

\subsection{Expression Renaming and Substitution}
\label{sec:expr-renam-subst}

For expressions, we represent renamings and substitutions directly by
suitable functions, rather than axiomatic as with type renamings and
substitutions. Hence, we cannot automate the simplification of
expression substitutions; nevertheless, we define the primitives analogously.

\subsubsection{Renaming}
\label{sec:renamings}

Expression renamings are indexed by type renamings because type
variables in expression may have to be renamed at the same time as
expression variables. This complication makes the types of the
operations quite involved, although the actual operations are not that
complicated. 
\SFExprRenaming
Defining the identity renaming is straightforward due to the presence
of rewriting for type substitutions.
\SFExprRenIdr
Weakening of a renaming by a value binding. 
\SFExprRenWeakening
Weakening of a renaming by a type binding.
\SFExprRenTWeakening
Extension of a renaming.
\SFExprRenExtension
Lifting of a renaming over a value binding.
\SFExprRenLifting
Lifting of a renaming over a type binding.
\SFExprRenTLifting
Inductive definition of a renaming on expressions. The last case of
the definition requires rewriting to type check.
\SFExprRenTraversal

\subsubsection{Substitution}
\label{sec:substitution}

Expression substitutions are indexed by type substitutions.
\SFExprSubstitution
The identity substitution for expressions is straightforward to
define. But this simplicity is due to the installed rewriting of type
substitutions, which avoids an explicit application of a transport
lemma using \AgdaPostulate{comp-id$_r$}.
\SFExprSubIds
Extending a substitution is standard.
\SFExprSubExtension
Due to the structure of contexts, we need two lifting lemmas, one for
value bindings and another for type bindings. 
The former requires a transport lemma, which is applied by rewriting.
\SFExprSubLifting
Lifting a substitution over a type binding is straightforward.
\SFExprSubTLifting
These operations are sufficient to define the application of a
substitution to an expression.
\SFExprSubTraversal

\subsection{Semantics}
\label{sec:semantics}

\begin{figure}[tp]
  \begin{minipage}[t]{0.49\linewidth}
    \SFExprSemProgressDefs
  \end{minipage}
  \begin{minipage}[t]{0.49\linewidth}
    \SFExprSemProgress
  \end{minipage}
  \caption{Progress for System~F}
  \label{fig:system-f-progress}
\end{figure}

We are now in position to define a small-step operational
semantics. The definition of single substitution, needed for beta
reduction, is analogous to the one on types: we build the substitution
by extending the identity substitution with the argument. In addition, a type
substitution into expression is needed for beta reduction of type
applications. This substitution is also implemented by an expression
substitution indexed by a type substitution that performs the actual change.
\SFExprSemSingleSub

With substitution in place, the definition of call-by-name small-step
reduction is straightforward. As usual, such a definition of reduction for
intrinsically-typed syntax implies subject reduction by construction.
\SFExprSemDefinition

To obtain type safety, it remains to prove progress.
\Cref{fig:system-f-progress} presents the complete proof of progress
for call-by-name System~F. A value is either a lambda or a big lambda
where the body is already a value. An expression fulfills progress if
it is either a value (\AgdaInductiveConstructor{done}) or it can make
a step (\AgdaInductiveConstructor{step}). Due to the definition of
value for big lambdas, we establish progress for type contexts that
may contain type bindings, but no value bindings. These contexts are
characterized by function \AgdaFunction{NoVar}. The actual proof of
progress is by induction on the structure of expressions. The overall
structure of this proof closely follows the corresponding proof by
\cite{10.1007/978-3-030-33636-3_10}. Their proof is more complicated
because their semantics is call-by-value and their language supports
isorecursive types.

\subsection{Laws for Renamings and Substitutions}
\label{sec:laws-renam-subst}

Proving type safety for System~F \emph{requires} exercising the
substitution theory at the \emph{type level}. Without installing its
laws as definitional equalities, many definitions become more
cumbersome because transport lemmas have to be inserted to equalize
the types of (Agda) expressions.

While proving type safety does \emph{not} require exercising same
theory at the \emph{expression level}, it is still good practice to
verify functorial and monadic properties of expression
substitutions. Moreover, if we were to move on to constructing and
proving properties of logical relations, then these properties would
be needed \cite{10.1145/3678000.3678201}.

As an example, we examine the composition of two expression
substitutions. Its definition involves two type substitutions $\eta_1$ and $\eta_2$ that
index the corresponding expression substitutions $\sigma_1$ and
$\sigma_2$. The composed expression substitution is indexed by the
composition of  $\eta_1$ and $\eta_2$. Type checking this definition
already exercises the laws for composition of type substitutions.
\SFExprSubCompDefinition

Here is the statement of functoriality of expression substitution:
applying two substitutions one after the other to an expression is the
same as applying their composition. This statement is a very prominent
example of transfer hell: the types of the left and right side of the
equality are different and would require a transfer without our
rewriting machinery in place.
\SFExprSubComposeType
We show the proof of this property just do demonstrate that type
adjustments for type substitutions can be ignored and we can
concentrate on the gist of the proof, rather than being overwhelmed by
transfers. The remaining fly in the ointment is the explicit passing
of the type substitutions $\eta_1$ and $\eta_2$. We chose to make them
explicit; while Agda can infer them in many places, 
there are equally many places where inference is not possible.
\SFExprSubComposeBody

This proof relies on further properties, in particular
\AgdaFunction{Lift-Dist-Comp$^{SS}$} (lifting a composition of substitutions
is equal to composing their liftings) and
\AgdaFunction{lift*-dist-Comp$^{SS}$} (its counterpart for lifting
over type bindings), where the statement and proof would require
explicit transfers. Essentially, these properties form a ``food
chain'' that stops at the composition properties of renamings with
renamings and liftings, all with similar issues. The supplemental
material gives the full story.

\subsection{Examples}
\label{sec:examples-1}

As an example of System~F expressions, we present some definitions for
Church numerals. We start with their type. For readability, we define aliases for type variables like
\AgdaFunction{$`\alpha$} for \AgdaInductiveConstructor{` Z}, \AgdaFunction{$`\beta$} for \AgdaInductiveConstructor{` (S Z)}, and analogously for
expression variables and binders.
\FCNType
We give the definitions for some constants and the successor operation.
\FCNZero
\FCNOne
\FCNSucc
\FCNTwo
% \FCNFour

\section{System F$\omega$}
\label{sec:system-fomega}

System~F$\omega$ extends System~F with higher-kinded types, that is,
abstraction over type functions. This calculus is the basis of
Haskell's type system where type functions are limited to partial
application of type constructors. Abstraction of higher-kinded types
is key to defining type classes for functors, monads, etc. An
extension of F$\omega$ with isorecursive types is the basis for
Plutus, the language of the Cardano blockchain
\cite{10.1007/978-3-030-33636-3_10}. 

\subsection{Definitions}
\label{sec:definitions}

We only give a glimpse of the definitions of the syntax of types and
expressions, which are taken from \cite{10.1007/978-3-030-33636-3_10}
and hence generalize the definitions for System~F from
\cref{sec:system-f}. We do not reiterate the development of renamings
and substitutions, as it transfers mutatis mutandis: the typings get
more involved, but the equational laws remain exactly the same.

For System~F$\omega$, type variables have more structure as in
System~F, as there are arrow kinds in addition to plain types. We use
$I, J, K$ to range over types.
\FOKind
Consequently, kind contexts are not mere numbers, but lists of kinds
that grow to the right. Kind contexts are ranged over by $\Phi, \Psi, \Theta$.
\FOTypeCtx
Type variables have the same structure as plain variables in the
simply-typed lambda calculus (see \cref{fig:simply-typed-syntax}).
\FOTypeVar

The definition of the type syntax also mimicks the expressions of the
simply-typed lambda calculus, but with an important
twist, which deviates from the prior work. 
\FOType
As System~F$\omega$ enjoys full beta reduction at the type level, we
do not define application (with symbol $\$$) as a data
constructor. Instead, we introduce it as a symbol and use rewriting
to extend functions on the type syntax to include application.

As an example, we show the definition of applying a renaming to an
expression. We elide the preceding definitions of lifting, extension,
and the type substitution machinery because they are identical to the
ones for System~F in \cref{sec:types}, save for the more elaborate type signatures.
\FORenTraversal

On top of the rewriting theory for type substitutions, we install type-level beta reduction as a rewrite rule,
using single type substitution on the right side:
\FOTypeBeta
\FORewrite
The combined theory is still confluent and terminating \cite{10.1145/96709.96712,10.1145/226643.226675}.

Surprisingly, type-level beta reduction is not required to define the
syntax of expressions, expression renamings and substitutions,
defining the operational semantics, as well as the proof of
type safety. Thanks to definitional beta conversion at the type level,
the expression syntax does \emph{not} require an explicit type conversion
rule as it was the case in prior work \cite{10.1007/978-3-030-33636-3_10}.
Hence, the proof presented in
\cref{fig:system-f-progress} for System~F carries over, mutatis
mutandis (i.e., adapting the type signatures).

In the next section, we develop some examples that genuinely rely on
type conversion.

\subsection{Examples}
\label{sec:examples}

\citet{10.1007/978-3-030-33636-3_10} consider several examples
to demonstrate their encoding of System~F$\omega\mu$. Their first group
of examples covers Church numerals in System~F. These are covered in
\cref{sec:examples-1}. Their second group of example covers recursive
types. We have no counterpart for them. Unfortunately, they do not
provide examples that exercise the full power of System~F$\omega$,
namely higher-kinded types! We fill this gap in the following.

\subsubsection{Church Numerals}
\label{sec:church-numerals}


First, we encode (simply-typed) Church numerals \emph{in the type
  language}. As beta reduction on the type level is definitional in
our development, normalization of Church numerals is performed by
Agda's type checker.

The kind of type level Church numerals is as expected.
\CNKind

We define zero and successor for Church numerals in the usual way. For readability, we
define aliases like \AgdaFunction{$\lambda\beta$} and so on for the type level lambda
\AgdaFunction{$\lambda\alpha$}. Analogously, we define aliases for type variables like
\AgdaFunction{$`\alpha$} for \AgdaInductiveConstructor{` Z}, \AgdaFunction{$`\beta$} for \AgdaInductiveConstructor{` (S Z)}, and so on.
\CNZeroSucc

We construct the Church numeral for $2$ by applying the successor
twice to zero. The proof that this term is equal to is normal form is definitional.
\CNTwoProof

Finally, we define addition and construct $2$ by adding $1+1$. The
corresponding equality proof puts a significant load on the type checker and
takes more than a minute to complete on the authors' machine.
\CNAddition

\subsubsection{Arrows}
\label{sec:arrows}

The final example is inspired by the work on arrows
\cite{DBLP:journals/scp/Hughes00}. This work uses type classes to
abstract over different instantiations of the function arrow. For
clarity, we start with an Agda version of the function that we wish to
implement in System~F$\omega$. 

The function \AgdaFunction{abst} is a glorified identity function. It abstracts over a
binary type constructor $\kappa$, two types $\beta$ and $\alpha$, then
it takes an abstract application function $app$ and applies it to an
abstract function $f$ and a suitable
argument $x$. Function \AgdaFunction{inst} instantiates this function. It
acts like an eliminator for \AgdaFunction{abst}. The function
\AgdaFunction{use} puts both together.
\FOPrelude
We start by defining the type in our encoding.
\FOTyApp
Next, we encode the defining expression equivalent to \AgdaFunction{abst}.
\FOAbstApp
To use this function, we encode functions \AgdaFunction{inst} and \AgdaFunction{use}.
\FOInstApp
\FOUseApp

The definitions of the encodings require beta conversion at the type
level. These definitions are not accepted without the rewriting of
beta reduction $\beta{\equiv}*$.

\section{Conclusion}
\label{sec:conclusions}

Intrinsically typed syntax promises elegant mechanizations by making
well-typed programs representable only as well-typed data, but for
polymorphic calculi this promise is often undermined by pervasive
transport reasoning. Our experience with System~F and System~F$\omega$
shows that the difficulty does not stem from binding structure or
indexing itself, but from a mismatch between substitution and
definitional equality: substitutions that are extensionally equal fail
to compute to a canonical form. By internalizing the equational laws of
the $\sigma$-calculus as definitional equality, substitutions become
canonical and routine transports disappear from proofs. The resulting
developments recover the simplicity seen in the simply-typed case
while scaling to higher-order polymorphism and intrinsic type
conversion. More broadly, this pearl suggests a practical guideline
for mechanizing type systems in dependently typed proof assistants:
when intrinsically typed encodings become proof-heavy, a promising
strategy is often to strengthen definitional equality rather than
introduce additional lemmas or automation. 


\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

% \appendix

% \section{Proofs}

\end{document}
\endinput

