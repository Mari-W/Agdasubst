@article{berardi1988towards,
  title={Towards a mathematical analysis of the Coquand-Huet calculus of constructions and the other systems in Barendregt’s cube},
  author={Berardi, Stefano},
  journal={Technica1 report, Carnegie-Me11on University (USA) and Universita di Torino (Ita1y)},
  year={1988},
  url={https://link.springer.com/chapter/10.1007/3-540-58140-5_33}
}
@InProceedings{10.1007/3-540-52592-0_53,
author="Barendregt, Henk
and Hemerik, Kees",
editor="Jones, Neil",
title="Types in lambda calculi and programming languages",
booktitle="ESOP '90",
year="1990",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--35",
isbn="978-3-540-47045-8",
url={https://repository.ubn.ru.nl/bitstream/handle/2066/17284/17284.pdf}
}
@article{terlouw1989een,
  title={Een nadere bewijstheoretische analyse van GSTT’s},
  author={Terlouw, Jan},
  journal={Manuscript (in Dutch)},
  year={1989},
  url={https://pure.tue.nl/ws/files/2226689/9613618.pdf}
}
@inproceedings{10.1007/11617990_1,
author = {Adams, Robin},
title = {Formalized metatheory with terms represented by an indexed family of types},
year = {2004},
isbn = {3540314288},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/11617990_1},
doi = {10.1007/11617990_1},
abstract = {It is possible to represent the terms of a syntax with binding constructors by a family of types, indexed by the free variables that may occur. This approach has been used several times for the study of syntax and substitution, but never for the formalization of the metatheory of a typing system. We describe a recent formalization of the metatheory of Pure Type Systems in Coq as an example of such a formalization. In general, careful thought is required as to how each definition and theorem should be stated, usually in an unfamiliar ‘big-step' form; but, once the correct form has been found, the proofs are very elegant and direct.},
booktitle = {Proceedings of the 2004 International Conference on Types for Proofs and Programs},
pages = {1–16},
numpages = {16},
location = {Jouy-en-Josas, France},
series = {TYPES'04}
}
@Inbook{Knuth1983,
author="Knuth, D. E.
and Bendix, P. B.",
editor="Siekmann, J{\"o}rg H.
and Wrightson, Graham",
title="Simple Word Problems in Universal Algebras",
bookTitle="Automation of Reasoning: 2: Classical Papers on Computational Logic 1967--1970",
year="1983",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="342--376",
abstract="An algorithm is described which is capable of solving certain word problems: i.e. of deciding whether or not two words composed of variables and operators can be proved equal as a consequence of a given set of identities satisfied by the operators. Although the general word problem is well known to be unsolvable, this algorithm provides results in many interesting cases. For example in elementary group theory if we are given the binary operator {\textperiodcentered}, the unary operator −, and the nullary operator e, the algorithm is capable of deducing from the three identities a {\textperiodcentered} (b {\textperiodcentered} c) = (a {\textperiodcentered} b) {\textperiodcentered} c, a {\textperiodcentered} a− = e, a {\textperiodcentered} e = a, the laws a− {\textperiodcentered} a = e, e {\textperiodcentered} a = a, a− −= a, etc.; and furthermore it can show that a {\textperiodcentered} b = b {\textperiodcentered} a−is not a consequence of the given axioms.",
isbn="978-3-642-81955-1",
doi="10.1007/978-3-642-81955-1_23",
url="https://doi.org/10.1007/978-3-642-81955-1_23"
}
@phdthesis{norellPracticalProgrammingLanguage2007,
title = {Towards a Practical Programming Language Based on Dependent Type Theory},
author = {Norell, Ulf},
year = {2007},
month = sep,
address = {{SE-412 96 G\"oteborg, Sweden}},
abstract = {Dependent type theories [ML72] have a long history of being used for theorem proving. One aspect of type theory which makes it very powerful as a proof language is that it mixes deduction with computation. This also makes type theory a good candidate for programming	extemdash the strength of the type system allows properties of programs to be stated and established, and the computational properties provide semantics for the programs.},
url = {https://www.cse.chalmers.se/~ulfn/papers/thesis.pdf},
keywords = {Agda},
school = {Department of Computer Science and Engineering, Chalmers University of Technology},
type = {{{PhD Thesis}}} 
}
@article{goguen1997candidates,
  title={Candidates for substitution},
  author={Goguen, Healfdene and McKinna, James},
  journal={LFCS report series-Laboratory for Foundations of Computer Science ECS LFCS},
  year={1997},
  publisher={UNIVERSITY OF EDINBURGH},
  url={https://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-358/}
}
@inproceedings{10.1007/978-3-662-49498-1_17,
author = {Keuchel, Steven and Weirich, Stephanie and Schrijvers, Tom},
title = {Needle \& Knot: Binder Boilerplate Tied Up},
year = {2016},
isbn = {9783662494974},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-662-49498-1_17},
doi = {10.1007/978-3-662-49498-1_17},
abstract = {To lighten the burden of programming language mechanization, many approaches have been developed that tackle the substantial boilerplate which arises from variable binders. Unfortunately, the existing approaches are limited in scope. They typically do not support complex binding forms such as multi-binders that arise in more advanced languages, or they do not tackle the boilerplate due to mentioning variables and binders in relations. As a consequence, the human mechanizer is still unnecessarily burdened with binder boilerplate and discouraged from taking on richer languages.This paper presents Knot, a new approach that substantially extends the support for binder boilerplate. Knot is a highly expressive language for natural and concise specification of syntax with binders. Its meta-theory constructively guarantees the coverage of a considerable amount of binder boilerplate for well-formed specifications, including that for well-scoping of terms and context lookups. Knot also comes with a code generator, Needle, that specializes the generic boilerplate for convenient embedding in Coq and provides a tactic library for automatically discharging proof obligations that frequently come up in proofs of weakening and substitution lemmas of type-systems.Our evaluation shows, that Needle \& Knot significantly reduce the size of language mechanizations by 40\"{\i} \'{z}\% in our case study. Moreover, as far as we know, Knot enables the most concise mechanization of the POPLmark Challenge 1a + 2a and is two-thirds the size of the next smallest. Finally, Knot allows us to mechanize for instance dependently-typed languages, which is notoriously challenging because of dependent contexts and mutually-recursive sorts with variables.},
booktitle = {Proceedings of the 25th European Symposium on Programming Languages and Systems - Volume 9632},
pages = {419–445},
numpages = {27}
}
@article{Nominal2-AFP,
  author  = {Christian Urban and Stefan Berghofer and Cezary Kaliszyk},
  title   = {Nominal 2},
  journal = {Archive of Formal Proofs},
  month   = {February},
  year    = {2013},
  note    = {\url{https://isa-afp.org/entries/Nominal2.html},
             Formal proof development},
  ISSN    = {2150-914x},
}
@incollection{MARTINLOF197573,
title = {An Intuitionistic Theory of Types: Predicative Part},
editor = {H.E. Rose and J.C. Shepherdson},
series = {Studies in Logic and the Foundations of Mathematics},
publisher = {Elsevier},
volume = {80},
pages = {73-118},
year = {1975},
booktitle = {Logic Colloquium '73},
issn = {0049-237X},
doi = {https://doi.org/10.1016/S0049-237X(08)71945-1},
url = {https://www.sciencedirect.com/science/article/pii/S0049237X08719451},
author = {Per Martin-Löf},
abstract = {Publisher Summary
The theory of types is intended to be a full-scale system for formalizing intuitionistic mathematics as developed. The language of the theory is richer than the languages of traditional intuitionistic systems in permitting proofs to appear as parts of propositions so that the propositions of the theory can express properties of proofs. There are axioms for universes that link the generation of objects and types and play somewhat the same role for the present theory as does the replacement axiom for Zermelo–Fraenkel set theory. The present theory is based on a strongly impredicative axiom that there is a type of all types in symbols. This axiom has to be abandoned, however, after it has been shown to lead to a contraction. This chapter discusses Normalization theorem, which can be strengthened in two ways: it can be made to cover open terms and it can be proved that every reduction sequence starting from an arbitrary term leads to a unique normal term after a finite number of steps. The definition of the notion of convertibility and the proof that an arbitrary term is convertible can no longer be separated because the type symbols and the terms are generated simultaneously.}
}
@article{10.1145/3236770,
author = {Cockx, Jesper and Abel, Andreas},
title = {Elaborating dependent (co)pattern matching},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236770},
doi = {10.1145/3236770},
abstract = {In a dependently typed language, we can guarantee correctness of our programs by providing formal proofs. To check them, the typechecker elaborates these programs and proofs into a low level core language. However, this core language is by nature hard to understand by mere humans, so how can we know we proved the right thing? This question occurs in particular for dependent copattern matching, a powerful language construct for writing programs and proofs by dependent case analysis and mixed induction/coinduction. A definition by copattern matching consists of a list of clauses that are elaborated to a case tree, which can be further translated to primitive eliminators. In previous work this second step has received a lot of attention, but the first step has been mostly ignored so far. We present an algorithm elaborating definitions by dependent copattern matching to a core language with inductive datatypes, coinductive record types, an identity type, and constants defined by well-typed case trees. To ensure correctness, we prove that elaboration preserves the first-match semantics of the user clauses. Based on this theoretical work, we reimplement the algorithm used by Agda to check left-hand sides of definitions by pattern matching. The new implementation is at the same time more general and less complex, and fixes a number of bugs and usability issues with the old version. Thus we take another step towards the formally verified implementation of a practical dependently typed language.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {75},
numpages = {30},
keywords = {Agda, Copatterns, Dependent pattern matching, Dependent types}
}
@article{gratzer2022controlling,
  title={Controlling unfolding in type theory},
  author={Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  journal={arXiv preprint arXiv:2210.05420},
  year={2022},
  url={https://arxiv.org/abs/2210.05420}
}
@inproceedings{10.1145/75277.75283,
author = {Wadler, P. and Blott, S.},
title = {How to make ad-hoc polymorphism less ad hoc},
year = {1989},
isbn = {0897912942},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/75277.75283},
doi = {10.1145/75277.75283},
abstract = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the “eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {60–76},
numpages = {17},
location = {Austin, Texas, USA},
series = {POPL '89}
}
@incollection{Hofmann1997,
  author    = {Hofmann, Martin},
  title     = {Syntax and semantics of dependent types},
  booktitle = {Extensional Constructs in Intensional Type Theory},
  pages     = {13--54},
  publisher = {Springer},
  year      = {1997}
}
@article{10.1145/3434341,
author = {Cockx, Jesper and Tabareau, Nicolas and Winterhalter, Th\'{e}o},
title = {The taming of the rew: a type theory with computational assumptions},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434341},
doi = {10.1145/3434341},
abstract = {Dependently typed programming languages and proof assistants such as Agda and Coq rely on computation to automatically simplify expressions during type checking. To overcome the lack of certain programming primitives or logical principles in those systems, it is common to appeal to axioms to postulate their existence. However, one can only postulate the bare existence of an axiom, not its computational behaviour. Instead, users are forced to postulate equality proofs and appeal to them explicitly to simplify expressions, making axioms dramatically more complicated to work with than built-in primitives. On the other hand, the equality reflection rule from extensional type theory solves these problems by collapsing computation and equality, at the cost of having no practical type checking algorithm. This paper introduces Rewriting Type Theory (RTT), a type theory where it is possible to add computational assumptions in the form of rewrite rules. Rewrite rules go beyond the computational capabilities of intensional type theory, but in contrast to extensional type theory, they are applied automatically so type checking does not require input from the user. To ensure type soundness of RTT—as well as effective type checking—we provide a framework where confluence of user-defined rewrite rules can be checked modularly and automatically, and where adding new rewrite rules is guaranteed to preserve subject reduction. The properties of RTT have been formally verified using the MetaCoq framework and an implementation of rewrite rules is already available in the Agda proof assistant.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {60},
numpages = {29},
keywords = {type theory, termination, rewriting theory, dependent types, confluence}
}
@inproceedings{10.1007/978-3-030-33636-3_10,
author = {Chapman, James and Kireev, Roman and Nester, Chad and Wadler, Philip},
title = {System F in Agda, for Fun and Profit},
year = {2019},
isbn = {978-3-030-33635-6},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-030-33636-3_10},
doi = {10.1007/978-3-030-33636-3_10},
abstract = {System F, also known as the polymorphic -calculus, is a typed -calculus independently discovered by the logician Jean-Yves Girard and the computer scientist John Reynolds. We consider , which adds higher-order kinds and iso-recursive types. We present the first complete, intrinsically typed, executable, formalisation of System  that we are aware of. The work is motivated by verifying the core language of a smart contract system based on System . The paper is a literate Agda script [14].},
booktitle = {Mathematics of Program Construction: 13th International Conference, MPC 2019, Porto, Portugal, October 7–9, 2019, Proceedings},
pages = {255–297},
numpages = {43},
location = {Porto, Portugal}
}
@misc{assaf2023deduktilogicalframeworkbased,
      title={Dedukti: a Logical Framework based on the $\lambda$$\Pi$-Calculus Modulo Theory}, 
      author={Ali Assaf and Guillaume Burel and Raphaël Cauderlier and David Delahaye and Gilles Dowek and Catherine Dubois and Frédéric Gilbert and Pierre Halmagrand and Olivier Hermant and Ronan Saillard},
      year={2023},
      eprint={2311.07185},
      archivePrefix={arXiv},
      primaryClass={cs.LO},
      url={https://arxiv.org/abs/2311.07185}, 
}
@article{10.1145/3776704,
author = {Leray, Yann and Winterhalter, Th\'{e}o},
title = {Encode the Cake and Eat It Too: Controlling Computation in Type Theory, Locally},
year = {2026},
issue_date = {January 2026},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {10},
number = {POPL},
url = {https://doi.org/10.1145/3776704},
doi = {10.1145/3776704},
abstract = {Proof assistants based on dependent type theory such as Agda, Lean and Rocq identify objects up to computation during proof checking. This takes away some of the proof burden from the user and even provides a way to get very efficient automation. Recently, Agda and Rocq have been extended to support user-defined computation. While they already prove very useful, user-defined computation rules are *global*: once they are added, they are here to stay. Importing a development that makes use of those rules then means relying on them, whether we want it or not, which can lead to unwanted incompatibilities. We design LRTT, a type theory with support for *local* abstraction over user-defined computation rules. This takes the form of a prenex quantification at the definition level. This quantification is supplemented with the possibility to provide one or several instantiations that verify the equations definitionally. We show that a procedure inlining definitions abstracting over definitional equality is possible, in the style of monomorphisation or of C++ templates. In the process we get a conservativity result over more conventional Martin-L\"{o}f type theories. There are several benefits to such a system. First, it provides encapsulation for user-defined computation rules, which is important to avoid unwanted bad interactions and limits the scope in which invariants of type theory (such as termination, confluence, type preservation and consistency) are broken. Second, abstraction lets users factorise code that crucially relies on definitional equality, as well as hide implementation details that are irrelevant in some settings. Finally, it gives a way to encode certain features without paying the price of the encoding. We showcase such examples in a prototype implementation as an extension of the Rocq Prover. Additionally, all the results in this have been formalised in Rocq.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {62},
numpages = {30},
keywords = {computation, dependent type theory, extensibility, interactive theorem proving, proof assistants, rewriting}
}
@inproceedings{10.1145/3678000.3678201,
author = {Saffrich, Hannes and Thiemann, Peter and Weidner, Marius},
title = {Intrinsically Typed Syntax, a Logical Relation, and the Scourge of the Transfer Lemma},
year = {2024},
isbn = {9798400711039},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3678000.3678201},
doi = {10.1145/3678000.3678201},
abstract = {Intrinsically typed syntax is an important and popular method for mechanized reasoning about programming languages. We explore the limits of this method in the setting of finitely-stratified System F using the Agda proof assistant. This system supports elegant definitions of denotational semantics as well as big-step operational semantics based on intrinsically typed syntax. While its syntactic metatheory (i.e., type soundness) works well, we demonstrate that its semantic metatheory poses technical challenges, by defining a logical relation and proving its fundamental lemma. Our logical relation connects a denotational semantics with an operational one, which exposes issues with transfer lemmas as well as minor issues with universe polymorphism.},
booktitle = {Proceedings of the 9th ACM SIGPLAN International Workshop on Type-Driven Development},
pages = {2–15},
numpages = {14},
keywords = {Agda, denotational semantics, finitely-stratified System F, mechanized metatheory, operational semantics},
location = {Milan, Italy},
series = {TyDe 2024}
}
@article{Shintani_2024,
   title={Compositional Confluence Criteria},
   volume={Volume 20, Issue 1},
   ISSN={1860-5974},
   url={http://dx.doi.org/10.46298/lmcs-20(1:6)2024},
   DOI={10.46298/lmcs-20(1:6)2024},
   journal={Logical Methods in Computer Science},
   publisher={Centre pour la Communication Scientifique Directe (CCSD)},
   author={Shintani, Kiraku and Hirokawa, Nao},
   year={2024},
   month=jan }
@InProceedings{cockx:LIPIcs.TYPES.2019.2,
  author =	{Cockx, Jesper},
  title =	{{Type Theory Unchained: Extending Agda with Userined Rewrite Rules}},
  booktitle =	{25th International Conference on Types for Proofs and Programs (TYPES 2019)},
  pages =	{2:1--2:27},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-158-0},
  ISSN =	{1868-8969},
  year =	{2020},
  volume =	{175},
  editor =	{Bezem, Marc and Mahboubi, Assia},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.TYPES.2019.2},
  URN =		{urn:nbn:de:0030-drops-130666},
  doi =		{10.4230/LIPIcs.TYPES.2019.2},
  annote =	{Keywords: Dependent types, Proof assistants, Rewrite rules, Higher-order rewriting, Agda}
}
@article{siek2021parameterized, 
  title={Parameterized cast calculi and reusable meta-theory for gradually typed lambda calculi}, 
  volume={31}, 
  DOI={10.1017/S0956796821000241}, 
  journal={Journal of Functional Programming}, 
  author={Siek, Jeremy G. and Chen, Tianyu}, 
  year={2021}, 
  pages={e30}
}
@InProceedings{saffrich:LIPIcs.ITP.2024.32,
  author =	{Saffrich, Hannes},
  title =	{{Abstractions for Multi-Sorted Substitutions}},
  booktitle =	{15th International Conference on Interactive Theorem Proving (ITP 2024)},
  pages =	{32:1--32:19},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-337-9},
  ISSN =	{1868-8969},
  year =	{2024},
  volume =	{309},
  editor =	{Bertot, Yves and Kutsia, Temur and Norrish, Michael},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2024.32},
  URN =		{urn:nbn:de:0030-drops-207609},
  doi =		{10.4230/LIPIcs.ITP.2024.32},
  annote =	{Keywords: Agda, Metatheory, Framework}
}
@inproceedings{10.1145/3293880.3294101,
  author = {Stark, Kathrin and Sch\"{a}fer, Steven and Kaiser, Jonas},
  title = {Autosubst 2: reasoning with multi-sorted de Bruijn terms and vector substitutions},
  year = {2019},
  isbn = {9781450362221},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3293880.3294101},
  doi = {10.1145/3293880.3294101},
  pages = {166–180},
  numpages = {15},
  keywords = {sigma-calculus, parallel substiutions, multi-sorted terms, de Bruijn repersentation},
  location = {Cascais, Portugal},
  series = {CPP 2019}
}
@phdthesis{Stark:2020:Mechanising,
  author       = {Kathrin Stark},
  title        = {Mechanising Syntax with Binders in {Coq}},
  school       = {Saarland University},
  address      = {Saarbrücken, Germany},
  year         = {2020},
  month        = {January},
  pages        = {206},
  note         = {Dissertation zur Erlangung des Grades des Doktors der Ingenieurwissenschaften (Dr.-Ing.)},
  url={https://www.ps.uni-saarland.de/Publications/documents/Stark_2020_Mechanising.pdf}
}
@inproceedings{10.1007/11532231_4,
  author = {Urban, Christian and Tasson, Christine},
  title = {Nominal techniques in Isabelle/HOL},
  year = {2005},
  isbn = {3540280057},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  url = {https://doi.org/10.1007/11532231_4},
  doi = {10.1007/11532231_4},
  booktitle = {Proceedings of the 20th International Conference on Automated Deduction},
  pages = {38–53},
  numpages = {16},
  keywords = {lambda-calculus, nominal logic, structural induction, theorem-assistants},
  location = {Tallinn, Estonia},
  series = {CADE' 20}
}
@InProceedings{10.1007/3-540-06859-7_148,
author="Reynolds, John C.",
editor="Robinet, B.",
title="Towards a theory of type structure",
booktitle="Programming Symposium",
year="1974",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="408--425",
isbn="978-3-540-37819-8",
url={https://www.cs.cmu.edu/afs/cs/user/jcr/ftp/theotypestr.pdf}
}
@article{Wood_2021,
   title={A Linear Algebra Approach to Linear Metatheory},
   volume={353},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.353.10},
   DOI={10.4204/eptcs.353.10},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Wood, James and Atkey, Robert},
   year={2021},
   month=dec, pages={195–212} }

@article{2021, 
  volume={353},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.353},
   DOI={10.4204/eptcs.353},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   year={2021},
   month=dec }
@misc{allais2021typescopesafeuniverse,
  title={A Type and Scope Safe Universe of Syntaxes with Binding: Their Semantics and Proofs}, 
  author={Guillaume Allais and Robert Atkey and James Chapman and Conor McBride and James McKinna},
  year={2021},
  eprint={2001.11001},
  archivePrefix={arXiv},
  primaryClass={cs.PL},
  url={https://arxiv.org/abs/2001.11001}, 
}
@article{stronglytyped,
  author = {Benton, Nick and Hur, Chung-Kil and Kennedy, Andrew and McBride, Conor},
  year = {2012},
  month = {08},
  pages = {1-19},
  title = {Strongly Typed Term Representations in Coq},
  volume = {49},
  journal = {Journal of Automated Reasoning - JAR},
  doi = {10.1007/s10817-011-9219-0}
}
@unpublished{ren-sub,
  author       = {Conor McBride},
  title        = {Type-preserving renaming and substitution},
  note         = {Unpublished manuscript},
  year         = {2005},
  url          = {http://strictlypositive.org/ren-sub.pdf},
  howpublished = {\url{http://strictlypositive.org/ren-sub.pdf}}
}
@inproceedings{altenkirch2025substitution,
  author       = {Altenkirch, Thorsten and Burke, Nathaniel and Wadler, Philip},
  title        = {Substitution without copy and paste},
  booktitle    = {Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP\,25)},
  year         = {2025},
  date         = {2025-07-19},
  address      = {Birmingham, UK},
  howpublished = {\url{https://nottingham-repository.worktribe.com/output/51884690/substitution-without-copy-and-paste}}
}
@article{Wadler_2024,
   title={Explicit Weakening},
   volume={413},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.413.2},
   DOI={10.4204/eptcs.413.2},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Wadler, Philip},
   year={2024},
   month=nov, pages={15–26} }

@inproceedings{10.1145/2535838.2535856,
author = {Eisenberg, Richard A. and Vytiniotis, Dimitrios and Peyton Jones, Simon and Weirich, Stephanie},
title = {Closed type families with overlapping equations},
year = {2014},
isbn = {9781450325448},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2535838.2535856},
doi = {10.1145/2535838.2535856},
abstract = {Open, type-level functions are a recent innovation in Haskell that move Haskell towards the expressiveness of dependent types, while retaining the look and feel of a practical programming language. This paper shows how to increase expressiveness still further, by adding closed type functions whose equations may overlap, and may have non-linear patterns over an open type universe. Although practically useful and simple to implement, these features go beyond conventional dependent type theory in some respects, and have a subtle metatheory.},
booktitle = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {671–683},
numpages = {13},
keywords = {haskell, system fc, type families, type-level computation},
location = {San Diego, California, USA},
series = {POPL '14}
}

@article{10.1145/2578855.2535856,
author = {Eisenberg, Richard A. and Vytiniotis, Dimitrios and Peyton Jones, Simon and Weirich, Stephanie},
title = {Closed type families with overlapping equations},
year = {2014},
issue_date = {January 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2578855.2535856},
doi = {10.1145/2578855.2535856},
abstract = {Open, type-level functions are a recent innovation in Haskell that move Haskell towards the expressiveness of dependent types, while retaining the look and feel of a practical programming language. This paper shows how to increase expressiveness still further, by adding closed type functions whose equations may overlap, and may have non-linear patterns over an open type universe. Although practically useful and simple to implement, these features go beyond conventional dependent type theory in some respects, and have a subtle metatheory.},
journal = {SIGPLAN Not.},
month = jan,
pages = {671–683},
numpages = {13},
keywords = {haskell, system fc, type families, type-level computation}
}

@inproceedings{10.1145/3018610.3018613,
author = {Allais, Guillaume and Chapman, James and McBride, Conor and McKinna, James},
title = {Type-and-scope safe programs and their proofs},
year = {2017},
isbn = {9781450347051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3018610.3018613},
doi = {10.1145/3018610.3018613},
abstract = {We abstract the common type-and-scope safe structure from computations on λ-terms that deliver, e.g., renaming, substitution, evaluation, CPS-transformation, and printing with a name supply. By exposing this structure, we can prove generic simulation and fusion lemmas relating operations built this way. This work has been fully formalised in Agda.},
booktitle = {Proceedings of the 6th ACM SIGPLAN Conference on Certified Programs and Proofs},
pages = {195–207},
numpages = {13},
keywords = {Agda, Generic Programming, Lambda-calculus, Mechanized Meta-Theory, Normalisation by Evaluation, Semantics},
location = {Paris, France},
series = {CPP 2017}
}
@inproceedings{10.1145/3018610.3018613,
author = {Allais, Guillaume and Chapman, James and McBride, Conor and McKinna, James},
title = {Type-and-scope safe programs and their proofs},
year = {2017},
isbn = {9781450347051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3018610.3018613},
doi = {10.1145/3018610.3018613},
abstract = {We abstract the common type-and-scope safe structure from computations on λ-terms that deliver, e.g., renaming, substitution, evaluation, CPS-transformation, and printing with a name supply. By exposing this structure, we can prove generic simulation and fusion lemmas relating operations built this way. This work has been fully formalised in Agda.},
booktitle = {Proceedings of the 6th ACM SIGPLAN Conference on Certified Programs and Proofs},
pages = {195–207},
numpages = {13},
keywords = {Semantics, Normalisation by Evaluation, Mechanized Meta-Theory, Lambda-calculus, Generic Programming, Agda},
location = {Paris, France},
series = {CPP 2017}
}

@InProceedings{10.1007/11617990_1,
author="Adams, Robin",
editor="Filli{\^a}tre, Jean-Christophe
and Paulin-Mohring, Christine
and Werner, Benjamin",
title="Formalized Metatheory with Terms Represented by an Indexed Family of Types",
booktitle="Types for Proofs and Programs",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--16",
abstract="It is possible to represent the terms of a syntax with binding constructors by a family of types, indexed by the free variables that may occur. This approach has been used several times for the study of syntax and substitution, but never for the formalization of the metatheory of a typing system. We describe a recent formalization of the metatheory of Pure Type Systems in Coq as an example of such a formalization. In general, careful thought is required as to how each definition and theorem should be stated, usually in an unfamiliar `big-step' form; but, once the correct form has been found, the proofs are very elegant and direct.",
isbn="978-3-540-31429-5",
url = {https://link.springer.com/chapter/10.1007/11617990_1},
}
@inproceedings{10.1145/96709.96712,
  author = {Abadi, M. and Cardelli, L. and Curien, P.-L. and Levy, J.-J.},
  title = {Explicit substitutions},
  year = {1989},
  isbn = {0897913434},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/96709.96712},
  doi = {10.1145/96709.96712},
  booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages = {31–46},
  numpages = {16},
  location = {San Francisco, California, USA},
  series = {POPL '90}
}
@InProceedings{schafer2015autosubst,
author="Sch{\"a}fer, Steven
and Tebbi, Tobias
and Smolka, Gert",
editor="Urban, Christian
and Zhang, Xingyuan",
title="Autosubst: Reasoning with de Bruijn Terms and Parallel Substitutions",
booktitle="Interactive Theorem Proving",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="359--374",
abstract="Reasoning about syntax with binders plays an essential role in the formalization of the metatheory of programming languages. While the intricacies of binders can be ignored in paper proofs, formalizations involving binders tend to be heavyweight. We present a discipline for syntax with binders based on de Bruijn terms and parallel substitutions, with a decision procedure covering all assumption-free equational substitution lemmas. The approach is implemented in the Coq library Autosubst, which additionally derives substitution operations and proofs of substitution lemmas for custom term types. We demonstrate the effectiveness of the approach with several case studies, including part A of the POPLmark challenge.",
isbn="978-3-319-22102-1",
url={https://www.ps.uni-saarland.de/Publications/documents/SchaeferEtAl_2015_Autosubst_-Reasoning.pdf},
}
@inproceedings{10.1145/2676724.2693163,
author = {Sch\"{a}fer, Steven and Smolka, Gert and Tebbi, Tobias},
  title = {Completeness and Decidability of de Bruijn Substitution Algebra in Coq},
  year = {2015},
  isbn = {9781450332965},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2676724.2693163},
  doi = {10.1145/2676724.2693163},
  booktitle = {Proceedings of the 2015 Conference on Certified Programs and Proofs},
  pages = {67–73},
  numpages = {7},
  keywords = {finite axiomatization, explicit substitutions, decision procedures, de bruijn terms, coq, completeness, algebra},
  location = {Mumbai, India},
  series = {CPP '15}
}
@article{10.1145/226643.226675,
  author = {Curien, Pierre-Louis and Hardin, Th\'{e}r\`{e}se and L\'{e}vy, Jean-Jacques},
  title = {Confluence properties of weak and strong calculi of explicit substitutions},
  year = {1996},
  issue_date = {March 1996},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {43},
  number = {2},
  issn = {0004-5411},
  url = {https://doi.org/10.1145/226643.226675},
  doi = {10.1145/226643.226675},
  journal = {J. ACM},
  month = mar,
  pages = {362–397},
  numpages = {36},
  keywords = {confluency, explicit substitutions}
}
@phdthesis{girard1972,
  author       = {Jean-Yves Girard},
  title        = {Interprétation fonctionnelle et élimination des coupures de l’arithmétique d’ordre supérieur},
  school       = {Éditeur inconnu},
  year         = {1972},
  type         = {PhD thesis},
  language     = {french},
  url          = {https://www.cs.cmu.edu/~kw/scans/girard72thesis.pdf}
}
@article{CARDELLI19944,
title = {An Extension of System F with Subtyping},
journal = {Information and Computation},
volume = {109},
number = {1},
pages = {4-56},
year = {1994},
issn = {0890-5401},
doi = {https://doi.org/10.1006/inco.1994.1013},
url = {https://www.sciencedirect.com/science/article/pii/S0890540184710133},
author = {L. Cardelli and S. Martini and J.C. Mitchell and A. Scedrov},
}⏎
# MLTT 
@book{martinlof1984,
  author    = {Per Martin-L{\"o}f},
  title     = {Intuitionistic Type Theory},
  year      = {1984},
  publisher = {Bibliopolis},
  address   = {Naples},
  note      = {Notes by Giovanni Sambin of a series of lectures given in Padua, June 1980}
}