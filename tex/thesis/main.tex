\documentclass[screen,nonacm]{acmart}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{microtype}
\usepackage{agda}

\input{unicodeletters}
\input{agdamacros}
\input{agda-generated}
\input{agda-generated-examples}

\definecolor{agdablue}{HTML}{0000CD}
\DisableLigatures[-]{encoding=T1}
\newcommand{\bsym}[1]{\textcolor{agdablue}{#1}}
\newcommand{\tdot}{\mkern2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern1mu}


\begin{document}

\title{Automated Reasoning over Scoped Syntaxes with Binding in Agda}

\author{Marius Weidner}
\email{weidner@cs.uni-freiburg.de}
\affiliation{%
      \institution{University of Freiburg}
      \country{Germany}}
\orcid{0009-0008-1152-165X} % chktex 8
% TODO: remove for anonymous review
\authornote{
      This is a copy submitted as my Master’s thesis in Computer Science at the University of Freiburg.\\The first examiner is Prof. Dr. Peter Thiemann, and the second examiner is Prof. Dr. Andreas Podelski.\\My matriculation number is 4933008. The thesis was written between 2025-04-09 and 2025-09-08.\\
      I hereby declare that I am the sole author and composer of my thesis and that
      no other sources or learning aids, other than those listed, have been used.\\
      Furthermore, I declare that I have acknowledged the work of others by providing
      detailed references of said work.\\
      I hereby also declare that my thesis has not been prepared for another
      examination or assignment, either wholly or excerpts thereof.
      \\
      \\
      \noindent\begin{tabular}{p{\textwidth/2} l}
            Freiburg, 08.09.2025       & \includegraphics[width=0.15\textwidth]{signature.png} \\
            \rule{\textwidth/3}{0.4pt} & \rule{\textwidth/3}{0.4pt}                            \\
            Place, Date                & Signature
      \end{tabular}
}

\begin{abstract}

      Mechanizing the metatheory of programming languages in proof assistants
      inevitably involves recurring challenges related to variable binding and
      substitution. Each formalization requires proving standard substitution lemmas,
      such as those characterizing the behavior of composition and the interaction of
      substitutions with binders.

      Historically, substitution has been treated as an meta-level operation. To
      formalize this, explicit substitution calculi were introduced to bring
      substitutions down to a syntactic level. The $σ$-calculus provides syntactic
      reduction rules for terms and substitutions, ensuring confluence and strong
      normalization, thereby enabling equations between them to be solved by
      comparing their normal forms. By applying the reduction rules until a normal
      form is reached, we obtain an automatic procedure that eliminates the need for
      manually choosing the correct substitution lemmas.

      To apply this automatic procedure within Agda proofs, the $σ$-calculus rules
      can be registered as native reduction rules using Agda’s rewrite mechanism.
      Embedding the $σ$-calculus rules as reduction rules in Agda is challenging
      because it requires precise control over the reduction behavior of definitions,
      substitutions must be defined structurally in terms of renamings, and multiple
      variable sorts must be supported. We address the latter by adapting the
      $σ$-calculus to intrinsically scoped and multi-sorted syntax. We first treat
      renamings and substitutions separately, and then present a uniform treatment
      that allows results about both to be proven once, avoiding duplication. In both
      cases, thanks to the $σ$-calculus laws embedded as rewrite rules, equations are
      solved automatically by reduction, yielding definitional equalities in cases
      where substitution lemmas would otherwise need to be applied manually.
\end{abstract}

\maketitle

\section{Introduction}\label{sec:introduction}
Mechanizing the metatheory of programming languages in proof assistants
inevitably involves recurring challenges related to variable binding and
substitution. While such details are usually ignored in pen-and-paper proofs,
their mechanization in proof assistants requires precise definitions and a
significant amount of manual effort.

Historically, substitution has been treated as an meta-level operation. To
formalize substitutions, explicit substitution
calculi~\cite{10.1145/96709.96712} were introduced to bring substitutions down
to a syntactic level. These calculi define substitution behavior through a set
of reduction rules. With the $σ$-calculus, a terminating,
confluent~\cite{10.1145/226643.226675} and
complete~\cite{10.1145/2676724.2693163} rewrite system for $λ$-calculus terms
with substitution has been discovered. Repeatedly applying the rules
left-to-right yields a normal form, which can then be compared for equality.

The $σ$-calculus laws can be generalized to custom syntaxes without much
difficulty. Consequently, it is possible to use the $σ$-calculus laws in proof
assistants to automatically generate proofs for equations in which only
syntactic expressions and substitutions appear. The creators of
\textsc{Autosubst}~\cite{schafer2015autosubst} were the first to realize this
opportunity and provided a tactic that applies the $σ$-calculus rules to solve
goals in Rocq (formerly Coq). \textsc{Autosubst
      2}~\cite{10.1145/3293880.3294101} improves on its predecessor by addressing
three fundamental limitations.

First, \textsc{Autosubst} originally only supported unscoped syntax. In Rocq,
it is possible define intrinsically scoped syntax, represented as a set of
terms indexed by their free variables. Variables are restricted to de Bruijn
indices smaller than the index that represents the number of free variables.
Hence, every syntax tree built in this style is well-scoped by construction.
\textsc{Autosubst 2} supports intrinsically scoped syntaxes directly.

Second, combining several syntactic categories that have variables can cause a
combinatorial explosion of near-identical substitution definitions and lemmas.
To address the combinatorial explosion problem, \textsc{Autosubst 2} introduces
vector substitutions, which bundle substitutions over different variable sorts
into a single structure.

Third, in a proof assistant setting, it is necessary to distinguish between
renamings, substitutions mapping variables to variables, and general
substitutions, which map variables to terms, in order to obtain structurally
recursive definitions~\cite{10.1007/11617990_1}. The developers of
\textsc{Autosubst 2} recognized that maintaining the separation in full
generality is useful, as there are situations where reasoning about renamings
alone is required. To accommodate this, they extended \textsc{Autosubst} with
first-class renamings, effectively duplicating the substitution infrastructure
to handle renamings independently.

In Agda, there are several options for defining syntax: extrinsically scoped
and typed syntax, intrinsically scoped but extrinsically typed syntax, and
intrinsically scoped and typed syntax. We argue that the intrinsically scoped
but extrinsically typed approach represents the sweet spot between the two
extremes. In contrast to intrinsically typed syntax, scoped syntax allows all
syntactic categories to be combined into a single multi-sorted and scoped data
type, indexed not only by its free variables, but also by the syntactic
categories. Using a multi-sorted and scoped syntax avoids the combinatorial
explosion and the need for vector substitutions, as substitution can be defined
uniformly across all sorts.

Adapting the $σ$-calculus with first-class renamings to a setting with
multi-sorted, scoped syntax is straightforward. In particular, Agda’s rewrite
mechanism~\cite{10.1145/3434341} allows the $σ$-calculus laws to be registered
as native reduction rules, yielding definitional equalities where otherwise
explicit application of substitution lemmas would be required.

Unfortunately, the need for renamings causes duplication. Lemmas, such as
substitution-preserves-typing, must be proven twice, once for renamings and
once for substitutions, with the latter relying on the former. To mitigate the
duplication issue, we build on the notion of Kits~\cite{ren-sub}, a structure
that captures the behavior common to both variables and terms, originally
developed in an intrinsically typed setting and later extended to multi-sorted,
scoped syntax~\cite{saffrich:LIPIcs.ITP.2024.32}. From Kits, we can define
Maps, a uniform structure for renamings and substitutions. Our work adapts the
$σ$-calculus laws to Kits and Maps over multi-sorted and scoped syntax,
treating renamings and substitutions uniformly and shows how to embed them as
reduction rules into Agda via its rewrite mechanism. The resulting framework
constitutes the first version of the \textsc{Agdasubst} library.

\subsection*{Structure}
The paper is organized into several sections.\ \cref{sec:pre} introduces the
theoretical background and tools. In \cref{sec:rel}, we discusses closely
related work and outline our contributions more precisely.\ \cref{sec:mis}
presents an embedding of the $σ$-calculus as native reduction rules into Agda
for multi-sorted, scoped syntax, treating renamings and substitutions
separately.\ \cref{sec:ags} explains the internals of the \textsc{Agdasubst}
library, where renamings and substitutions can be treated uniformly.\
\cref{sec:ext} illustrates the use of the library through case studies.
Finally, we outline directions for future work in \cref{sec:wrk}, discuss
related work in \cref{sec:rwk} and conclude the paper in \cref{sec:con}.

\subsection*{Contributions}
The main contributions of this work are
\begin{itemize}
      \item an embedding of the $σ$-calculus with first-class renamings into Agda, in a
            scoped and multi-sorted setting, using rewrite rules, exemplified with System~F
            (\cref{sec:mis});
      \item a novel version of the $σ$-calculus, formulating the $σ$-calculus laws in a
            Kit- and Map-based setting, where we effectively lift the distinction between
            variables and terms, as well as between renamings and substitutions, from the
            syntactic to the type level. The new laws form the core of the
            \textsc{Agdasubst} library. (\cref{sec:ags}).
\end{itemize}

\noindent\textbf{The supplement contains the complete Agda code underlying this paper.}
% TODO: remove for anonymous review
\footnote{The supplement is available online:
      \href{https://github.com/Mari-W/Agdasubst}{Link to supplement on GitHub}}

\section{Preliminaries}\label{sec:pre}
This section introduces the concepts and tools required for the developments in
this work. We summarize
\begin{itemize}
      \item Agda and language features relevant to our work: instance arguments, rewrite
            rules and opaque blocks;
      \item The $σ$-calculus;
      \item Multi-sorted and scoped syntaxes in Agda.
\end{itemize}

\subsection{Agda and Relevant Language Features}\label{sec:pre-agd}
Agda is a dependently typed programming language and proof assistant based on
Martin-Löf type theory~\cite{MARTINLOF197573}. It enables users to write
programs and proofs in a functional programming language, verifying correctness
through type checking.

Proofs in Agda become substantially easier when the relevant terms are
definitionally equal. To decide whether two terms are definitionally equal,
Agda computes their weak head normal forms. A propositional equality proof
\AgdaBound{a} \AgdaDatatype{≡} \AgdaBound{b} between two definitionally equal
terms \AgdaBound{a} and \AgdaBound{b} can then be established using the
\AgdaInductiveConstructor{refl} constructor. If two terms are not
definitionally equal, the user must resort to manual equational reasoning,
typically by pattern matching and explicit application of lemmas. This is
cumbersome, as Agda usually lacks tactics that automatically discharge proof
obligations using existing lemmas. Increasing the number of definitional
equalities between terms therefore greatly simplifies proofs and reduces manual
effort.

In addition to its well-known features such as parameterized and indexed
inductive datatypes, dependent (co-) pattern matching~\cite{10.1145/3236770},
implicit arguments and records, Agda supports three less commonly used but
important features relevant to this work.

\subsection*{Instance Arguments}
Instance arguments, written inside double braces \AgdaSymbol{\{\{\dots\}\}},
are resolved automatically via an instance search algorithm. When a function
expects an instance argument, Agda attempts to infer and insert it from values
marked with the \AgdaKeyword{instance} keyword. This mechanism enables
type-directed programming patterns similar to type classes in
Haskell~\cite{10.1145/75277.75283}. As an example, consider the following
definition of a record for types with a default value: \EDefault{}We can bring
the \AgdaField{default} field into scope using the \AgdaKeyword{open} \dots
\AgdaSymbol{\{\{\dots\}\}} syntax and instruct Agda to automatically resolve
suitable record instances for occurrences of this field via instance search:
\EDefFields{}At this point, instances for different types may be declared:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefInst{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefInstS{}
\end{minipage}

\noindent The two instances allow implicit usage of the default values for natural numbers and strings via instance search, through the \AgdaField{default} field:

\noindent \begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefEx{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefExS{}
\end{minipage}

\noindent On the left side, Agda infers from the type \AgdaDatatype{ℕ} of \AgdaNumber{0} that the
instance \AgdaFunction{default–ℕ} applies for \AgdaFunction{default},
automatically inserting it to conclude that the equation holds definitionally.
The same reasoning applies to the equality on the right side, involving the empty string.

\subsection*{Rewrite Rules}
In this work, the most important feature of Agda is user-defined rewrite
rules~\cite{10.1145/3434341, cockx:LIPIcs.TYPES.2019.2}, which extend Agda's
computation rules by integrating propositional equalities as reduction rules
directly into type checking. A function definition in Agda can be registered as
a rewrite rule if it is of the form
\[
      \AgdaFunction{eq} : (x_1 : A_1)\, \ldots\, (x_k : A_k) \to \AgdaFunction{f}\, p_1\, \ldots\, p_n \; \AgdaFunction{≡} \; v
\]
and satisfies the following three conditions:
\begin{enumerate}
      \item The head symbol \AgdaFunction{f} must be a postulate, a defined function, or a
            constructor applied to fully general type parameters (i.e.\ the type parameters
            must be distinct variables)
      \item Each variable $x_1, \ldots, x_k$ must occur at least once in a pattern position
            among $p_1, \ldots, p_n$\footnote{The Agda documentation includes a precise
                  definition for pattern positions:
                  \href{https://agda.readthedocs.io/en/latest/language/rewriting.html}{Link to
                        Agda Documentation}}.
      \item The left side $\AgdaFunction{f}\, p_1\, \ldots\, p_n$ must be neutral, i.e., it
            should not reduce any further using existing definitions.
\end{enumerate}

\noindent As an example, consider the right identity law for addition: \ERewrite{}The
lemma satisfies the three required conditions. It is a defined function symbol
that does not reduce, as addition is defined via structural induction on the
left argument, and all bound variables occur on the left side of the equation. We
can now register it as a rewrite rule using the rewrite pragma:
\ERewriteIt{}From this point on, Agda treats \AgdaBound{n} \AgdaFunction{+}
\AgdaNumber{0} as definitionally equal to \AgdaBound{n}: \ERewriteEx{}To
maintain consistency, Agda requires that all rewrite rules satisfy the three
conditions stated above, and that the combined set of rewrite rules is both terminating
and confluent. Termination is currently not checked by Agda, it is only
observable indirectly when type checking fails to terminate. Confluence can be
checked using the \texttt{--local-confluence-check} and
\texttt{--confluence-check} flags, but both checks are necessarily
conservative.

\subsection*{Opaque Blocks}
Agda supports opaque definitions~\cite{gratzer2022controlling}, which treat
selected parts of the code as non-unfolding symbols. Normally, Agda unfolds all
definitions automatically to produce as many definitional equalities as
possible. While this behavior is desirable in most cases, we will require
certain definitions to remain blocked, so that rewrite rules apply predictably
to these symbols. In later opaque blocks, the type checker can be instructed to
unfold previously blocked definitions, ensuring that their behavior remains
accessible when needed.

A block is marked as opaque by preceding it with the \AgdaKeyword{opaque}
keyword. All definitions within the block become opaque, while their names and
types remain visible and usable throughout the code: \EOpaque{}In this case,
\AgdaFunction{forty-two} is defined as the numeral \AgdaNumber{42}, but outside
the block it is treated abstractly. This means that although
\AgdaFunction{forty-two} still has type \AgdaDatatype{ℕ} and can be used in
expressions and proofs, it does not reduce to \AgdaNumber{42} during
definitional equality checks:\EOpaqueExO{}Using \AgdaKeyword{unfolding} reduces
the definition to \AgdaNumber{42} again, as expected: \EOpaqueExT{}

\subsection{The Sigma Calculus}\label{sec:pre-sig}
\begin{figure}[t]
      \centering
      \small
      {\raggedright{} \textbf{\Large Symbols} \par}
      \vspace{1.5em}

      \begin{minipage}[t]{0.48\textwidth}
            \raggedright{}
            \textbf{Variables} $x$
            \begin{align*}
                  \text{innermost variable} \quad & \textcolor{agdablue}{\mathsf{zero}}    \\
                  \text{outer variables} \quad    & \textcolor{agdablue}{\mathsf{suc}}\; x
            \end{align*}\\
            \vspace{1em}
            \textbf{Terms} $t$
            \begin{align*}
                  \text{variable usage} \quad           & \textcolor{agdablue}{\texttt{\`{}}}x \\
                  \text{abstraction} \quad              & \textcolor{agdablue}{λ.}\, t         \\
                  \text{application} \quad              & t_1 \ t_2                            \\
                  \text{substitution lookup} \quad      & x \textcolor{agdablue}{\;\&\;} σ     \\
                  \text{substitution application} \quad & t \tdot{} σ
            \end{align*}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright{}
            \textbf{Substitutions} $σ$
            \begin{align*}
                  \text{identity} \quad    & \textcolor{agdablue}{\mathsf{id}}                                                                           \\
                  \text{extension} \quad   & t \textcolor{agdablue}{\cdot} σ                                                                             \\
                  \text{composition} \quad & σ_1 \ \textcolor{agdablue}{;} \  σ_2                                                                        \\
                  \text{weakening} \quad   & \textcolor{agdablue}{\mathsf{wk}}                                                                           \\
                  \text{lifting} \quad     & \textcolor{agdablue}{\uparrow}σ ≐ ((\textcolor{agdablue}{\texttt{\`{}}}\textcolor{agdablue}{\mathsf{zero}})
                  \textcolor{agdablue}{\cdot} (σ \ \textcolor{agdablue}{;} \
                  \textcolor{agdablue}{\mathsf{wk}}))
            \end{align*}
      \end{minipage}

      {\raggedright{} \vspace{2.0em} \textbf{\Large Reduction} \par}
      \vspace{1.5em}
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright{}
            \textbf{Definitional Laws}
            \begin{alignat*}{2}
                  \mathsf{id}      \quad          & x \textcolor{agdablue}{\;\&\;} \textcolor{agdablue}{\mathsf{id}}                                     &  & = \textcolor{agdablue}{\texttt{\`{}}} x                                       \\
                  \mathsf{ext}_\mathsf{Z}  \quad  & \textcolor{agdablue}{\mathsf{zero}} \textcolor{agdablue}{\;\&\;} (t \textcolor{agdablue}{\cdot} σ)   &  & = t                                                                           \\
                  \mathsf{ext}_\mathsf{S}   \quad & \textcolor{agdablue}{\mathsf{suc}}\;x \textcolor{agdablue}{\;\&\;} (t \textcolor{agdablue}{\cdot} σ) &  & = x \textcolor{agdablue}{\;\&\;} σ                                            \\
                  \mathsf{comp}    \quad          & x \textcolor{agdablue}{\;\&\;} (σ_1 \ \textcolor{agdablue}{;} \  σ_2)                                &  & = (x \textcolor{agdablue}{\;\&\;} σ_1) \tdot σ_2                              \\
                  \mathsf{wk}      \quad          & x \textcolor{agdablue}{\;\&\;} \textcolor{agdablue}{\mathsf{wk}}                                     &  & = \textcolor{agdablue}{\texttt{\`{}}}(\textcolor{agdablue}{\mathsf{suc}} \ x)
            \end{alignat*}\\
            \vspace{1em}
            \textbf{Traversal Laws}
            \begin{alignat*}{2}
                  \mathsf{var} \quad & (\textcolor{agdablue}{\texttt{\`{}}} x)                                 & \tdot σ
                                     & = x \textcolor{agdablue}{\;\&\;} σ                                                 \\
                  \mathsf{lam} \quad & (\textcolor{agdablue}{λ.}\, t)                                          & \tdot  σ
                                     & = \textcolor{agdablue}{λ.} (t  \tdot (\textcolor{agdablue}{\uparrow}σ))            \\
                  \mathsf{app} \quad & (t_1 \ t_2)                                                             & \tdot σ
                                     & = (t_1  \tdot σ) \ (t_2  \tdot σ)
            \end{alignat*}

      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright{}
            \textbf{Interaction Laws}
            \begin{alignat*}{2}
                  \mathsf{comp\text{-}id}_\mathsf{L} \quad & \textcolor{agdablue}{\mathsf{id}} \ \textcolor{agdablue}{;} \  σ                                                                                                    &  & = σ                                                                                                                                                                                                 \\
                  \mathsf{comp\text{-}id}_\mathsf{R} \quad & σ \ \textcolor{agdablue}{;} \  \textcolor{agdablue}{\mathsf{id}}                                                                                                    &  & = σ                                                                                                                                                                                                 \\
                  \mathsf{associativity}          \quad    & (σ_1 \ \textcolor{agdablue}{;} \  σ_2) \ \textcolor{agdablue}{;} \  σ_3                                                                                             &  & = σ_1 \ \textcolor{agdablue}{;} \  (σ_2 \ \textcolor{agdablue}{;} \  σ_3)                                                                                                                           \\
                  \mathsf{distributivity}           \quad  & (t \textcolor{agdablue}{\cdot} σ_1) \ \textcolor{agdablue}{;} \  σ_2                                                                                                &  & = (t \mkern2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} σ_2) \textcolor{agdablue}{\cdot} (σ_1 \ \textcolor{agdablue}{;} \  σ_2) \\
                  \mathsf{interact}       \quad            & \textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \  (t \textcolor{agdablue}{\cdot} σ)                                                                    &  & = σ                                                                                                                                                                                                 \\
                  \eta\mathsf{\text{-}id}        \quad     & (\textcolor{agdablue}{\texttt{\`{}}\mathsf{zero}}) \textcolor{agdablue}{\cdot} \textcolor{agdablue}{\mathsf{wk}}                                                    &  & = \textcolor{agdablue}{\mathsf{id}}                                                                                                                                                                 \\
                  \eta\mathsf{\text{-}law}       \quad     & (\textcolor{agdablue}{\mathsf{zero}} \textcolor{agdablue}{\;\&\;} σ) \textcolor{agdablue}{\cdot} (\textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \  σ) &  & = σ
            \end{alignat*}\\
            \vspace{1em}
            \textbf{Monad Laws}
            \begin{alignat*}{2}
                  \mathsf{right\text{-}id} \quad          & t  \tdot
                  \mathsf{id}                             &           & = t        \\
                  \mathsf{compositionality}         \quad & (t  \tdot
                  σ_1)  \tdot
                  σ_2                                     &           & = t  \tdot
                  (σ_1 \textcolor{agdablue}{;} σ_2)
            \end{alignat*}
      \end{minipage}
      \caption{The three-sorted $σ$-calculus}\label{fig:pre-sig}
\end{figure}

The $\sigma$-calculus~\cite{10.1145/96709.96712}, an explicit substitution
calculus, formalizes the behavior of substitutions through explicit, syntactic
reduction rules. Of particular interest is the
$σ_{SP}$-calculus~\cite{10.1145/2676724.2693163}, an extension of the
$\sigma$-calculus that ensures confluence and forms the theoretical foundation
of \textsc{Autosubst}. The $σ_{SP}$-calculus is sound,
confluent~\cite{10.1145/226643.226675}, and
complete~\cite{10.1145/2676724.2693163}, meaning that any equation involving
terms and substitutions can be correctly proven or disproven by repeated
application of its reduction rules. We present our own three-sorted variant of
the $σ_{SP}$-calculus, instantiated with the $λ$-calculus as the object
language in \cref{fig:pre-sig}.

Our system closely follows the $σ_{SP}$-calculus. The syntax is sorted into
de~Bruijn variables, terms, and parallel substitution primitives. We use
de~Bruijn variables to obtain $α$-equivalence for free. Terms include the
standard $λ$-calculus constructs, extended with the lookup in a substitution
and application of a substitution to terms.

The Substitution primitives allow the construction of parallel substitutions,
which are maps from variables to terms, and support the composition of multiple
such substitutions. Unlike most presentations in the literature, we include
explicit syntax for variable usage within terms. Because of the syntax for
variable usage within terms, we require a distinction between
\bsym{\textsf{suc}} and \bsym{\textsf{wk}} to shift variables by one index,
depending on whether they appear in the sort of variables or substitutions.
Applying a weakening substitution to a term, shifts all variables inside the
term by one index. We also include a shorthand for lifting, which enables a
substitution to be pushed under a binder. A lifted substitution replaces the
bound variable with itself, leaving all occurrences of the variable inside the
body of the binding construct unchanged, while weakening all terms in the
substitution so that they correctly refer to the variables outside the binding
construct.

Inspired by \citet{Stark:2020:Mechanising}, we group the reduction rules into
four categories.
\begin{itemize}
      \item The \textbf{Definitional Laws} describe how variables are looked up in
            substitutions;
      \item \textbf{Interaction Laws} express equalities between substitution expressions;
      \item \textbf{Traversal Laws} describe how substitutions propagate through term syntax and under binders;
      \item \textbf{Monad Laws} describe the behavior of substitutions when applied to
            terms.
\end{itemize}

\noindent We deliberately do not include reduction rules for the $λ$-calculus itself, such as
$β$-reduction, as done for example in the $λσ$-calculus~\cite{10.1145/226643.226675}.
Our focus is not on the reduction of the object language, but on the behavior
of substitutions applied to terms. The reduction strategy of the object
language is part of its definition and is left unspecified.
The only syntax-dependent rules we require are those traversing terms with substitutions.

We believe the three-sorted $σ$-calculus is terminating and confluent. Although
we do not give a formal proof, it is a reasonable variant of the
$σ_{SP}$-calculus. Renamings, needed to define substitutions structurally in
Agda, break completeness of the system, when available as first-class syntactic
constructs~\cite{10.1145/3293880.3294101}. For this reason, we do not consider
completeness a central property in this work. Still, we try to keep the space
of solvable equations as large as possible.

\subsection{Multi-Sorted and Scoped Syntaxes in Agda}\label{sec:pre-syn}
\begin{figure}[t]
      \centering
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \EScoped{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \EMultiSorted{}
      \end{minipage}
      \caption{Classically Scoped Syntax vs. Multi-Sorted and Scoped Syntax}\label{fig:pre-svm}
\end{figure}

Unlike the $λ$-calculus, many programming languages feature multiple syntactic
categories. For instance, System~F~\cite{girard1972, 10.1007/3-540-06859-7_148}
has expressions, types and kinds, with two of the three categories supporting
variables. To avoid scoping-related errors, we aim for syntaxes that enforce
correct scoping intrinsically. An intrinsically scoped syntax definition only
permits the construction of object language terms that are correctly scoped by
construction. In Agda, intrinsically scoped syntax is typically achieved by a
syntax definition as a family of types indexed by the set of free variables.

On the left side of \cref{fig:pre-svm}, we present a standard intrinsically
scoped syntax for System~F. Types are indexed by the number of free type
variables, and expressions are indexed by both the number of free type and
expression variables. Variables are represented using de Bruijn indices of type
\AgdaDatatype{Fin} \AgdaBound{n}, that is, natural numbers strictly less than
the number of free variables. This representation ensures that only well-scoped
terms can be constructed. Technically, the \AgdaDatatype{Kind} type could be
omitted, as all types, in the case of simple System~F, are well-formed by
construction.

This approach is simple but has drawbacks. Types and expressions are separate
datatypes, so we would need to define multiple substitution operations:
type-in-type, expr-in-expr, and type-in-expr. To avoid the combinatorial
explosion of substitution operations, we define a uniform, multi-sorted and
scoped syntax on the right side of \cref{fig:pre-svm}. Terms form a single
datatype indexed by a list of sorts, called \AgdaDatatype{Scope} and ranged
over by \AgdaBound{S}, together with a target sort. A type \AgdaBound{S}
\AgdaDatatype{⊢} \AgdaBound{s} describes a term of sort \AgdaBound{s} with free
variables whose sorts are listed in \AgdaBound{S}. Variable positions are
represented by \AgdaBound{S} \AgdaDatatype{∋} \AgdaBound{s}, a proof that a
variable of sort \AgdaBound{s} appears in \AgdaBound{S}. The proof acts as the
de Bruijn index. Using the unified syntax, we can later define scoped and
multi-sorted renamings and substitutions that operate uniformly across all
sorts.

Due to the similarity in terminology, the above approach might be confused with
Pure Type Systems~\cite{berardi1988towards, 10.1007/3-540-52592-0_53,
      terlouw1989een}, which describe a class of typed lambda calculi parameterized
over a set of sorts, dependencies between these sorts, and rules for permitted
quantifications. The key difference is that, in multi-sorted syntax, sorts
differentiate syntactic categories, keeping terms of different sorts distinct.
In contrast, in Pure Type Systems, sorts act as universe types, such as
\AgdaDatatype{Set} in Agda, and terms of different sorts belong to a single
syntactic category.

\section{Closely Related Work}\label{sec:rel}
Two works are particularly closely related to ours and warrant discussion
upfront. Our work can essentially be seen as a combination of the two.

\subsection{Autosubst}
Most of this work is inspired by the theoretical foundations developed in the
context of the \textsc{Autosubst}~\cite{schafer2015autosubst} library. The
original work makes use of the $σ$-calculus laws to automatically solve
equations between unscoped, uni-sorted terms and substitutions in Rocq.
Version~2~\cite{10.1145/3293880.3294101, Stark:2020:Mechanising} extends the
original work with scoped syntax, first-class renamings and introduces new
rules that connect renamings and substitutions. \textsc{Autosubst 2} uses
vectors to bundle renamings and substitutions over multiple variable sorts and
provides additional laws to support the interactions between vector
substitutions. Because Rocq is tactic-oriented, the library provides tactics to
apply the $σ$-calculus laws to proof obligations. It further supports code
generation of syntax-dependent definitions and laws from a Higher-Order
Abstract Syntax (HOAS) specification.

\subsection{Kits and Maps}
The idea of Kits, structures that abstract over variables and terms and allow
reasoning about both simultaneously, was originally proposed by \citet{ren-sub}
in an intrinsically typed setting. \citet{saffrich:LIPIcs.ITP.2024.32} extended
the Kit concept to scoped syntax, defining a uniform, multi-sorted, and scoped
structure for renamings and substitutions called Maps. Their focus was on
abstractions over typing relations and the semantics of the object language
while maintaining a uniform treatment of renamings and substitutions. The
framework includes a Typing Kit structure, which abstracts over typed renamings
and substitutions with respect to a typing relation. The abstraction enables
proving substitution-preserves-typing using a single uniform lemma over Maps,
eliminating the need to first prove it separately for renamings.

\subsection{Contributions}
We combine the approach of \textsc{Autosubst 2} with abstractions over
multi-sorted, scoped syntax and substitutions.

Before introducing Kits and Maps, we first apply the $σ$-calculus laws to a
scoped syntax setting with first-class renamings, following the approach of
\textsc{Autosubst 2}, but implemented in Agda. Unlike \textsc{Autosubst 2}, we
do not rely on vectors for multiple variable sorts, but instead use parallel,
multi-sorted renamings and substitutions. We avoid tactics and embed the laws
as rewrite rules to produce definitional equalities. For illustration purposes,
we present a version using System~F in \cref{sec:mis}. This version is later
subsumed by the full \textsc{Agdasubst} library in \cref{sec:ags}, which
supports custom syntaxes.

In \textsc{Agdasubst}, we adopt the notions of Kits and Maps, and formulate
$σ$-calculus laws in that setting. Informally, the adapted laws lift the
distinction between variables and terms, as well as between renamings and
substitutions, from the syntactic to the type level, allowing abstraction over
both. For instance, the uniform Typing Kit-based substitution-preserves-typing
lemma of \citet{saffrich:LIPIcs.ITP.2024.32} is substantially simplified, as
our laws integrate seamlessly with this framework, eliminating the need for
manual application of Map lemmas.

\section{The Sigma Calculus with Separate Renamings and Substitutions}\label{sec:mis}
This section presents a direct embedding of the $σ$-calculus rules with
first-class renamings, following the conceptual theory underlying
\textsc{Autosubst 2}, as native reduction rules in Agda using its rewrite
mechanism. We use the multi-sorted and scoped version of SystemF
from~\cref{fig:pre-svm} as an example for any custom syntax. The approach
described in this section directly translates to any multi-sorted and scoped
syntax definition.

\subsection{Scoped and Multi-Sorted Renamings and Substitutions}\label{sec:mis-sub}
\begin{figure}[t]
      \centering
      \small
      \begin{minipage}[t]{0.48\linewidth}
            \small
            \raggedright{}
            \ERen{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth}
            \small
            \raggedright{}
            \ESub{}
      \end{minipage}
      \caption{Scoped and Multi-Sorted Renamings and Substitutions}\label{fig:mis-ras}
\end{figure}

We define renamings (\AgdaFunction{\_→ᴿ\_}) and substitutions
(\AgdaFunction{\_→ˢ\_}) uniformly over all variable sorts by indexing them over
scopes, as shown in \cref{fig:mis-ras}. A renaming from scope \AgdaBound{S₁} to
\AgdaBound{S₂} maps each variable of a given sort in \AgdaBound{S₁} to a
variable of the same sort in \AgdaBound{S₂}. Similarly, substitutions map
variables to terms of the corresponding sort.

We first define the renaming type and its primitive operations: identity
(\AgdaFunction{idᴿ}), weakening (\AgdaFunction{wkᴿ}) and extension
(\AgdaFunction{\_·ᴿ\_}). Substitution primitives mirror those for renamings,
but use the superscript S instead of R, except for weakening, which is strictly
a renaming. The order of definitions is chosen carefully to obtain a
structurally recursive definition. We use the structurally smaller weakening
renaming to define lifting of substitutions (\AgdaFunction{\_↑ˢ\_}).

To support all composition combinations of renamings and substitutions, we
provide four forward composition primitives: renaming composed with renaming
(\AgdaFunction{\_;ᴿᴿ\_}), renaming with substitution
(\AgdaFunction{\_;ᴿˢ\_})\footnote{The first two composition operators can
      technically be merged into a single definition. Both are simply forward
      function composition, but we choose to keep them separated.}, substitution with
renaming (\AgdaFunction{\_;ˢᴿ\_}), and substitution with substitution
(\AgdaFunction{\_;ˢˢ\_}).

The traversal functions (\AgdaFunction{\_⋯ᴿ\_} for renaming and
\AgdaFunction{\_⋯ˢ\_} for substitution) are defined by structural induction on
the syntax. Each clause applies a renaming or substitution to a object language
term, lifting the renaming or substitution, when going under a binder. The
clauses in both definitions correspond directly to the traversal laws of the
$σ$-calculus, and therefore, we want these functions to reduce during type
checking. When adapting this approach to arbitrary custom syntaxes, the
traversal functions are the only definitions that must be provided by the user.
All other definitions can be stated independently of the concrete syntax.

Renaming and substitution primitives are declared opaque, which blocks their
reduction. This abstraction is crucial for rewriting the $σ$-calculus laws,
where the primitives must act as uninterpreted symbols rather than as concrete
functions. Blocking reduction in this way allows rewrite rules to apply
predictably. The types for renamings and substitutions are declared opaque to
prevent their misuse as actual functions. Renamings and substitutions should
not behave as functions, because rewriting cannot be performed on a stuck
function applied to an argument. Instead, we introduce explicit syntax for
function application (\AgdaFunction{\_\&ᴿ\_} and \AgdaFunction{\_\&ˢ\_}) to
allow rewriting on a renaming or substitution applied to a variable.

\subsection{The Sigma Calculus with First-Class Renamings}\label{sec:mis-sig}
\begin{figure}[t]
      \centering

      \begin{minipage}[t]{0.38\linewidth}
            \raggedright{}
            \EDefLaws{}
            \ERewriteSys{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.58\linewidth}
            \raggedright{}
            \EInteractLaws{}
            \EMonadLaws{}
      \end{minipage}
      \caption{The Scoped and Multi-Sorted $σ$-calculus with First-Class Renamings}\label{fig:mis-sig}
\end{figure}

While we could opt to restrict the relevance of renamings to the structural
definition of substitutions and state the laws only for substitutions, it is
often useful to reason about renamings directly, for instance in the context
morphism lemma~\cite{goguen1997candidates}. We therefore, similar to Autosubst,
treat renamings as first-class constructs.\ \cref{fig:mis-sig} presents the
$σ$-calculus laws with first-class renamings. They all satisfy the requirements
from \cref{sec:pre-agd} and qualify as rewrite rules.

The \textbf{Definitional Laws} now involve primitives for both renamings and
substitutions. The \textbf{Interaction Laws} likewise cover all operators. Many
of these laws are similar in shape. For instance, we require eight
associativity laws. The \textbf{Traversal Laws} follow directly from the
definition of traversal given in the previous section.

Most of the laws can be proven independently of the concrete syntax. In
contrast, the \textbf{Monad Laws} must be shown by induction over the syntax
and vary for each object language definition. We highlight syntax-dependent
laws in red throughout this work.

\citet{10.1145/3293880.3294101} noticed that a further category emerges from the interaction between
renamings and substitutions. The \textbf{Coincidence Laws} govern the case where
substitutions are intertwined with renamings, but the renamings can be
separated from them, and applied to a term separately.
The coincidence and the coincidence-fold laws
enable us to recover renamings from their embedding as substitutions via the
identity substitution. Extracting arbitrary renamings from deeply nested substitutions would require a
dedicated solving strategy, which we leave for future work but consider
important for a more complete account.

In her PhD thesis, \citet{Stark:2020:Mechanising} proves the
\AgdaFunction{coincidence} law by induction over the syntax. The law is not
syntax-dependent when composition between renamings and substitutions is
included in the theory and the monad laws are available: \ECoincidenceProof{}
The remaining coincidence laws follow analogously.

The exact influence of coincidence laws on the metatheory of the rule set as a
whole still needs to be examined in detail but it is believed their addition
preserves termination and confluence~\cite{10.1145/3293880.3294101}. Agda
cannot determine that the set of rewrite rules is confluent using its built-in
checks. To make the rules amenable to such analysis, a critical pair analysis
in the spirit of the Knuth-Bendix completion algorithm~\cite{Knuth1983} would
be required to split the rules into components that Agda can recognize as
collectively confluent.

To prove the $σ$-calculus laws presented in \cref{fig:mis-sig}, we need to
unfold the definitions of the renamings and substitutions primitives. Laws
colored blue can be proven syntax-independently, while laws colored in red need
to be proven by structural induction over the syntax. Our implementation, found
in the supplement, makes use of function extensionality, which is safe to
postulate in Agda. It is known that with a little more effort, this assumption
is not necessary.

\subsection{Discussion}\label{sec:mis-dis}
The laws presented in \cref{sec:mis-sig} are an extension of the classic
$σ$-calculus rules to a setting with renamings. They fulfill the requirements
to be registered as rewrite rules without further modification. This is a
consequence of marking the relevant symbols opaque. Inside the proofs of the
laws themselves, the definitions can still unfold when needed, while externally
they behave as uninterpreted symbols and are reduced only by the $σ$-calculus
laws.

The main drawback of the approach with separated renamings and substitutions is
the unavoidable duplication of similar definitions and proofs. Associativity
laws pose little difficulty as they can be stated independently of the syntax,
but the definition of traversal and monad laws must be provided explicitly.
These include two traversal definitions, two right-identity laws, and four
compositionality laws, all similar in shape. Even if syntax-dependent
definitions and laws are derived automatically, every subsequent result about
substitutions would still need to be proven twice, once for renamings and once
for general substitutions.

\section{The Agdasubst Library}\label{sec:ags}
This section introduces the \textsc{Agdasubst} library. It builds on the ideas
from \cref{sec:mis} but removes the strict separation between variables and
terms by the introduction of a construct that can represent either, which we
call Kits. Using Kits, renamings and substitutions can be defined uniformly
through a single notion, called Maps. With Kits and Maps in place, definitions
and proofs from \cref{sec:mis} that were previously similar in shape can now be
unified.

We first recall the relevant definitions from the work of
\citet{saffrich:LIPIcs.ITP.2024.32} in \cref{sec:ags-kit,sec:ags-com}. Most
implementation details of Kits and Maps are omitted, except for those directly
relevant to the $σ$-calculus laws. For a complete account of Kits, Maps, and
their extensions, we refer the reader to \citet{saffrich:LIPIcs.ITP.2024.32}.
We then show how the $σ$-calculus laws can be formulated in the setting of Kits
and Maps and discuss the challenges in doing so. In particular, it is
challenging to formulate the laws, such that they satisfy the requirements to
be registered as rewrite rules.

The library, and the following chapter, abstracts over a set of sorts
\ASortParam, a scoped and multi-sorted syntax \AScopedT, that must have a
variable constructor \AVarCstr.

\subsection{Kits}\label{sec:ags-kit}
A Kit is a structure that abstracts over terms and variables. The intended
usage is to instantiate the Kit structure exactly twice, first for variables
and then for terms. Definitions can be written uniformly, parameterized over a
Kit, and are consequently applicable to both cases.

\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AKit{}
      \AOpenKit{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AModeDef{}
      \AImage{}
\end{minipage}

\noindent To distinguish the two instances of Kits on the type level, Kits are indexed over
a boolean-like structure \AgdaDatatype{Mode}. The \AgdaFunction{image} function computes,
given a fixed \AgdaDatatype{Mode}, whether the Kit corresponds to a variable or
term. The Kit record has multiple fields.
\begin{itemize}
      \item \AgdaField{K-id/‘} converts a variable into a variable or term \AgdaBound{S} \AgdaBound{∋/⊢ᴷ} \AgdaBound{s}.
            For the Variable Kit, \AgdaBound{\_∋/⊢ᴷ\_} is instantiated to \AgdaDatatype{\_∋\_}, so the operation needs to act as the identity.
            For the Term Kit, it is instantiated to \AgdaField{\_⊢\_}, so the operation corresponds to the variable constructor.
      \item \AgdaField{K-‘/id} converts an element of type \AgdaBound{S} \AgdaBound{∋/⊢ᴷ} \AgdaBound{s} into a term of type \AgdaBound{S} \AgdaField{⊢} \AgdaBound{s}, and works analogous to \AgdaField{K-id/‘}.
      \item \AgdaField{K-wk} shifts the de Bruijn indices in a variable or term.
            The newly introduced, unused variable \AgdaInductiveConstructor{zero} can assume any sort \AgdaBound{s′}.
            For variables, \AgdaField{K-wk} corresponds to the successor constructor \AgdaInductiveConstructor{suc}.
            For terms, \AgdaField{K-wk} needs to apply a weakening renaming to the term.
\end{itemize}

\noindent The \AgdaDatatype{Kit} record further includes fields for axioms that constrain
its instantiation. We will not cover these axioms, because for both variables
and reasonable syntaxes, all of them hold almost by definition.

Because rewrite rules cannot mention record fields directly, we provide for
each field, except \AgdaField{K-wk}, a corresponding version without the
\AgdaBound{K}-prefix. These are declared as opaque functions, so they can be
used as symbols in rewrite rules, while still be selectively unfolded to the
actual fields when needed. Going forwards, we assume all opaque definitions
unfolding any time throughout this section. It is only outside the library,
when we have the $σ$-calculus laws in place, when we want definitions to act as
uninterpreted symbols.

We can now define the usual operations for renamings and substitutions. The
definitions are included directly inside the \AgdaDatatype{Kit} record, so they
are implicitly parameterized over a Kit \AgdaBound{K} with Mode \AgdaBound{M}
and can be uniformly stated. All the primitives are marked \AgdaKeyword{opaque}.

\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AMapA{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AMapB{}
\end{minipage}

\noindent The type for Maps \AgdaBound{S₁} \AgdaFunction{→ᴷ} \AgdaBound{S₂} unifies
renamings \AgdaBound{S₁} \AgdaFunction{→ᴿ} \AgdaBound{S₂} and substitutions
\AgdaBound{S₁} \AgdaFunction{→ˢ} \AgdaBound{S₂}. For \AgdaBound{M} specialized
to \AgdaInductiveConstructor{Vᴹ} the \AgdaFunction{image} function computes to
the type of variables and as a result the Map acts as renaming. Similarly, in
the case that \AgdaBound{M} is equal to \AgdaInductiveConstructor{Tᴹ}, the Map
corresponds to a substitution. The identity Map, as well as lookup and
extension operations behave analogously in both the renaming and substitution
cases.

Term traversal is not yet available, because it requires Kits to be defined
first, as traversal is formulated for Maps directly, parameterized by a Kit. At
the same time, traversal is needed to define composition for Maps, because
composing with a substitution on the right relies on traversal, and composition
is in turn required to define lifting: \ALifting{}To break this dependency
cycle, we introduce a generalized weakening operator \AgdaFunction{\_;wk},
which can later be rewritten as an actual composition with the weakening
primitive \AgdaFunction{wk}, which we also define in terms of the generalized
version.

Similarly, once term traversal is available, the \AgdaFunction{id/‘} and
\AgdaFunction{‘/id} operators can be expressed entirely in terms of the
primitive operations. We also provide syntax to refer to Kits explicitly inside
square brackets:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AKitExplicit{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AExpId{}
\end{minipage}

\noindent To define the Term Kit instance, we need to know how a Map is
applied to a term. The user has to provide the Kit-based traversal function and
a proof that applying the identity Map leaves a term unchanged by structural induction over their syntax:
\ATraversal{}Equipped with the traversal function we can define the two
intended instances for Kits:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AInstanceRen{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \AInstanceSub{}
\end{minipage}

\noindent In the \AgdaField{K-wk} field for the Term Kit, we use the \AgdaFunction{wk} primitive from the
Variable Kit. The Variable Kit is automatically resolved using
instance search.

\subsection{Composition}\label{sec:ags-com}
We aim to abstract over the four composition options for renamings and
substitutions, enabling unified composition lemmas, such as one associativity
law, instead of separate laws for each of the eight valid combinations. To this
end, we define the \AgdaDatatype{ComposeKit} record, parameterized over three
Kits. Inside the record, we can later define a single, more general composition
of a \AgdaBound{K₁}-Map with a \AgdaBound{K₂}-Map, yielding a
\AgdaBound{K₁⊔K₂}-Map. \AComposeKit{}The operation \AgdaField{C-\_\&/⋯\_}
unifies lookup and traversal. It takes a variable or term \AgdaBound{x/t}
(according to \AgdaBound{K₁}) and a renaming or substitution \AgdaBound{ϕ}
(according to \AgdaBound{K₂}), and applies \AgdaBound{ϕ} to \AgdaBound{x/t},
yielding a variable or term (according to \AgdaBound{K₁⊔K₂}). From unified
lookup/traversal, for which we also provide an opaque function version without
the $C$-prefix, we derive Map composition: \ACompDef{}The Map composition
operator, such as the unified lookup/traversal operator, is implicitly
parameterized over a Compose Kit. It takes an renaming or substitution
\AgdaBound{ϕ₁} (according to \AgdaBound{K₁}) and a renaming or substitution
\AgdaBound{ϕ₂} (according to \AgdaBound{K₂}) as arguments, and composes it to a
renaming or substitution (according to \AgdaBound{K₁⊔K₂}). When \AgdaBound{x}
\AgdaFunction{\&} \AgdaBound{ϕ₁} yields a variable, we need to look up the
resulting variable in \AgdaBound{ϕ₂}, or if we have a term, we traverse the
term with \AgdaBound{ϕ₂}. We also define versions of both the unified
lookup/traversal operator and the composition operator where the Compose Kit is
given explicitly: \ACompExp\ and \ALoAExp.

As with Kits, we now require a user-provided proof about traversal. We need the
user to show that the chosen syntax and traversal function satisfy
compositionality. This proof can only be established by induction on the
syntax: \ACompositionality{}Finally, to cover the four possible instances of
Compose Kits, we provide two generic instances that suffice:

\noindent\begin{minipage}{0.43\linewidth}
      \raggedright{}
      \AInstanceCRen{}
\end{minipage}
\begin{minipage}{0.53\linewidth}
      \raggedright{}
      \AInstanceCSub{}
\end{minipage}

\noindent The \AgdaFunction{Cᴿ} instance corresponds to the Compose Kit for composition
between a renaming and another \AgdaBound{K}-Map. Similarly, \AgdaFunction{Cˢ} covers the
composition between a substitution and another \AgdaBound{K}-Map, and assumes that
composition of a \AgdaBound{K}-Maps with renamings is already available.

The third parameter \AgdaBound{K₁⊔K₂} of a Compose Kit can be understood as a
functional dependency, uniquely determined by the choice of \AgdaBound{K₁} and
\AgdaBound{K₂}. It is instantiated to \AgdaFunction{V} if and only if both
\AgdaBound{K₁} and \AgdaBound{K₂} are \AgdaFunction{V}, otherwise it is
\AgdaFunction{T}. In other words, only renamings compose to a renaming, while
every other case yields a substitution. We can put this more algebraically: if
$\varphi_1$ is a $K_1$-Map and $\varphi_2$ is a $K_2$-Map, then the result is a
$(K_1 \sqcup K_2)$-Map, where $\sqcup$ refers to the join-semilattice on $\{V,
      T\}$ generated by $V < T$. A natural question is why we do not simply compute
\AgdaBound{K₁⊔K₂}. Computing \AgdaBound{K₁⊔K₂} is in fact possible and even
necessary to define the $σ$-calculus rules so that they still adhere to
restrictions on the shape of rewrite rules.

\subsection{Structural Kit Order}\label{sec:ags-sko}
We define a least upper bound operation on Modes that mirrors the behavior of
composing two Maps, indexed by Kits of these Modes, inside an opaque
block:\AModeLub{}By case analysis, all the join-semilattice laws are easily
verified: \AModeLubLaws{}All laws can be embedded as rewrite rules in Agda,
except for \AgdaFunction{⨆-comm}, which is evidently non-terminating. The
lattice laws for Modes must be registered as rewrite rules to define the
semilattice laws for Kits. Without the rewrite rules, explicit type coercions
would be necessary, because Modes appear in the type of Kits. We then define
the least upper bound for Kits: \AKitLub{}and prove the join-semilattice laws:
\AKitLubLaws{}The \AgdaFunction{⊔-comm} law requires the transfer lemma in its
type, because \AgdaFunction{⨆-comm} for Modes could not be rewritten earlier.
All other laws can be registered as rewrite rules to produce definitional
equalities whenever applicable, enabling effective use of the least upper bound
operator without the need to apply additional lemmas. The Kit least upper bound
laws follow by case distinction on their Modes, but examining a proof in detail
reveals a subtle issue. As an example, consider the proof for the
\AgdaFunction{⊔-idem} law. The remaining laws follow analogously.
\AKitLubExcerpt{}If we split on the Mode \AgdaBound{M} of the Kit
\AgdaBound{K}, we must prove in both cases that \AgdaBound{K} is either
\AgdaFunction{V} or \AgdaFunction{T}, according to the definition of
\AgdaFunction{\_⊔\_} and the chosen Mode. We run into the problem, that
\AgdaBound{K} is inferred by instance resolution, and Agda cannot deduce that
there is only one possible choice in both cases, \AgdaFunction{V} for
\AgdaInductiveConstructor{Vᴹ} and \AgdaFunction{T} for
\AgdaInductiveConstructor{Tᴹ}. Nor can the uniqueness of instances be assumed
in general, as external code might declare additional instances.

Agda does not provide a notion of closed type classes, where instance
declarations outside a module can be prohibited. In Haskell, such behavior can
be encoded using closed type families~\cite{10.1145/2578855.2535856}. In Agda,
closed type classes can be simulated, by requiring a field \ALockField{} of
type \ALock\ in the construction of a record instance. Because
\AgdaDatatype{Lock} is private, it can only be constructed from within the
library. Any attempt to declare an instance outside the library would fail,
because the required field \AgdaField{K-lock} of type \AgdaDatatype{Lock}
cannot be filled.

We can now postulate the uniqueness of Kits after manually verifying that only
two instances exist and that we rely solely on Kits provided by instance
resolution, never creating them locally: \AUniqueKits{}The postulates are
declared private and cannot cause inconsistencies for users outside the
library. There also exists a version \AgdaFunction{unique–K} that computes
whether a given Kit is \AgdaFunction{V} or \AgdaFunction{T}, based on its Mode.

\subsection{Computing Compose Kits}\label{sec:ags-cck}
Our original goal was to compute the third parameter of a Compose Kit. To
motivate this and, more generally, the computation of Compose Kits from Kits,
we consider a first attempt of the definition for the associativity law of the
$σ$-calculus, which in our Kit-based setting corresponds to the associativity
of Map composition:\AAssocTryO{}Here \AgdaBound{C₁} to \AgdaBound{C₄} denote
the four Compose Kits that are required for the compositions. For clarity we
apply them to the composition operators explicitly, although instance
resolution would perform this step automatically. This yields the most general
formulation of the associativity law for Maps, where arbitrary Kits are
admitted as long as both sides reduce to a \AgdaBound{K₅}-Map. Our current
formulation of the law, however, is not a valid rewrite rule. Both
\AgdaBound{C₃} and \AgdaBound{C₄}, required for the right side, appear only
there, violating the condition that all arguments of a rewrite rule must occur
on the left. Moreover, the law requires the instance argument \AgdaBound{K₆},
used as the result of composing the \AgdaBound{K₂}-Map with that of
\AgdaBound{K₄}, which is only used on the right. Because \AgdaBound{K₆} can be
computed via the least upper bound operation we defined before, the main
difficulty is to compute \AgdaBound{C₃} and \AgdaBound{C₄}.

We can try to define a function \ACompCKitSafe{}, that evaluates to
\AgdaFunction{Cᴿ}, if \AgdaBound{K₁} has Mode \AgdaInductiveConstructor{Vᴹ} and
to \AgdaFunction{Cˢ}, if \AgdaBound{K₁} has Mode \AgdaInductiveConstructor{Tᴹ}.
The function can be readily defined, but its correctness relies not only on the
uniqueness of Kit instances, but also on the uniqueness of Compose Kit
instances:\AUniqueCKits{}As before we require a value of \AgdaDatatype{Lock} in
the creation of Compose Kits. By manual inspection we confirm that
\AgdaFunction{Cᴿ} and \AgdaFunction{Cˢ} are the only instances and that none
are created locally.

Yet the function \AgdaFunction{\_;ᴷ\_} is insufficiently general. Computing
\AgdaBound{C₄} from the associativity law yields $C_4 = K_2 \;
      \AgdaFunction{;ᴷ} \; K_4 = \AgdaDatatype{ComposeKit}\; K_2\; K_4\; (K_2$
\AgdaFunction{⊔} $K_4)$. Consequently, \AgdaBound{C₃} evaluates to $C_3 = K_1
      \; \AgdaFunction{;ᴷ} \; (K_2 \; \AgdaFunction{⊔} \; K_4) =
      \AgdaDatatype{ComposeKit}\; K_1\; (K_2$ \AgdaFunction{⊔} $ K_4)\; (K_1$
\AgdaFunction{⊔} $ (K_2 $ \AgdaFunction{⊔} $ K_4))$. The final Map on the right
of the equation computes to a $(K_1 $ \AgdaFunction{⊔} $ (K_2$ \AgdaFunction{⊔}
$ K_4))$-Map, whereas the Map on the left is a $K_5$-Map. Adjusting the
\AgdaBound{K₅} parameter in \AgdaBound{C₂} to $(K_1 $ \AgdaFunction{⊔} $ (K_2$
\AgdaFunction{⊔} $ K_4))$ is not possible, as Compose Kits whose third
parameter involves least upper bounds cannot be inferred by instance
resolution. Defining instances that would permit the inference of Compose Kits
with arbitrary least upper bound computation in the third parameter is hard and
would increase instance resolution runtime dramatically. Additionally, Agda
generally refused to infer such instances during higher-order pattern
unification, performed when checking if a rewrite rule applies. A second
approach, defining the least upper bound operation syntactically as a
constructor in the \AgdaDatatype{Mode} type, fails because the lattice laws can
no longer be stated and rewritten. As a solution, we require an even more
general, but also unsafe, function: \ACKitUnsafe{}Because it is declared
non-covering, evaluation may get stuck, yielding a value for a Compose Kit that
should not exist. For this reason, every use of the function requires manual
verification. Computed Compose Kits are reduced to the actual instances, when
applicable, using the rewrite rules \ACKitRenRed{} for \AgdaFunction{Cᴿ} and
\ACKitSubRed{} for \AgdaFunction{Cˢ}. The unsafe function is only available
from within the library, but we can define the safe version from before as a
special case of the unsafe function: \ACompCKitSafeDef{}. We can now state a
version of the associativity law eligible for rewriting: \AAssocTryT{}With the
unsafe operator, we can connect $K_1$ \AgdaFunction{⊔} $ (K_2 $
\AgdaFunction{⊔} $K_4)$ with \AgdaBound{K₅} in the outer Compose Kit on the
right side of the equation. It remains to check that whenever the incoming
Compose Kits $C_1$ and $C_2$ are valid, the outgoing ones, computed using our
unsafe function, are as well. By exhaustively checking all eight valid
combinations of values for $C_1$ and $C_2$, we confirm that in each case the
outgoing Compose Kits are valid. Inside the associativity proof, the remaining
cases must be refuted under the assumption of valid and unique incoming Compose
Kits, and the non-existence of invalid Compose Kits: \AUnqiueCKitsImp{}As
before, each use of these postulates requires manual verification to avoid
inconsistencies, but cannot leak to the user, because they are declared
\AgdaKeyword{private}.

All other $σ$-calculus laws, generalized to Maps, follow the same structure as
the \AgdaFunction{associativity} law. On the left side of the equations we rely
on Kits and Compose Kits inferred via instance resolution, while on the right
we compute the resulting Kits and Compose Kits using the least upper bound
operation together with the unsafe \AgdaFunction{\_,\_,\_} operator, where we
manually verify that its use is sound. The proofs are carried out by case
analysis on the Modes of the Kit instance arguments and rely on the uniqueness
of (Compose-) Kits as well as the refutation of invalid ComposeKit Kits. Apart
from these aspects, their structure closely resembles the familiar separated
proofs for renamings and substitutions.

\subsection{The Scoped and Multi-Sorted $σ$-Calculus with Kits and Maps}\label{sec:ags-rls}
\begin{figure}[tp]
      \centering
      \small
      {\raggedright{} \textbf{\Large Symbols} \par}
      \vspace{1.5em}

      \begin{minipage}[t]{0.48\textwidth}
            \small{}
            \raggedright{}
            \textbf{Sorts} $s$ \\
            \ESortTy{}\\
            \vspace{0.5em}
            \emph{..\ object language sorts\..}\\
            \vspace{0.5em}
            \textbf{Scopes} $S$ \\
            \EScopeDefTy{}\\
            \vspace{0.5em}
            \EScopeDef{}\\
            \vspace{0.5em}
            \textbf{Variables} $x$ \\
            \EVarsTy{}\\
            \vspace{0.5em}
            \EVars{}\\
            \vspace{0.5em}
            \textbf{Terms} $t$ \\
            \ETmC{}\\
            \vspace{0.5em}
            \EVarC{}\\
            \emph{..\ object language\..}\\
            \vspace{1.0em}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \small{}
            \raggedright{}
            \textbf{Kits} \AgdaBound{K} \\
            \EKitDefTy{}\\
            \vspace{0.5em}
            \EKitDef{}\\
            \vspace{0.5em}
            \textbf{Maps} $ϕ$\\
            \EPrimsTy{}\\
            \vspace{0.5em}
            \EPrims{}\\
            \vspace{0.5em}
            \textbf{Variables or Terms} $x/t$\\
            \EVarTrmTy{}\\
            \vspace{0.5em}
            \EVarTrmApp{}
      \end{minipage}

      {\raggedright{} \vspace{2.0em} \textbf{\Large Reduction} \par}
      \vspace{1.5em}
      \begin{minipage}[t]{0.40\textwidth}
            \small{}
            \raggedright{}
            \textbf{Kit Laws}\\
            \ETypeLevel{}\\
            \vspace{0.5em}
            \textbf{Definitional Laws}\\
            \vspace{0.5em}
            \EDefLawTy{}\\
            \vspace{0.5em}
            \EDefLaw{}\\
            \vspace{0.5em}
            \textbf{Specialization Laws}
            \ESpecialDefLaws{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.54\textwidth}
            \small{}
            \raggedright{}
            \textbf{Interaction Laws}\\
            \EInteraction{}\\
            \vspace{0.5em}
            \textbf{Coincidence Laws}\\
            \ECoincidence{}
            \vspace{0.5em}
            \textbf{Traversal Laws}\\
            \ETravL{}\\
            \emph{..\ object language traversal\..}\\
            \vspace{0.5em}
            \textbf{Monad Laws}\\
            \EMonad{}\\
      \end{minipage}
      \caption{The Scoped and Multi-Sorted $σ$-Calculus with Kits and Maps}\label{fig:ags-fin}
\end{figure}

\cref{fig:ags-fin} states the $σ$-calculus laws in the Kit-setting.
The figure lists the symbols and laws as they are used in \textsc{Agdasubst}.
For readability we omit the Kit and ComposeKit instance arguments. In the
library, Kits and ComposeKits carry data, and Kits must be disambiguated on the
type level by their Modes. Here we treat Kits as markers, which lets us elide
the Mode lattice laws. Similarly, ComposeKits serve as markers for admissible
compositions and are written explicitly for each operator in square brackets.

The symbols are grouped into several categories. Sorts and scopes provide
intrinsic scoping at the type level. Variables are supplied by the library,
while terms are user-defined, subject only to the requirement of a variable
constructor of the appropriate form. We define the type of Kits together with
the Variable Kit, the Term Kit, and the least upper bound operation. We then
define the type of Maps and the four Map primitives, parameterized by Kits. The
operator \AgdaFunction{wk} is specialized directly to a renaming to avoid
duplication, as it can always be embedded as a substitution by composition with
the identity substitution. When the Kit in the type index of Maps is known to
be \AgdaFunction{V} or \AgdaFunction{T}, we use the variables $ρ$ and $σ$
respectively. From Kits we also obtain the combined type of variables and
terms, together with the unified lookup/traversal operator. While there are
distinct type definitions for variables, terms, and variables-or-terms, there
is only a single type definition for Maps, specialized through the Kit index.
There is no technical obstacle to unifying variables and terms in the same way.
However, unlike renamings, substitutions, and Maps, terms are user-defined,
whereas variables are provided by the library and therefore justify a distinct
type definition.

We already discussed the \textbf{Kit Laws} in \cref{sec:ags-sko}, so we now
turn to the remaining ones. We begin with the type-level reduction laws
\AgdaFunction{imgⱽ} and \AgdaFunction{imgᵀ} inside the \textbf{Definitional
      Laws}, which rewrite the type of variables-or-terms to either the type of
variables or the type of terms when the Kit index is known to be
\AgdaFunction{V} or \AgdaFunction{T}, respectively.

Next comes the definition of lookup on the identity substitution
\AgdaFunction{idˢ}. It is given in terms of the unified lookup/traversal
operator. The laws \AgdaFunction{wk}, \AgdaFunction{ext₀}, and
\AgdaFunction{extₛ} are the direct generalizations of their familiar
counterparts for renaming and substitution.

Lookup on the identity renaming does not require a separate law, as it is
already subsumed by the generalized \AgdaField{right-id} from the \textbf{Monad
      Laws}. The \AgdaField{right-id} law accounts for both a term traversed by an
identity substitution and a variable looked up in the identity renaming. This
coincidence suggests a deeper connection between definitional laws and monad
laws when there is only a single unified lookup/traversal operator. We can
confirm our suspicion when examining the \AgdaFunction{comp} and
\AgdaField{compositionality} law. There exists a fundamental symmetry between
the definition of composition, given via the unified lookup/traversal operator,
and the compositionality law in full generality:

\noindent\begin{minipage}{0.45\linewidth}
      \raggedright{}
      \ECompGeneral{}
\end{minipage}
\begin{minipage}{0.55\linewidth}
      \raggedright{}
      \ECompoGeneral{}
\end{minipage}

\noindent Viewed side by side, these laws exhibit an inherent symmetry. If both were admitted into the
rewrite system, they would trigger infinite loops. This symmetry is no accident, intuitively, one law pushes variables into maps, while the other pushes maps into other maps, away from terms. The unification of lookup and traversal into a single operator makes this symmetry explicit.
To avoid non-termination, we adopt the following heuristic:
\begin{itemize}
      \item In variable position ($K_5 = $ \AgdaFunction{V}) use the definition of
            composition. In this case all other indices $K_1,\dots,K_4$ are forced to
            \AgdaFunction{V}, and $x/t$ must be a variable. This yields exactly the
            specialized \AgdaFunction{comp} law shown in the figure.
      \item In term position ($K_5 = $ \AgdaFunction{T}) use \AgdaField{compositionality}.
            Here no restrictions on the other indices arise, so the law is preserved in
            most of its generality and appears under the Monad Laws.
\end{itemize}

\noindent If neither condition applies ($K_5$ not fixed), the user must explicitly choose from the fully
general laws which law to apply, either by equational reasoning or by using
\AgdaKeyword{rewrite}.

With the position heuristic the \AgdaFunction{comp} law is rather restricted.
We now miss cases where we would make progress by applying the
\AgdaFunction{comp} law, when $\varphi_1$ and $\varphi_2$ are not both
renamings. Hence, we consider all situations where progress would be made
directly after applying \AgdaFunction{comp}, by specializing on $\varphi_1$.
The laws, where $\varphi_1$ or $\varphi_2$ is fixed to a primitive and progress
can be inlined, appear under the name \textbf{Specialization Laws}.

The \textbf{Interaction Laws} are the direct generalizations of their original
$σ$-calculus counterparts to Kits. Next come the \textbf{Traversal Laws}.
Because we are independent of the object syntax except for the required
variable constructor, we only show the law specific to the traversal of a
variable. When a variable constructor is applied to a map, the variable it
holds is mapped accordingly. To turn the result back into a term, as it may
otherwise be either a variable or a term, depending on the map, we subsequently
apply the identity substitution.

To illustrate another case for traversal, consider an object language that
supports $λ$-abstractions. The corresponding user-supplied traversal function,
needed to construct the Term Kit, would then include a clause \FSLambdaExT.
However, the clause does not directly corresponds to a traversal law. It must
first be lifted from the traversal operator to the unified lookup/traversal
operator: \FSLambdaExL. The equation can be proven by reflexivity, when we
unfold the definition of the unified lookup/traversal operator. It can then be
added to our equational theory.

Finally, the \textbf{Coincidence Laws} generalize from renamings to Maps and
enable Maps to be pulled out of substitutions when possible. As discussed
earlier, these laws do not exhaustively describe every possible way in which
Maps can be extracted from substitutions.

\subsection{Discussion}
The Kit-based version of the $σ$-calculus laws required unsafe computation and
a careful formulation of the laws so that they remain valid rewrite rules while
still delegating Kit and ComposeKit inference to the instance resolution
algorithm. We believe the Kit-based variant, derived from the $σ$-calculus used
in \textsc{Autosubst}, remains terminating and confluent, even though Agda’s
built-in checker cannot verify confluence. From the Kit-based laws, we can
readily derive the specialized laws from \cref{sec:mis} and rewrite them if we
wish to reason about renamings and substitutions separately.

The key difficulty in adapting the laws to the Kit-setting emerges from the
symmetry between the general definition of composition \AgdaFunction{comp} and
the \AgdaField{compositionality} law. Our solution is a heuristic that resolves
this conflict by restricting the laws to cases where the context is known to be
variable or term position. When the position is unknown, the flow of the laws
becomes ambiguous, and the user must resort to manual application.

Compared to the laws from \cref{sec:mis}, the Kit-based formulation has the
advantage that properties can be established directly for Maps, without
requiring separate but structurally identical proofs for renamings and
substitutions.

\section{Case Studies}\label{sec:ext}
We present two examples illustrating the usage of the \textsc{Agdasubst}
library. The first concerns proofs of subject reduction for System F with
subtyping. We begin by a presentation of the proof using the laws from
\cref{sec:mis-sig} and then revisit it using the Kit-based laws from
\cref{sec:ags-rls}. We then extend the latter version with subtyping. The
second example, based on work by \citet{allais2021typescopesafeuniverse},
provides an instantiation for a generic universe of scoped syntax.
\subsection{System F (+ Subtyping)}\label{sec:ext-syf}

\begin{figure}[!t]
      \centering
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ETyping{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESemantics{}
      \end{minipage}
      \caption{Typing and semantics for System F}\label{fig:ext-tas}
\end{figure}

Recall the multi-sorted and scoped syntax from the right side of
\cref{fig:pre-svm}. We outline the proof of subject reduction, first using the
laws from \cref{sec:mis-sig} and then using the \textsc{Agdasubst} library. The
type system and semantics are the same in both cases and are presented once in
\cref{fig:ext-tas}. In both settings, we use the functions \EWk{} and \ESubst{}
to increment all variable indices within a term and to substitute a term for
the most recently bound variable in another term. These functions can be
defined directly from the primitives in both cases. Within the typing relation,
we rely on the lookup relation \ELookup{} to retrieve the type of a variable
from the typing context. The type of the lookup and typing relation is
expressed using the \AgdaFunction{\_∶⊢\_} operator. This operator computes the
sort of the third index of the relations based on the sort of the second. With
the \AgdaFunction{\_∶⊢\_} operator, we can define a single lookup and typing
relation for well-typed expressions and well-kinded types. For System F, it can
be defined as follows:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EUpArrow{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \ETypeOf{}
\end{minipage}

\subsection*{Separated Renamings and Substitutions}
\begin{figure}[!t]
      \centering
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ERPT{}
      \end{minipage}
      \begin{minipage}[t]{0.48\linewidth}
            \raggedright{}
            \ESPT{}
      \end{minipage}
      \caption{Renaming and Substitution Preserve Typing}\label{fig:ext-rst}
\end{figure}

We have already seen the instantiation of the $σ$-calculus for System F, where
renamings and substitutions are treated separately, in \cref{sec:mis-sig}. To
establish subject reduction, we first prove that renaming and substitution
preserves typing. The proofs for the preservation lemmas can be found in
\cref{fig:ext-rst}. We prove renaming preserves typing
(\AgdaFunction{\_⊢⋯ᴿ\_}), and then, using this result in the proof for the fact
that lifting of a substitution preserves typing (\AgdaFunction{⊢↑ˢ}, omitted),
show that general substitution preserves typing (\AgdaFunction{\_⊢⋯ˢ\_}) as
well.

The types of both proofs rely on the types for well-typed renamings \EWTR{} and
well-typed substitutions \EWTS{}, whose definitions are omitted here. In the
cases for variables, we look up the well-typed variable in the corresponding
renaming or substitution. When going under a binder, we apply the preservation
lemma for lifting renamings and substitutions. Thanks to the automatic
application of the $σ$-calculus laws, both proofs follow directly by induction,
including the cases under binders.

Using the two results, we can then prove subject reduction for
System~F:\ESR{}All cases proceed without any explicit application of
substitution lemmas. In particular, in the $β$-reduction cases, we can directly
apply the substitution-preserves-typing lemma, whereas normally the interaction
law would need to be applied manually as well.

\subsection*{Using \textsc{Agdasubst}}
We first instantiate the library by providing the traversal function and the
syntax-dependent laws. For System F, the traversal function is given
by:\SFTraversal{}In the case of variables, we convert the result of the lookup
on the Map, whether a variable or a term, into a term. We then proceed to prove
the monad laws:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \small
      \raggedright{}
      \SFId{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \small
      \raggedright{}
      \SFCompo{}
\end{minipage}

\noindent We omit the proofs, but they follow directly by structural induction because
the library already provides and permits rewriting of the necessary laws.
Specifically, for right identity under a binder, we rely on
\AgdaFunction{id↑≡id}\;:\;\AIdLift{}, and for compositionality under a binder,
we rely on \AgdaFunction{dist–↑–;}\;:\;\ADistLift{}. Both additional laws
follow directly from the rules of the $σ$-calculus and do not cause any issues
when admitted as rewrite rules, in addition to the $σ$-calculus laws, rewritten
later. We omit the syntax-dependent laws needed to lift the traversal operator
to the unified lookup/traversal operator, when traversing a term. To complete
the instantiation, lookup and traversal are redefined using the unified
lookup/traversal operator:

\noindent \begin{minipage}[t]{0.48\linewidth}
      \small
      \raggedright{}
      \SFLookupSH{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \small
      \raggedright{}
      \SFTraversalSH{}
\end{minipage}

\noindent To prove that renaming and substitution preserve typing in a single lemma, we
make use of Typing Kits, following the approach of \citet{saffrich:LIPIcs.ITP.2024.32}. Typing
Kits abstract over typed renamings and substitutions depending on a Kit, in a
way analogous to how Maps abstract over renamings and substitutions based on
a Kit. Within the library, they are instantiated exactly twice, once for the
Variable Kit and once for Term Kit. For a
more detailed description, we refer the reader to the already mentioned work.
The unified proof that Maps preserve typing mirrors the shape of the separate
proofs: \SFSPT{}In the variable case, we need to convert a typed
variable or term into a typed term. \textsc{Agdasubst} automatically solves all equations occurring
from lifting. Compared with the proofs presented by
\citet{saffrich:LIPIcs.ITP.2024.32} in Section 5.5\footnote{Additionally available online: \href{https://github.com/m0rphism/kitty/blob/bc86948c60f2d827593ad23e539197f9660178aa/src/Kitty/Examples/SystemF/SubjectReduction.agda\#L9}{Link to proof on GitHub}}, there is no need to
manually move the Map under a weakening for binders or under a singleton
substitution in the case of type application.

The proof of subject reduction is exactly the same as the one presented before.
The only difference is that, instead of using the substitution preserves typing
lemma, we use the more general lemma that Maps preserve typing in the cases of
$β$-reductions: \SFSR{} Normally, we would additionally need to apply the
interaction law manually in the case of \AgdaFunction{β-λ}\footnote{See the
      proof provided by \citet{saffrich:LIPIcs.ITP.2024.32}:
      \href{https://github.com/m0rphism/kitty/blob/bc86948c60f2d827593ad23e539197f9660178aa/src/Kitty/Examples/SystemF/SubjectReduction.agda\#L32}{Link
            to proof on GitHub}}.

\subsection*{Subtyping}
When we extend System F with subtyping\cite{CARDELLI19944}, substitution does
not generally preserve typing because type variables must respect subtyping
bounds. To formalize subtyping bounds, we can encode a type variable binding $α
      < t$ as two bindings, $α : \star$ and a constraint $c : (α < t)$. This
restricted, first-class-constraint–style encoding is isomorphic to the original
formalization and makes substitution-preserves-typing hold again. Here,
violating a bound simply yields a context with an unsatisfiable
constraint~\cite{saffrich:LIPIcs.ITP.2024.32}.

The extension with subtyping substantially complicates the proof of subject
reduction. We must reason about an injective subset of renamings and handle
various inversion lemmas arising from the additional subtyping constraints. All
these additional lemmas, together with the subject reduction theorem, can be
established within \textsc{Agdasubst} without any manual application of
substitution lemmas and are provided in the supplement\footnote{In comparison,
      see the subject reduction proof by \citet{saffrich:LIPIcs.ITP.2024.32}:
      \href{https://github.com/m0rphism/kitty/blob/bc86948c60f2d827593ad23e539197f9660178aa/src/Kitty/Examples/SystemFSub/SubjectReduction.agda\#L308}{Link
            to proof on GitHub}}.

\subsection{Generic Syntax}\label{sec:ext-uni}
The class of object languages supported by \textsc{Agdasubst} can be described
by the definition of a generic syntax à la
\citet{allais2021typescopesafeuniverse}, adapted to the intrinsically scoped
setting~\cite{saffrich:LIPIcs.ITP.2024.32}:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \GDesc{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \GDenot{}
      \GTms{}
\end{minipage}

\noindent We can describe our object
language syntax using sums \AgdaInductiveConstructor{`σ}, products
\AgdaInductiveConstructor{`X} that introduce binders, and
\AgdaInductiveConstructor{‘■} to terminate a construct. The \AgdaDatatype{Tm} type turns a syntax description into a data structure that separates variables from the other object language constructors, which are built using sums, products, and equality inside the \AgdaFunction{⟦\_⟧} function.

All laws required for instantiation of the \textsc{Agdasubst} library can be
proven once and for all over the generic syntax. Users can define their own
syntax directly from these building blocks without implementing traversals or
reproving syntax-specific laws. Albeit the \AgdaInductiveConstructor{`X}
constructor permits the addition of \AgdaBound{S′} many binders, the current
version of \textsc{Agdasubst} does not support variadic binders, that is,
binders introducing an unknown number of newly bound variables. The rewrite
rules only apply correctly when \AgdaBound{S′} is fixed. For instance, the
$σ$-calculus laws apply automatically to the following encoding of the lambda
calculus, where the generic encoding has a single sort of expressions,
\GSort{}, and two labels, one for abstraction and one for application,
\GLabel{}:

\noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \GDescL{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \GPattern{}
\end{minipage}

\noindent While the
generic approach is very convenient, the main drawback is that Agda sometimes
unfolds the pattern definitions inside holes, leaking details of the encoding,
which results in proof states that are hard to read.

\section{Further Work}\label{sec:wrk}
This section outlines possible directions for improving \textsc{Agdasubst} in
the future.

\subsection*{Reflection}
In contrast to most of the other substitution libraries, users of
\textsc{Agdasubst} still need to manually provide the definition for traversal
and the syntax-dependent proofs (Monad and Coincidence Laws).
\citet{saffrich:LIPIcs.ITP.2024.32} has shown that definitions and proofs for
scoped syntax can be derived automatically using Agda's reflection mechanism.
There is no reason why the same approach could not be applied for the
definitions and proofs required to instantiate \textsc{Agdasubst}.

\subsection*{Sigma Calculus Extensions}
\citet{Stark:2020:Mechanising} introduced several interesting extensions to the $σ$-calculus that could also be implemented in \textsc{Agdasubst}. One extension is support for variadic bindings (unknown number of variables bound), useful for languages with pattern matching. Another extension is support for lists of terms, allowing an unknown number of terms in the syntax tree. This would, for example, enable support for languages with $n$-ary application.
The latter can already be encoded in the current system by inlining the list
data structure directly into the syntax definition and treating
them as terms of a new sort.

\subsection*{Meta Theory}
In its current state, \textsc{Agdasubst} completely lacks a meta-theoretical
analysis. While we conjecture it to be terminating and confluent, it would be
interesting to formally establish these properties.

\subsection*{Coincidences}
As noted, \textsc{Agdasubst} is not complete when reasoning simultaneously
about renamings, substitutions and Maps. It would therefore be worthwhile to
investigate additional laws, in the spirit of the coincidence laws, to increase
the space of solvable equations. \textsc{Autosubst 2} already provides a more
sophisticated tactic for the separation of renamings from substitutions, which
could serve as a useful starting point for deriving such additional laws in
\textsc{Agdasubst}.

\subsection*{Performance}
At the moment, the performance of \textsc{Agdasubst} is, to be honest, very
poor. For instance, the proof of subject reduction for System~F with subtyping
requires several minutes to check. Our analysis shows that most of this time is
spent on instance resolution and function coverage analysis (i.e., verifying
that pattern matching clauses are exhaustive). Currently, we have no concrete
strategy to improve these aspects, without decreasing user-experience, except
that we know, that the addition of the coincidence laws dramatically increases
type-checking time.

\section{Related Work}\label{sec:rwk}

\subsection*{Explicit Substitution Calculi}
There exist a variety of explicit substitution calculi, but we focus on the
original $σ$-calculus~\cite{10.1145/96709.96712}, which includes identity,
extension, shifting, and composition primitives, and the
$σ_{SP}$-calculus~\cite{10.1145/2676724.2693163}, which adds further reductions
to ensure confluence. Only the $σ_{SP}$-calculus is both sound and complete,
enabling all equations between terms to be derived via reduction. Both
completeness and convergence are established through mechanized
proofs~\cite{10.1145/2676724.2693163, Stark:2020:Mechanising}.

\subsection*{Abstractions over Variables/Terms and Renamings/Substitutions}
We already discussed the original work on Kits~\cite{ren-sub} and their
adaptation to multi-sorted and scoped
syntax~\cite{saffrich:LIPIcs.ITP.2024.32}.

The intrinsically scoped version of this approach also appears in recent work,
for example in a paper written by \citet{altenkirch2025substitution}, where a
uniform treatment of renaming and substitution is explored in an intrinsically
typed setting. They additionally unify variables and terms, which we
deliberately do not do, as variables are library-defined while terms are
user-supplied. A further application of the Kit approach is given by
\citet{Wood_2021}, who use it to reason about metatheory in the context of
linear languages.

Another line of research concerns generic programming
approaches~\cite{allais2021typescopesafeuniverse, 10.1145/3018610.3018613},
which allow the construction of syntax trees from general building blocks
supporting sums, products, and binder introduction. The generic programming
approach also allows for a generic structure that abstracts not only over
renamings and substitutions, but also over semantics and other relevant
language structures. The generic syntax approach can be adapted to a scoped and
multi-sorted setting~\cite{saffrich:LIPIcs.ITP.2024.32}. Importantly, generic
programming and the \textsc{Agdasubst} library are orthogonal, as shown
in~\cref{sec:ext-uni}.

\subsection*{Substitution Libraries in Proof Assistants}
We have already discussed \textsc{Autosubst 2}~\cite{10.1145/3293880.3294101,
      schafer2015autosubst, Stark:2020:Mechanising} which forms the direct
theoretical foundation of our work.

There exists another Agda library with a similar goal to \textsc{Agdasubst},
called \textsc{Abstract Binding Trees}, used for instance by
\citet{siek2021parameterized}. It permits constructing an object language from
a generic syntax, similar to the approach in \cref{sec:ext-uni}, but it
supports only extrinsic scoping and single-sorted syntaxes. The library
provides abstractions over arbitrary predicates about the object language,
rather than focusing on specific relations such as
typing~\cite{saffrich:LIPIcs.ITP.2024.32}. The library also offers incomplete
experimental support for rewriting using $\sigma$-calculus laws, but only
handles renamings and substitutions separately, similar to the approach in
\cref{sec:mis-sig}, rather than in a uniform treatment.

More distantly related is \textsc{Nominal 2}~\cite{Nominal2-AFP}, an Isabelle
package that addresses the $α$-equivalence problem not via de Bruijn indices,
but using nominal datatypes and freshness conditions. Their approach is closer
to the intuitive notion of variables, but the tool does not provide any
strategy for solving equations involving terms and substitutions.

Additionally, there are tools such as \textsc{Needle and
      Knot}~\cite{10.1007/978-3-662-49498-1_17}, which is a code generator for
unscoped syntax using de Bruijn indices. The tool generates substitution and
interaction lemmas for single-pointed substitutions for languages that feature
multiple variable sorts and variadic binders.

\section{Conclusion}\label{sec:con}
We have shown how to take advantage of the $σ$-calculus laws to automatically
solve equations inside proofs about syntaxes with binding in Agda, similar to
\textsc{Autosubst 2} in Rocq.

We first embedded the $σ$-calculus with first-class renamings directly into
Agda as reduction rules, using its rewrite mechanism to yield definitional
equalities for a formalization of System~F.

We then wanted to unify proofs about renamings and substitutions, which led to
the current state of the \textsc{Agdasubst} library. To achieve our goal, we
introduced the notions of Kits and Maps from prior work and adapted the
$σ$-calculus laws to a Kit and Map setting.

We demonstrated how \textsc{Agdasubst} can be used to prove properties
involving substitutions for formal languages, including subject reduction for
System F with subtyping using a single substitution-preserves-typing lemma, and
provided an instantiation of a scoped universe of syntaxes with binding.

The \textsc{Agdasubst} library is not yet close to a stable release. We have
outlined potential directions for future development and plan to continue
improving the library over time.

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
