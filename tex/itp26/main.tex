
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
\usepackage{microtype}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\nolinenumbers

\usepackage{agda}

\input{unicodeletters}
\input{agdamacros}
\input{agda-generated}
\input{agda-generated-examples}

\definecolor{agdablue}{HTML}{0000CD}
\DisableLigatures[-]{encoding=T1}
\newcommand{\bsym}[1]{\textcolor{agdablue}{#1}}
\newcommand{\tdot}{\mkern2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern-2mu \textcolor{agdablue}{\cdotp} \mkern1mu}

\bibliographystyle{plainurl}
\title{How to REWRITE the Sigma Calculus in Agda}

\author{Marius Weidner}{University of Freiburg, Germany}{weidner@cs.uni-freiburg.de}{0009-0008-1152-165X}{}
\authorrunning{M. Weidner}
\Copyright{Marius Weidner}

\keywords{Explicit Substitutions, Sigma Calculus, Kits, Agda}

\ccsdesc[300]{Theory of computation~Equational logic and rewriting}

\begin{document}
\AgdaNoSpaceAroundCode{}

\maketitle

\begin{abstract}
      Mechanizing the metatheory of programming languages in proof assistants is
      difficult because of recurring challenges with variable binding. Every
      formalization requires proving standard lemmas about substitutions such
      as those describing composition and interaction with binders.
      Historically researchers treated substitution as a meta level operation
      but explicit substitution calculi bring these operations into the
      syntax. The $\sigma$ calculus provides reduction rules that ensure
      confluence and strong normalization so that users can compare normal
      forms instead of applying lemmas manually.

      Tools like \textsc{Autosubst 2} provide this procedure via tactics to produce
      \emph{propositional} equalities. We register $\sigma$ calculus rules as native
      reduction rules in Agda using the Agda REWRITE mechanism to produce
      \emph{definitional} equalities. Native embedding is challenging because it
      requires precise control over reduction behavior and care to maintain the
      logical consistency of Agda.

      We treat renamings and substitutions separately at first in a scoped syntax
      setting which is reasonably safe and see that the concepts translate well to
      intrinsically typed syntax. If substitution appears as an operation on the
      index of complex intrinsically typed syntax then rewriting the $\sigma$
      calculus laws avoids transfer hell in substitution lemmas. Finally we
      investigate how to adapt the $\sigma$ calculus to a setting where substitutions
      and renamings are treated uniformly from a proof engineering perspective. This
      uniform treatment loses the safety of earlier approaches because more work is
      needed to verify the required properties of the resulting rewrite system.
\end{abstract}

\section{Introduction}\label{sec:introduction}

\subsection*{Structure}
The paper is organized into several sections.\ \cref{sec:pre} introduces the
theoretical background and tools.\ \cref{sec:mis} presents an embedding of the
$σ$-calculus as native reduction rules into Agda for multi-sorted, scoped
syntax, treating renamings and substitutions separately.\ \cref{sec:its} shows
how the rewriting approach prevents the transfer hell problem for complex
intrinsically typed syntax. \cref{sec:ags} explains how to adapt the laws to a
setting where renamings and substitutions can be treated uniformly.\ Finally,
we outline directions for future work in \cref{sec:wrk}, discuss related work
in \cref{sec:rwk} and conclude the paper in \cref{sec:con}.

\subsection*{Contributions}
The main contributions of this work are
\begin{itemize}
      \item an embedding of the $σ$-calculus with first-class renamings into Agda, in a
            scoped and multi-sorted setting, using rewrite rules, exemplified with System~F
            (\cref{sec:mis});
      \item proof of the XXX laws for substitutions for expressions in intrinsically typed
            System~F without entering transfer hell
      \item a novel version of the $σ$-calculus, where the laws are stated in a Kit- and
            Map-based setting. We effectively lift the distinction between variables and
            terms, as well as between renamings and substitutions, from the syntactic to
            the type level.
\end{itemize}

\noindent\textbf{The supplement contains the complete Agda code underlying this paper.}

\section{Preliminaries}\label{sec:pre}
This section introduces the concepts and tools required for the developments in
this work. We summarize
\begin{itemize}
      \item Agda and language features relevant to our work: instance arguments, rewrite
            rules and opaque blocks;
      \item The $σ$-calculus;
      \item Multi-sorted and scoped syntaxes in Agda.
\end{itemize}

\subsection{Agda and Relevant Language Features}\label{sec:pre-agd}
Agda is a dependently typed functional language and proof assistant based on
Martin-Löf type theory~\cite{MARTINLOF197573}, where proofs are verified via
type checking. Proofs are significantly simplified when terms are
\textit{definitionally equal}. When terms are not definitionally equal, users
must resort to manual equational reasoning using propositional equality, which
is a cumbersome process as Agda lacks automated proof-discharge tactics.
Maximizing definitional equalities thus directly reduces manual effort.

Beyond standard features like indexed inductive types and dependent pattern
matching~\cite{10.1145/3236770}, this work utilizes three specific mechanisms.

\subsection*{Instance Arguments}
Instance arguments (\AgdaSymbol{\{\{\dots\}\}}) are resolved via an automated,
type-directed search similar to Haskell type
classes~\cite{10.1145/75277.75283}. Agda infers these arguments from values
marked \AgdaKeyword{instance}. Consider a record for types with a default
value: \EDefault{} Opening this record with \EDefFields{} allows Agda to
resolve the \AgdaField{default} field automatically: \noindent\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \setlength{\mathindent}{0pt}
      \EDefInst{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}%
      \raggedright{}%
      \setlength{\mathindent}{0pt}%
      \EDefInstS{}%
\end{minipage}

\noindent These instances enable implicit usage of default values for natural numbers and strings:
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefEx{}
\end{minipage}
\begin{minipage}[t]{0.48\linewidth}
      \raggedright{}
      \EDefExS{}
\end{minipage}

\noindent Agda infers the appropriate instance (\AgdaFunction{default–ℕ} or \AgdaFunction{default–String}) from the required type, ensuring these equations hold definitionally.

\subsection*{Rewrite Rules}
User-defined rewrite rules~\cite{10.1145/3434341, cockx:LIPIcs.TYPES.2019.2}
extend Agda’s computation by treating propositional equalities as reduction
rules. A function $\AgdaFunction{eq} : (x_1 : A_1) \ldots \to
      \AgdaFunction{f}\, p_1 \ldots p_n \, \AgdaFunction{≡} \, v$ can be registered
as a rewrite rule if:
\begin{enumerate}
      \item The head \AgdaFunction{f} is a postulate, defined function, or constructor with
            distinct variable type parameters.
      \item Every variable $x_i$ appears in a pattern position among $p_1, \ldots,
                  p_n$\footnote{The Agda documentation includes a precise definition for pattern
                  positions:
                  \href{https://agda.readthedocs.io/en/latest/language/rewriting.html}{Link to
                        Agda Documentation}}.
      \item The left side is neutral (it does not further reduce).
\end{enumerate}

\noindent For example, the right identity of addition satisfies these criteria: \ERewrite{} Once registered via \ERewriteIt{}, Agda treats \AgdaBound{n} \AgdaFunction{+} \AgdaNumber{0} as definitionally equal to \AgdaBound{n}: \ERewriteEx{} Users must ensure rules are terminating and confluent to retain logical consistency. While Agda provides conservative confluence checks via \texttt{--confluence-check}, termination is not verified.

\subsection*{Opaque Blocks}
Opaque definitions~\cite{gratzer2022controlling} treat code as non-unfolding
symbols. Definitions within an \AgdaKeyword{opaque} block are visible but
treated abstractly during type checking: \EOpaque{} Outside this block,
\AgdaFunction{forty-two} does not reduce to \AgdaNumber{42} during equality
checks: \EOpaqueExO{} However, the \AgdaKeyword{unfolding} keyword can be used
to manually expose the underlying definition when needed: \EOpaqueExT{}

\begin{figure}[t]
      \centering
      \scriptsize % 1. Use smaller font
      \setlength{\jot}{0pt} % No vertical gap between equation lines

      % 2. Kill all vertical space around math environments
      \setlength{\abovedisplayskip}{0pt}
      \setlength{\belowdisplayskip}{0pt}
      \setlength{\abovedisplayshortskip}{0pt}
      \setlength{\belowdisplayshortskip}{0pt}
      \setlength{\arraycolsep}{2pt} % Tighter horizontal columns

      % Header 1
      {\raggedright \textbf{Symbols} \par}
      \vspace{2pt} % Minimal gap

      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Variables} $x$
            \begin{align*}
                  \text{innermost} \quad & \textcolor{agdablue}{\mathsf{zero}}    \\
                  \text{outer} \quad     & \textcolor{agdablue}{\mathsf{suc}}\; x
            \end{align*}
            \vspace{2pt}
            \textbf{Terms} $t$
            \begin{align*}
                  \text{var} \quad    & \textcolor{agdablue}{\texttt{\`{}}}x \\
                  \text{abs} \quad    & \textcolor{agdablue}{λ.}\, t         \\
                  \text{app} \quad    & t_1 \ t_2                            \\
                  \text{lookup} \quad & x \textcolor{agdablue}{\;\&\;} σ     \\
                  \text{subst} \quad  & t \tdot{} σ
            \end{align*}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.48\textwidth}
            \raggedright
            \textbf{Substitutions} $σ$
            \begin{align*}
                  \text{id} \quad   & \textcolor{agdablue}{\mathsf{id}}                                                                           \\
                  \text{ext} \quad  & t \textcolor{agdablue}{\cdot} σ                                                                             \\
                  \text{comp} \quad & σ_1 \ \textcolor{agdablue}{;} \  σ_2                                                                        \\
                  \text{wk} \quad   & \textcolor{agdablue}{\mathsf{wk}}                                                                           \\
                  \text{lift} \quad & \textcolor{agdablue}{\uparrow}σ ≐ ((\textcolor{agdablue}{\texttt{\`{}}}\textcolor{agdablue}{\mathsf{zero}})
                  \textcolor{agdablue}{\cdot} (σ \ \textcolor{agdablue}{;} \
                  \textcolor{agdablue}{\mathsf{wk}}))
            \end{align*}
      \end{minipage}

      \vspace{0.6em} % Reduced gap between top and bottom halves
      {\raggedright \textbf{Reduction} \par}
      \vspace{2pt}

      \begin{minipage}[t]{0.38\textwidth}
            \raggedright
            \textbf{Definitional Laws}
            \begin{alignat*}{2}
                  \mathsf{id}      \quad          & x \textcolor{agdablue}{\;\&\;} \textcolor{agdablue}{\mathsf{id}}                                     &  & = \textcolor{agdablue}{\texttt{\`{}}} x                                       \\
                  \mathsf{ext}_\mathsf{Z}  \quad  & \textcolor{agdablue}{\mathsf{zero}} \textcolor{agdablue}{\;\&\;} (t \textcolor{agdablue}{\cdot} σ)   &  & = t                                                                           \\
                  \mathsf{ext}_\mathsf{S}   \quad & \textcolor{agdablue}{\mathsf{suc}}\;x \textcolor{agdablue}{\;\&\;} (t \textcolor{agdablue}{\cdot} σ) &  & = x \textcolor{agdablue}{\;\&\;} σ                                            \\
                  \mathsf{comp}    \quad          & x \textcolor{agdablue}{\;\&\;} (σ_1 \ \textcolor{agdablue}{;} \  σ_2)                                &  & = (x \textcolor{agdablue}{\;\&\;} σ_1) \tdot σ_2                              \\
                  \mathsf{wk}      \quad          & x \textcolor{agdablue}{\;\&\;} \textcolor{agdablue}{\mathsf{wk}}                                     &  & = \textcolor{agdablue}{\texttt{\`{}}}(\textcolor{agdablue}{\mathsf{suc}} \ x)
            \end{alignat*}
            \vspace{2pt}
            \textbf{Traversal Laws}
            \begin{alignat*}{2}
                  \mathsf{var} \quad & (\textcolor{agdablue}{\texttt{\`{}}} x)                                 & \tdot σ
                                     & = x \textcolor{agdablue}{\;\&\;} σ                                                 \\
                  \mathsf{lam} \quad & (\textcolor{agdablue}{λ.}\, t)                                          & \tdot  σ
                                     & = \textcolor{agdablue}{λ.} (t  \tdot (\textcolor{agdablue}{\uparrow}σ))            \\
                  \mathsf{app} \quad & (t_1 \ t_2)                                                             & \tdot σ
                                     & = (t_1  \tdot σ) \ (t_2  \tdot σ)
            \end{alignat*}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.60\textwidth}
            \raggedright
            \textbf{Interaction Laws}
            \begin{alignat*}{2}
                  \mathsf{id}_\mathsf{L} \quad         & \textcolor{agdablue}{\mathsf{id}} \ \textcolor{agdablue}{;} \  σ                                                                                                    &  & = σ                                                                                \\
                  \mathsf{id}_\mathsf{R} \quad         & σ \ \textcolor{agdablue}{;} \  \textcolor{agdablue}{\mathsf{id}}                                                                                                    &  & = σ                                                                                \\
                  \mathsf{assoc}          \quad        & (σ_1 \ \textcolor{agdablue}{;} \  σ_2) \ \textcolor{agdablue}{;} \  σ_3                                                                                             &  & = σ_1 \ \textcolor{agdablue}{;} \  (σ_2 \ \textcolor{agdablue}{;} \  σ_3)          \\
                  \mathsf{dist}           \quad        & (t \textcolor{agdablue}{\cdot} σ_1) \ \textcolor{agdablue}{;} \  σ_2                                                                                                &  & = (t \tdot σ_2) \textcolor{agdablue}{\cdot} (σ_1 \ \textcolor{agdablue}{;} \  σ_2) \\
                  \mathsf{int}       \quad             & \textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \  (t \textcolor{agdablue}{\cdot} σ)                                                                    &  & = σ                                                                                \\
                  \eta\mathsf{\text{-}id}        \quad & (\textcolor{agdablue}{\texttt{\`{}}\mathsf{zero}}) \textcolor{agdablue}{\cdot} \textcolor{agdablue}{\mathsf{wk}}                                                    &  & = \textcolor{agdablue}{\mathsf{id}}                                                \\
                  \eta\mathsf{\text{-}law}       \quad & (\textcolor{agdablue}{\mathsf{zero}} \textcolor{agdablue}{\;\&\;} σ) \textcolor{agdablue}{\cdot} (\textcolor{agdablue}{\mathsf{wk}} \ \textcolor{agdablue}{;} \  σ) &  & = σ
            \end{alignat*}
            \vspace{2pt}
            \textbf{Monad Laws}
            \begin{alignat*}{2}
                  \mathsf{r\text{-}id} \quad  & t  \tdot \mathsf{id}      &  & = t                                          \\
                  \mathsf{comp}         \quad & (t  \tdot σ_1)  \tdot σ_2 &  & = t  \tdot (σ_1 \textcolor{agdablue}{;} σ_2)
            \end{alignat*}
      \end{minipage}
      \caption{The three-sorted $σ$-calculus}\label{fig:pre-sig}
\end{figure}

The $\sigma$-calculus~\cite{10.1145/96709.96712} formalizes substitutions via
explicit reduction rules. We utilize a three-sorted variant of the
$σ_{SP}$-calculus~\cite{10.1145/2676724.2693163}, which provides a sound,
confluent~\cite{10.1145/226643.226675}, and
complete~\cite{10.1145/2676724.2693163} foundation. Our instantiation for the
$λ$-calculus is presented in \cref{fig:pre-sig}.

The syntax distinguishes between de~Bruijn variables, terms, and parallel
substitutions. Parallel substitutions map variables to terms and support
composition. Unlike standard accounts, we include explicit syntax for variable
usage, requiring distinct symbols for \bsym{\textsf{suc}} and
\bsym{\textsf{wk}} to shift variables or substitutions, respectively. Applying
\bsym{\textsf{wk}} to a term shifts all internal variables. We also define a
\textit{lifting} shorthand to push substitutions under binders; lifting
preserves the bound variable while weakening the substitution's terms to
maintain correct scoping.

Following~\cite{Stark:2020:Mechanising}, we categorize reduction rules into
four groups:
\begin{itemize}
      \item \textbf{Definitional}: Variable lookup in substitutions.
      \item \textbf{Interaction}: Equalities between substitution expressions.
      \item \textbf{Traversal}: Propagation through terms and under binders.
      \item \textbf{Monad}: Behavior of substitutions applied to terms.
\end{itemize}
We omit object-language reductions (e.g., $β$-reduction) to focus strictly on
substitution behavior. While renamings as first-class constructs will break
completeness~\cite{10.1145/3293880.3294101}, we prioritize a large space of
solvable equations. We maintain that our three-sorted variant remains
terminating and confluent.

TODO: TALK ABOUT EXTENSION WITH FIRST CLASS RENAMINGS

\subsection{Multi-Sorted and Scoped Syntaxes in Agda}\label{sec:pre-syn}
\begin{figure}[t]
      \centering
      \footnotesize % Standard for dense Agda code blocks in LIPIcs
      \begin{minipage}[t]{0.40\linewidth}
            \raggedright
            % Optional: add a small negative \vspace if your code commands have built-in padding
            \EScoped{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.58\linewidth}
            \raggedright
            \EMultiSorted{}
      \end{minipage}
      \vspace{-1em} % Pull the caption closer to the code to save vertical space
      \caption{Classically Scoped Syntax vs. Multi-Sorted and Scoped Syntax}\label{fig:pre-svm}
\end{figure}

Unlike $λ$-calculus, many languages feature multiple syntactic categories.
System~F~\cite{girard1972, 10.1007/3-540-06859-7_148}, for instance, has
expressions, types, and kinds. To prevent scoping errors, we utilize
\textit{intrinsically scoped syntax}, where inductive syntax definitions are
indexed by free variables to ensure terms are correctly scoped by construction.
\Cref{fig:pre-svm} (left) shows a standard implementation: types are indexed by
type-variable counts, and expressions by both type and expression variable
counts. Variables use de Bruijn indices (\AgdaDatatype{Fin} \AgdaBound{n}).
% While the \AgdaDatatype{Kind} type could technically be omitted here since types are well-formed by construction. 
This separate-datatype approach requires defining many substitution
permutations (e.g., type-in-type, type-in-expr, expr-in-expr).

To avoid this combinatorial explosion, we define the uniform, multi-sorted
syntax in \cref{fig:pre-svm} (right). Terms form a single datatype
(\AgdaBound{S} \AgdaDatatype{⊢} \AgdaBound{s}) indexed by a target sort
\AgdaBound{s} and a \AgdaDatatype{Scope} \AgdaBound{S} (a list of variable
sorts). Variables are represented by membership proofs (\AgdaBound{S}
\AgdaDatatype{∋} \AgdaBound{s}) that act as de Bruijn indices. This unified
structure enables renamings and substitutions to operate uniformly across all
sorts.

\section{The Sigma Calculus with Separate Renamings and Substitutions}\label{sec:mis}
This section presents a direct embedding of the $σ$-calculus rules with
first-class renamings, following the conceptual theory underlying
\textsc{Autosubst 2}, as native reduction rules in Agda using its rewrite
mechanism. We use the multi-sorted and scoped version of SystemF
from~\cref{fig:pre-svm} as an example for any custom syntax. The approach
described in this section directly translates to any multi-sorted and scoped
syntax definition.

\subsection{Scoped and Multi-Sorted Renamings and Substitutions}\label{sec:mis-sub}
\begin{figure}[t]
      \centering
      \footnotesize % Consistent with previous small figures
      \begin{minipage}[t]{0.43\linewidth}
            \raggedright
            \ERen{}
            \ESub{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.54\linewidth}
            \raggedright
            \ESubInst{}
      \end{minipage}
      \vspace{-0.5em} % Tightens the gap between the code and the caption
      \caption{Scoped and Multi-Sorted Renamings and Substitutions (excerpt)}\label{fig:mis-ras}
\end{figure}

We define renamings (\AgdaFunction{\_→ᴿ\_}) and substitutions
(\AgdaFunction{\_→ˢ\_}) uniformly over all variable sorts by indexing them over
scopes, as shown in \cref{fig:mis-ras}. A renaming from scope \AgdaBound{S₁} to
\AgdaBound{S₂} maps each variable of a given sort in \AgdaBound{S₁} to a
variable of the same sort in \AgdaBound{S₂}. Similarly, substitutions map
variables to terms of the corresponding sort.

We first define the renaming type and its primitive operations: identity
(\AgdaFunction{idᴿ}), weakening (\AgdaFunction{wkᴿ}) and extension
(\AgdaFunction{\_·ᴿ\_}). Substitution primitives mirror those for renamings,
but use the superscript S instead of R, except for weakening, which is strictly
a renaming. The order of definitions is chosen carefully to obtain a
structurally recursive definition. We use the structurally smaller weakening
renaming to define lifting of substitutions (\AgdaFunction{\_↑ˢ\_}).

To support all composition combinations of renamings and substitutions, we
provide four forward composition primitives: renaming composed with renaming
(\AgdaFunction{\_;ᴿᴿ\_}), renaming with substitution
(\AgdaFunction{\_;ᴿˢ\_})\footnote{The first two composition operators can
      technically be merged into a single definition. Both are simply forward
      function composition, but we choose to keep them separated.}, substitution with
renaming (\AgdaFunction{\_;ˢᴿ\_}), and substitution with substitution
(\AgdaFunction{\_;ˢˢ\_}).

The traversal functions (\AgdaFunction{\_⋯ᴿ\_} for renaming and
\AgdaFunction{\_⋯ˢ\_} for substitution) are defined by structural induction on
the syntax. Each clause applies a renaming or substitution to a object language
term, lifting the renaming or substitution, when going under a binder. The
clauses in both definitions correspond directly to the traversal laws of the
$σ$-calculus, and therefore, we want these functions to reduce during type
checking. When adapting this approach to arbitrary custom syntaxes, the
traversal functions are the only definitions that must be provided by the user.
All other definitions can be stated independently of the concrete syntax.

Renaming and substitution primitives are declared opaque, which blocks their
reduction. This abstraction is crucial for rewriting the $σ$-calculus laws,
where the primitives must act as uninterpreted symbols rather than as concrete
functions. Blocking reduction in this way allows rewrite rules to apply
predictably. The types for renamings and substitutions are declared opaque to
prevent their misuse as actual functions. Renamings and substitutions should
not behave as functions, because rewriting cannot be performed on a stuck
function applied to an argument. Instead, we introduce explicit syntax for
function application (\AgdaFunction{\_\&ᴿ\_} and \AgdaFunction{\_\&ˢ\_}) to
allow rewriting on a renaming or substitution applied to a variable.

\subsection{The Sigma Calculus with First-Class Renamings}\label{sec:mis-sig}
\begin{figure}[t]
      \centering

      \begin{minipage}[t]{0.38\linewidth}
            \raggedright{}
            \EDefLaws{}
            \ERewriteSys{}
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.58\linewidth}
            \raggedright{}
            \EInteractLaws{}
            \EMonadLaws{}
      \end{minipage}
      \caption{The Scoped and Multi-Sorted $σ$-calculus with First-Class Renamings}\label{fig:mis-sig}
\end{figure}

While we could opt to restrict the relevance of renamings to the structural
definition of substitutions and state the laws only for substitutions, it is
often useful to reason about renamings directly, for instance in the context
morphism lemma~\cite{goguen1997candidates}. We therefore, similar to Autosubst,
treat renamings as first-class constructs.\ \cref{fig:mis-sig} presents the
$σ$-calculus laws with first-class renamings. They all satisfy the requirements
from \cref{sec:pre-agd} and qualify as rewrite rules.

The \textbf{Definitional Laws} now involve primitives for both renamings and
substitutions. The \textbf{Interaction Laws} likewise cover all operators. Many
of these laws are similar in shape. For instance, we require eight
associativity laws. The \textbf{Traversal Laws} follow directly from the
definition of traversal given in the previous section.

Most of the laws can be proven independently of the concrete syntax. In
contrast, the \textbf{Monad Laws} must be shown by induction over the syntax
and vary for each object language definition. We highlight syntax-dependent
laws in red throughout this work.

\cite{10.1145/3293880.3294101} noticed that a further category emerges from the interaction between
renamings and substitutions. The \textbf{Coincidence Laws} govern the case where
substitutions are intertwined with renamings, but the renamings can be
separated from them, and applied to a term separately.
The coincidence and the coincidence-fold laws
enable us to recover renamings from their embedding as substitutions via the
identity substitution. Extracting arbitrary renamings from deeply nested substitutions would require a
dedicated solving strategy, which we leave for future work but consider
important for a more complete account.

In her PhD thesis, \cite{Stark:2020:Mechanising} proves the
\AgdaFunction{coincidence} law by induction over the syntax. The law is not
syntax-dependent when composition between renamings and substitutions is
included in the theory and the monad laws are available: \ECoincidenceProof{}
The remaining coincidence laws follow analogously.

The exact influence of coincidence laws on the metatheory of the rule set as a
whole still needs to be examined in detail but it is believed their addition
preserves termination and confluence~\cite{10.1145/3293880.3294101}. Agda
cannot determine that the set of rewrite rules is confluent using its built-in
checks. To make the rules amenable to such analysis, a critical pair analysis
in the spirit of the Knuth-Bendix completion algorithm~\cite{Knuth1983} would
be required to split the rules into components that Agda can recognize as
collectively confluent.

To prove the $σ$-calculus laws presented in \cref{fig:mis-sig}, we need to
unfold the definitions of the renamings and substitutions primitives. Laws
colored blue can be proven syntax-independently, while laws colored in red need
to be proven by structural induction over the syntax. Our implementation, found
in the supplement, makes use of function extensionality, which is safe to
postulate in Agda. It is known that with a little more effort, this assumption
is not necessary.

\subsection{Discussion}\label{sec:mis-dis}
The laws presented in \cref{sec:mis-sig} are an extension of the classic
$σ$-calculus rules to a setting with renamings. They fulfill the requirements
to be registered as rewrite rules without further modification. This is a
consequence of marking the relevant symbols opaque. Inside the proofs of the
laws themselves, the definitions can still unfold when needed, while externally
they behave as uninterpreted symbols and are reduced only by the $σ$-calculus
laws.

The main drawback of the approach with separated renamings and substitutions is
the unavoidable duplication of similar definitions and proofs. Associativity
laws pose little difficulty as they can be stated independently of the syntax,
but the definition of traversal and monad laws must be provided explicitly.
These include two traversal definitions, two right-identity laws, and four
compositionality laws, all similar in shape. Even if syntax-dependent
definitions and laws are derived automatically, every subsequent result about
substitutions would still need to be proven twice, once for renamings and once
for general substitutions.

\section{Avoiding Transfer Hell in Complex Intrinsically Typed Syntax}\label{sec:its}

\section{TBD}\label{sec:ags}

\section{Further Work}\label{sec:wrk}
This section outlines possible directions for improving \textsc{Agdasubst} in
the future.

In contrast to most of the other substitution libraries, users of
\textsc{Agdasubst} still need to manually provide the definition for traversal
and the syntax-dependent proofs (Monad and Coincidence Laws).
\cite{saffrich:LIPIcs.ITP.2024.32} has shown that definitions and proofs for
scoped syntax can be derived automatically using Agda's reflection mechanism.
There is no reason why the same approach could not be applied for the
definitions and proofs required to instantiate \textsc{Agdasubst}.

\cite{Stark:2020:Mechanising} introduced several interesting extensions to the $σ$-calculus that could also be implemented in \textsc{Agdasubst}. One extension is support for variadic bindings (unknown number of variables bound), useful for languages with pattern matching. Another extension is support for lists of terms, allowing an unknown number of terms in the syntax tree. This would, for example, enable support for languages with $n$-ary application.
The latter can already be encoded in the current system by inlining the list
data structure directly into the syntax definition and treating
them as terms of a new sort.

In its current state, \textsc{Agdasubst} completely lacks a meta-theoretical
analysis. While we conjecture it to be terminating and confluent, it would be
interesting to formally establish these properties.

As noted, \textsc{Agdasubst} is not complete when reasoning simultaneously
about renamings, substitutions and Maps. It would therefore be worthwhile to
investigate additional laws, in the spirit of the coincidence laws, to increase
the space of solvable equations. \textsc{Autosubst 2} already provides a more
sophisticated tactic for the separation of renamings from substitutions, which
could serve as a useful starting point for deriving such additional laws in
\textsc{Agdasubst}.

At the moment, the performance of \textsc{Agdasubst} is, to be honest, very
poor. For instance, the proof of subject reduction for System~F with subtyping
requires several minutes to check. Our analysis shows that most of this time is
spent on instance resolution and function coverage analysis (i.e., verifying
that pattern matching clauses are exhaustive). Currently, we have no concrete
strategy to improve these aspects, without decreasing user-experience, except
that we know, that the addition of the coincidence laws dramatically increases
type-checking time.

\section{Related Work}\label{sec:rwk}

\subsection*{Explicit Substitution Calculi}
There exist a variety of explicit substitution calculi, but we focus on the
original $σ$-calculus~\cite{10.1145/96709.96712}, which includes identity,
extension, shifting, and composition primitives, and the
$σ_{SP}$-calculus~\cite{10.1145/2676724.2693163}, which adds further reductions
to ensure confluence. Only the $σ_{SP}$-calculus is both sound and complete,
enabling all equations between terms to be derived via reduction. Both
completeness and convergence are established through mechanized
proofs~\cite{10.1145/2676724.2693163, Stark:2020:Mechanising}.

\subsection*{Abstractions over Variables/Terms and Renamings/Substitutions}
We already discussed the original work on Kits~\cite{ren-sub} and their
adaptation to multi-sorted and scoped syntax~\cite{saffrich:LIPIcs.ITP.2024.32}
throughout \cref{sec:ags}.

The intrinsically scoped version of this approach also appears in recent work,
for example in a paper written by \cite{altenkirch2025substitution}, where a
uniform treatment of renaming and substitution is explored in an intrinsically
typed setting. Their work also includes a structure and definitions similar to
the structural kit order we defined in \cref{sec:ags-sko}. They additionally
unify variables and terms, which we deliberately do not do, as variables are
library-defined while terms are user-supplied. Furthermore they hide the
structual dependence of renamings and substitutions in the kit structure
itself, using terminating checking directly, to make Agda see this dependence.
The approach by saffrich instead hides it behind instead hide it in instance
resolution. A further application of the Kit approach is given by
\cite{Wood_2021}, who use it to reason about metatheory in the context of
linear languages.% TODO

Another line of research concerns generic programming
approaches~\cite{allais2021typescopesafeuniverse, 10.1145/3018610.3018613},
which allow the construction of syntax trees from general building blocks
supporting sums, products, and binder introduction. The generic programming
approach also allows for a generic structure that abstracts not only over
renamings and substitutions, but also over semantics and other relevant
language structures. The generic syntax approach can be adapted to a scoped and
multi-sorted setting~\cite{saffrich:LIPIcs.ITP.2024.32}. Importantly, generic
programming and the \textsc{Agdasubst} library are orthogonal, as shown
in~\cref{sec:ext-uni}.

\subsection*{Substitution Libraries for Proof Assistants}
We have already discussed \textsc{Autosubst 2}~\cite{10.1145/3293880.3294101,
      schafer2015autosubst, Stark:2020:Mechanising} which forms the direct
theoretical foundation of our work.

There exists another Agda library with a similar goal to \textsc{Agdasubst},
called \textsc{Abstract Binding Trees}, used for instance by
\cite{siek2021parameterized}. It permits constructing an object language from a
generic syntax, similar to the approach in \cref{sec:ext-uni}, but it supports
only extrinsic scoping and single-sorted syntaxes. The library provides
abstractions over arbitrary predicates about the object language, rather than
focusing on specific relations such as
typing~\cite{saffrich:LIPIcs.ITP.2024.32}. The library also offers incomplete
experimental support for rewriting using $\sigma$-calculus laws, but only
handles renamings and substitutions separately, similar to the approach in
\cref{sec:mis-sig}, rather than in a uniform treatment.

More distantly related is \textsc{Nominal 2}~\cite{Nominal2-AFP}, an Isabelle
package that addresses the $α$-equivalence problem not via de Bruijn indices,
but using nominal datatypes and freshness conditions. Their approach is closer
to the intuitive notion of variables, but the tool does not provide any
strategy for solving equations involving terms and substitutions.

Additionally, there are tools such as \textsc{Needle and
      Knot}~\cite{10.1007/978-3-662-49498-1_17}, which is a code generator for
unscoped syntax using de Bruijn indices. The tool generates substitution and
interaction lemmas for single-pointed substitutions for languages that feature
multiple variable sorts and variadic binders.

\section{Conclusion}\label{sec:con}
We have shown how to take advantage of the $σ$-calculus laws to automatically
solve equations inside proofs about syntaxes with binding in Agda, similar to
\textsc{Autosubst 2} in Rocq.

We first embedded the $σ$-calculus with first-class renamings directly into
Agda as reduction rules, using its rewrite mechanism to yield definitional
equalities for a formalization of System~F.

We then wanted to unify proofs about renamings and substitutions, which led to
the current state of the \textsc{Agdasubst} library. To achieve our goal, we
introduced the notions of Kits and Maps from prior work and adapted the
$σ$-calculus laws to a Kit and Map setting.

We demonstrated how \textsc{Agdasubst} can be used to prove properties
involving substitutions for formal languages, including subject reduction for
System F with subtyping using a single substitution-preserves-typing lemma, and
provided an instantiation of a scoped universe of syntaxes with binding.

The \textsc{Agdasubst} library does not constitute a stable release candidate
yet. We have outlined potential directions for future development and plan to
continue improving the library over time.

\bibliography{references}

\end{document}
