\documentclass[manuscript,screen,review,anonymous,acmsmall]{acmart}
\usepackage[capitalize,noabbrev]{cleveref}

\usepackage{agda}
\usepackage{stmaryrd}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

\input{examples}
\input{SystemF1}
\input{STLC}
\input{unicodeletters}

\begin{document}

\title{Intrinisically Typed Syntax That Works (Functional Pearl)}

\author{Peter Thiemann}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}

\author{Marius Weidner}
\email{weidner@cs.uni-freiburg.de}
\affiliation{%
  \institution{University of Freiburg}
  % \city{Hekla}
  \country{Germany}}
\orcid{0009-0008-1152-165X}

\begin{abstract}

\end{abstract}

\maketitle
\keywords{Intrinisically Typed Syntax, Strictification, Agda}

\section{Introduction}
\label{sec:introduction}

When formalizing the metatheory of a programming language in a proof
assistant based on dependent type theory, variable binders are often
represented by de Bruijn indices. In some proof assistants, notably in
Agda, it is not uncommon to go an extra step and use intrinsically
typed syntax. This idea goes back to Curry-style vs.\ Church-style
formalizations of lambda calculus: the former style has an untyped
semantics and typing is externally imposed; in the latter style, it is
impossible to construct untyped terms and semantics is only assigned
to typed terms. Thus, untyped syntax gives rise to a Curry-style
presentation, whereas intrinsically typed syntax results in a
Church-style presentation.

\begin{figure}[tp]
  \begin{minipage}[t]{0.49\linewidth}
  \STLCTypeCtx
  \STLCVar
  \STLCExpr 
  \end{minipage}
  ~
  \begin{minipage}[t]{0.49\linewidth}
    \STLCSmallStep
    \STLCProgress
  \end{minipage}
  \caption{Call-by-name simply-typed lambda calculus}
  \label{fig:simply-typed-syntax}
\end{figure}
The simply-typed lambda calculus provides an appealing example where
intrinsically typed syntax works well. \Cref{fig:simply-typed-syntax}
shows typical definitions of the 
syntax of types, type contexts, variables, and expressions, which are
indexed by contexts and types (left column). Building on these definitions it is
straightforward to define denotational or operational
semantics. Proving type safety for a small-step operational semantics
is also easy as subject reduction holds by definition and progress
follows by a simple inductive proof (right column). The style of these
definitions is adapted from the textbook by
\citet{DBLP:journals/scp/KokkeSW20}. We elide the definition  of the
substitution operator $\_[\_]$, as we discuss substitutions in detail
in \cref{sec:types}.

However, managing intrinsically typed syntax can become significantly
more demanding. For example, \citet{10.1007/978-3-030-33636-3_10}
present a formalization of System $F_\omega$, which is inspired by
prior work of \citet{DBLP:conf/csl/AltenkirchR99},
\citet{DBLP:phd/ethos/Chapman09}, and
\citet{DBLP:conf/cpp/Allais0MM17}. \citet{10.1007/978-3-030-33636-3_10}
start by defining kinds,
kind contexts, type variables, and type expressions, which are
isomorphic to the simply-typed lambda calculus, followed by the
development of type renamings and simultaneous type substitutions
\cite{DBLP:journals/jar/BentonHKM12}. On top of this type framework,
they define type contexts, expression variables, and expressions,
again followed by renaming and simultaneous substitution on
expressions. Crucially, expression renamings are indexed by type
renamings and expression substitution by type substitutions in their
framework. While indexing works smoothly for these definitions,
it complicates the proofs of some properties with uninteresting type
corrections, aka transfer hell.

Transfer hell is the colloquial term for being forced to apply
type-changing lemmas to terms that are already known to be equal. This
situation is annoying because proof assistants like Agda plainly
refuse to let users even state this equality.\footnote{A situation
  that can be addressed using heterogeneous equality introduced in
  Conor McBride's thesis.} A workaround is to state definitions and
proofs with explicit equivalence relations, but this practice is
cumbersome, inefficient, and far away from the holy grail of
definitional equality, which just works.

In this paper, we examine the transfer hell arising by
intrinsically-typed syntax encodings of System-F and
System-F$\omega$. Specifically, we consider the problems arising with
type-renaming-indexed renamings and type-substitution-indexed
substitutions. We propose to install the laws of the sigma calculus as
definitional equalities for type substitutions, thus simplifying
substitutions with the same approach like the tactics of Autosubst
\cite{schafer2015autosubst,Stark:2020:Mechanising,10.1145/3293880.3294101},
but automatically by rewriting \cite{10.1145/3434341}. We build on a
standard functional representation of renamings and substitutions
\cite{DBLP:journals/jar/BentonHKM12}, prove the lemmas underlying the
equational laws of the sigma calculus, and then inject these equations
into Agda's rewrite engine, i.e., make the sigma calculus equations
definitional (for type substitutions). The tricky part of this injection is to
obtain a confluent and terminating rewrite system in connection with
the existing definitional equalities.

We first exercise this program for plain System-F in
\cref{sec:system-f}, radically simplifying the transfer-ridden approach used by
\citet{10.1145/3678000.3678201}, 
and then apply the same techniques to System-F$\omega$ in
\cref{sec:system-fomega}. In the latter, the main difference to
previous work \cite{10.1007/978-3-030-33636-3_10} lies in our
intrinsic treatment of type conversion, which leads to significant
simplifications. 


\section{System F}
\label{sec:system-f}

\subsection{Types}
\label{sec:types}

\begin{figure}[tp]
  \begin{minipage}[t]{0.49\linewidth}
    \SFTypeRenaming
    \SFTypeRenamingOpaque
  \end{minipage}
  \begin{minipage}[t]{0.49\linewidth}
    \SFTypeSubstitution
    \SFTypeSubstitutionOpaque
  \end{minipage}
  \caption{Renamings and substitutions on types}
  \label{fig:system-f-ren-sub}
\end{figure}

The syntax of System-F types uses the standard de Bruijn encoding of
variables by natural numbers. The index $n$ stands for the number of
type variables in scope. Variables are drawn from the type $Fin n$, i.e.,
the set $\{0,\dots, n-1\}$. The $\forall$-binder introduces a new type
variable, and $\Rightarrow$ is the infix function type constructor.
\SFTypeDefinition

\Cref{fig:system-f-ren-sub} contains the first step in defining
type renamings (left column) and substitutions (right column).
A type renaming maps variables from one scope $n_1$ to
another $n_2$. We write the type of type renamings as $n_1 \to^R n_2$.
The definitions comprise (in order) weakening, the identity renaming,
pushing a new mapping for variable
\AgdaInductiveConstructor{zero} on a renaming, applying a renaming to a variable,
composing two renamings, extending a renaming (to move under a
binder), and applying a renaming to a type.

A this point, the astute reader may wonder about the use of
\AgdaKeyword{opaque} in the definitions. The function symbols defined in an
\AgdaKeyword{opaque} block are usable from outside, but their
computational behavior is hidden. Thus, the only normal definition is
$\uparrow^R$ for extending a renaming. This selective hiding is
essential for our approach because we want to establish new definitional
equalities (i.e., the laws of the sigma calculus with first-class
renamigns) on top of the thus defined symbols. These new equalities 
interfere in a bad way with the standard definitional equalities, thus
we hide the latter. To prove these equalities, we open the opaque
definitions locally and proceed as usual.

For substitutions (right column of \cref{fig:system-f-ren-sub}) we
proceed analogously. A type substitution maps variables from scope
$n_1$ to types defined over scope $n_2$. We write the type of type
substitutions as $n_1 \to^S n_2$. The definitions (in order)
comprise
lifting a renaming to a substitution, pushing a new mapping on a
substitution, applying a substitution to variable, extending a
substitution (to move under a binder), applying a substitution to a
type, and composing two substitutions.

\begin{figure}[tp]
  \begin{flushleft}
    \SFTypeRenamingBeta
    \SFTypeSubstitutionBeta
    \SFTypeMonad
    \SFTypeCoincidence
  \end{flushleft}
  \caption{Equational laws of the sigma calculus with first class
    renamings}
  \label{fig:system-f-sigma-calculus}
\end{figure}

\Cref{fig:system-f-sigma-calculus} gives the equational laws of the
sigma calculus with first-class renamings \cite{schafer2015autosubst}.
All of these equalities are supported by proofs using the definitions from
\cref{fig:system-f-ren-sub}, but the proofs are not included because
they are standard.

The first group gives computation rules for renamings, in particular,
how to apply the different forms of renamings to a variable. The
second group presents interaction laws for renamings. Most of them
deal with composition.

The third group presents computation rules for substitutions starting
with the application of a substitution to a variable. There is one
equation for each possible form of a substitution: pushed
substitution, lifted renaming, and composition of substitutions. The
final equation in this group characterizes lifting in terms of push,
weakening, and composition.

The fourth group contains laws about composition of substitutions,
which are mostly analogous to the corresponding laws for renamings.

The fifth group presents laws that govern the composition of different
kinds of term traversal. All four combinations of applying renamings
and substitutions to a type are covered.

The final group covers laws that provide shortcuts and cover critical
pairs that arise from the preceding laws.

\subsection{Expressions}
\label{sec:expressions}



\section{System F$\omega$}
\label{sec:system-fomega}



\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\appendix

\section{Proofs}

\end{document}
\endinput

